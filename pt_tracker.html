<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="PT Tracker">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%23007AFF' rx='20'/><text x='50' y='70' font-size='60' text-anchor='middle' fill='white'>ðŸ’ª</text></svg>">
    <meta name="theme-color" content="#007AFF">
    <title>PT Exercise Tracker</title>
    <style>
        :root {
            --ios-blue: #007AFF;
            --ios-red: #FF3B30;
            --ios-green: #34C759;
            --ios-orange: #FF9500;
            --ios-gray: #8E8E93;
            --ios-background: #F2F2F7;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: var(--ios-background);
            color: #000;
            touch-action: manipulation;
            user-select: none;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            background: white;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header h1 {
            font-size: 20px;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .exercise-name {
            font-size: 17px;
            color: var(--ios-blue);
            font-weight: 600;
        }

        /* Main Counter View */
        .counter-view {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 250px);
            padding: 20px;
        }

        .set-info {
            font-size: 17px;
            color: var(--ios-gray);
            margin-bottom: 20px;
        }

        .counter-display {
            width: min(320px, 85vw);
            height: min(320px, 85vw);
            border-radius: 50%;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 72px;
            font-weight: 700;
            color: var(--ios-blue);
            box-shadow: 0 4px 20px rgba(0, 122, 255, 0.3);
            margin-bottom: 30px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .counter-display:active {
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(0, 122, 255, 0.2);
        }

        .timer-display {
            font-size: 64px;
            font-weight: 700;
            color: var(--ios-blue);
            margin-bottom: 20px;
        }

        .timer-display.warning {
            color: var(--ios-orange);
        }

        .timer-display.danger {
            color: var(--ios-red);
        }

        .target-info {
            font-size: 17px;
            color: var(--ios-gray);
            margin-bottom: 30px;
        }

        .remaining-info {
            font-size: 18px;
            font-weight: 600;
            color: #1c1c1e;
            text-align: center;
            margin-bottom: 12px;
        }

        .progress-bar-container {
            width: 100%;
            max-width: 300px;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--ios-blue), var(--ios-green));
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 12px;
            width: 100%;
            max-width: 400px;
            padding: 0 20px;
        }

        .control-btn {
            flex: 1;
            padding: 14px;
            font-size: 17px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
        }

        .control-btn:active {
            transform: scale(0.98);
            opacity: 0.8;
        }

        .btn-primary {
            background: var(--ios-blue);
            color: white;
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3);
        }

        .btn-secondary {
            background: white;
            color: var(--ios-blue);
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
        }

        .btn-success {
            background: var(--ios-green);
            color: white;
            box-shadow: 0 2px 8px rgba(52, 199, 89, 0.3);
        }

        .btn-danger {
            background: var(--ios-red);
            color: white;
            box-shadow: 0 2px 8px rgba(255, 59, 48, 0.3);
        }

        /* Footer */
        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            padding: 12px;
            padding-bottom: max(12px, env(safe-area-inset-bottom));
            border-top: 0.5px solid rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 12px;
            z-index: 999;
        }

        .footer button {
            flex: 1;
            padding: 14px;
            font-size: 17px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.1s, opacity 0.2s;
        }

        .footer button:active {
            transform: scale(0.98);
            opacity: 0.8;
        }

        /* iOS Bottom Sheet Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.4);
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.25s ease;
        }

        .modal.active {
            display: block;
            opacity: 1;
        }

        .modal-content {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--ios-background);
            border-radius: 20px 20px 0 0;
            padding: 0;
            max-height: 90vh;
            overflow-y: auto;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 -2px 20px rgba(0,0,0,0.15);
        }

        .modal.active .modal-content {
            transform: translateY(0);
        }

        .modal-drag-handle {
            width: 36px;
            height: 5px;
            background: rgba(0,0,0,0.2);
            border-radius: 3px;
            margin: 12px auto 8px;
        }

        .modal-title {
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            padding: 8px 20px 16px;
            color: #000;
            border-bottom: 0.5px solid rgba(0,0,0,0.1);
        }

        .modal-form {
            padding: 20px;
        }

        .modal-input, .modal-select {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 17px;
            margin-bottom: 12px;
            font-family: inherit;
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .modal-input:focus, .modal-select:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--ios-blue);
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            padding: 0 20px 20px;
        }

        .modal-buttons button {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 12px;
            font-size: 17px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.1s;
        }

        .modal-buttons button:active {
            transform: scale(0.98);
            opacity: 0.8;
        }

        .modal-save {
            background: var(--ios-blue);
            color: white;
        }

        .modal-cancel {
            background: white;
            color: var(--ios-blue);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        /* iOS Action Sheet */
        .action-sheet-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.25s ease;
        }

        .action-sheet-backdrop.active {
            display: block;
            opacity: 1;
        }

        .action-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: transparent;
            z-index: 3001;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 8px;
        }

        .action-sheet.active {
            transform: translateY(0);
        }

        .action-sheet-content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 14px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .action-sheet-message {
            padding: 20px;
            text-align: center;
            color: var(--ios-gray);
            font-size: 13px;
            border-bottom: 0.5px solid rgba(0, 0, 0, 0.1);
        }

        .action-sheet-button {
            width: 100%;
            padding: 16px;
            background: transparent;
            border: none;
            font-size: 20px;
            cursor: pointer;
            border-bottom: 0.5px solid rgba(0, 0, 0, 0.1);
            color: var(--ios-blue);
            transition: background 0.2s;
        }

        .action-sheet-button:last-child {
            border-bottom: none;
        }

        .action-sheet-button:active {
            background: rgba(0, 0, 0, 0.05);
        }

        .action-sheet-button.destructive {
            color: var(--ios-red);
            font-weight: 600;
        }

        .action-sheet-cancel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 14px;
            width: 100%;
            padding: 16px;
            border: none;
            font-size: 20px;
            font-weight: 600;
            color: var(--ios-blue);
            cursor: pointer;
            transition: background 0.2s;
        }

        .action-sheet-cancel:active {
            background: rgba(0, 0, 0, 0.05);
        }

        .history-section {
            margin-bottom: 16px;
        }

        .history-heading {
            font-size: 15px;
            font-weight: 700;
            color: #1c1c1e;
            margin-bottom: 8px;
        }

        .history-list {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
            padding: 12px;
        }

        .history-item {
            padding: 10px 8px;
            border-bottom: 0.5px solid rgba(0, 0, 0, 0.06);
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-meta {
            font-size: 12px;
            color: var(--ios-gray);
            margin-top: 4px;
        }

        .pill {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            background: rgba(0, 122, 255, 0.1);
            color: var(--ios-blue);
            margin-right: 6px;
        }

        .pocket-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 4000;
        }

        .pocket-overlay.active {
            display: flex;
        }

        .pocket-pad {
            width: min(360px, 95vw);
            height: min(360px, 70vh);
            border-radius: 28px;
            background: white;
            color: var(--ios-blue);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            font-size: 56px;
            font-weight: 800;
            box-shadow: 0 12px 40px rgba(0,0,0,0.35);
            text-align: center;
            padding: 20px;
        }

        .pocket-meta {
            color: #3a3a3c;
            font-size: 16px;
            font-weight: 600;
        }

        .pocket-close {
            margin-top: 18px;
            background: rgba(0,0,0,0.75);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 20px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            width: 100%;
            max-width: 320px;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸ’ª PT Exercise Tracker</h1>
        <div style="display: flex; align-items: center; justify-content: space-between;">
            <div class="exercise-name" id="exercise-name">Goblet Squat</div>
            <button onclick="showExerciseDetailsModal()" style="background: transparent; border: none; font-size: 20px; cursor: pointer; padding: 4px 8px;">ðŸ“‹</button>
        </div>
    </div>

    <!-- Counter View -->
    <div class="counter-view" id="counter-view">
        <div class="set-info" id="set-info">Set 1 of 3</div>
        <div class="remaining-info" id="remaining-info">Reps left: 10 Â· Sets left: 3</div>

        <!-- Counter Mode -->
        <div id="counter-mode">
            <div class="counter-display" id="counter-display" onclick="incrementCounter()" aria-live="assertive">0</div>
            <div class="target-info" id="target-info">Target: 10 reps</div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
        </div>

        <!-- Timer Mode -->
        <div id="timer-mode" class="hidden">
            <div class="target-info" id="timer-rep-info">Rep 1 of 10</div>
            <div class="timer-display" id="timer-display">00:00</div>
            <div class="target-info" id="timer-target">Target: 10 seconds</div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="timer-progress-bar"></div>
            </div>
            <div class="controls" style="margin-bottom: 20px;">
                <button class="control-btn btn-primary" id="timer-start-btn" onclick="startTimer()">Start Timer</button>
                <button class="control-btn btn-danger hidden" id="timer-stop-btn" onclick="stopTimer()">Stop</button>
                <button class="control-btn btn-secondary hidden" id="timer-reset-btn" onclick="resetTimer()">Reset</button>
            </div>
        </div>

        <div class="controls" id="main-controls">
            <button class="control-btn btn-secondary" onclick="previousSet()">Previous</button>
            <button class="control-btn btn-primary" onclick="showLogSetModal()">Log Set</button>
            <button class="control-btn btn-success" onclick="completeSet()">Complete Set</button>
        </div>
    </div>

    <div class="footer">
        <button class="btn-primary" onclick="showExerciseList()">Exercises</button>
        <button class="btn-secondary" onclick="showHistory()">History</button>
        <button class="btn-success" onclick="togglePocketMode(true)">Pocket</button>
    </div>

    <!-- Exercise Selection Modal -->
    <div class="modal" id="exercise-modal" onclick="if(event.target === this) closeExerciseModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Select Exercise</div>
            <div class="modal-form">
                <select class="modal-select" id="exercise-select" onchange="updateExerciseType()">
                    <option value="goblet_squat">Goblet Squat</option>
                    <option value="plank">Plank Hold</option>
                    <option value="step_ups">Step Ups</option>
                    <option value="clamshells">Clamshells</option>
                    <option value="bridge_hold">Bridge Hold</option>
                    <option value="pushup_amrap">Push-up AMRAP</option>
                    <option value="walk_distance">Walk (Distance)</option>
                </select>
                <select class="modal-select" id="exercise-type" onchange="updateTargetLabel()">
                    <option value="reps">Rep-based</option>
                    <option value="timed">Timed Reps</option>
                    <option value="hold">Hold</option>
                    <option value="duration">Duration</option>
                    <option value="amrap">AMRAP</option>
                    <option value="distance">Distance</option>
                </select>
                <input type="number" class="modal-input" id="sets-input" placeholder="Number of sets" value="3">
                <input type="number" class="modal-input" id="reps-input" placeholder="Reps per set" value="10">
                <input type="number" class="modal-input" id="target-input" placeholder="Target (seconds or distance)" value="10">
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeExerciseModal()">Cancel</button>
                <button class="modal-save" onclick="saveExercise()">Start</button>
            </div>
        </div>
    </div>

    <!-- Exercise List Modal -->
    <div class="modal" id="exercise-list-modal" onclick="if(event.target === this) closeExerciseList()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">My Exercises</div>
            <div class="modal-form">
                <input type="text" class="modal-input" id="exercise-search" placeholder="Search exercises..." oninput="filterExercises()">
                <div id="tag-filter-container" style="margin-bottom: 12px;"></div>
                <div id="recent-exercises-container" style="margin-bottom: 12px;"></div>
                <div class="history-list" id="exercise-list-content"></div>
                <div style="display: flex; gap: 8px; margin-top: 12px;">
                    <button class="control-btn btn-success" onclick="showAddExerciseModal()" style="flex: 1;">+ Add New</button>
                    <button class="control-btn btn-secondary" onclick="showArchivedExercises()" style="flex: 1;" id="archived-btn">ðŸ“¦ Archived</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add/Edit Exercise Modal -->
    <div class="modal" id="add-exercise-modal" onclick="if(event.target === this) closeAddExerciseModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title" id="add-exercise-title">Add Exercise</div>
            <div class="modal-form">
                <input type="text" class="modal-input" id="new-exercise-name" placeholder="Exercise name">
                <select class="modal-select" id="new-exercise-type">
                    <option value="reps">Rep-based</option>
                    <option value="timed">Timed Reps</option>
                    <option value="hold">Hold</option>
                    <option value="duration">Duration</option>
                    <option value="amrap">AMRAP</option>
                    <option value="distance">Distance</option>
                </select>
                <input type="number" class="modal-input" id="new-sets" placeholder="Sets (e.g., 3)" value="3">
                <input type="number" class="modal-input" id="new-reps" placeholder="Reps per set (e.g., 10)" value="10">
                <input type="number" class="modal-input" id="new-seconds" placeholder="Seconds (for timed)" value="">
                <div id="tag-selector-container" style="margin: 12px 0;"></div>

                <!-- ATLAS Features -->
                <div style="margin: 12px 0;">
                    <label style="display: flex; align-items: center; font-size: 15px; cursor: pointer;">
                        <input type="checkbox" id="bilateral-checkbox" style="margin-right: 8px;">
                        <span>Bilateral (both sides together)</span>
                    </label>
                </div>
                <div id="side-options-container" style="margin: 12px 0;"></div>
                <input type="text" class="modal-input" id="supersedes-input" placeholder="Supersedes (e.g., ex_basic_squats_01)">

                <!-- ATLAS: Muscles & Regions -->
                <textarea class="modal-input" id="primary-muscles" placeholder="Primary muscles (e.g., quadriceps, gluteus maximus)" style="min-height: 50px; resize: vertical;"></textarea>
                <textarea class="modal-input" id="anatomic-regions" placeholder="Anatomic regions (e.g., knee, hip, lower back)" style="min-height: 50px; resize: vertical;"></textarea>

                <!-- Equipment & Modifiers -->
                <select class="modal-select" id="equipment-select" multiple style="min-height: 80px;">
                    <option value="none">No equipment</option>
                    <option value="band">Resistance band</option>
                    <option value="weights">Weights/dumbbells</option>
                    <option value="ball">Exercise ball</option>
                    <option value="step">Step/platform</option>
                    <option value="wall">Wall</option>
                    <option value="chair">Chair</option>
                    <option value="foam_roller">Foam roller</option>
                    <option value="mat">Mat</option>
                </select>
                <div style="font-size: 12px; color: var(--ios-gray); margin-top: 4px; margin-bottom: 8px;">Hold Ctrl/Cmd to select multiple</div>

                <select class="modal-select" id="difficulty-select">
                    <option value="">Difficulty (optional)</option>
                    <option value="beginner">Beginner</option>
                    <option value="intermediate">Intermediate</option>
                    <option value="advanced">Advanced</option>
                </select>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeAddExerciseModal()">Cancel</button>
                <button class="modal-save" onclick="saveNewExercise()">Save</button>
            </div>
        </div>
    </div>

    <!-- Session Notes Modal -->
    <div class="modal" id="session-notes-modal" onclick="if(event.target === this) closeSessionNotesModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Session Notes (Optional)</div>
            <div class="modal-form">
                <textarea class="modal-input" id="session-notes" placeholder="How did it feel? Any pain? Progress notes..." style="min-height: 100px; resize: vertical;"></textarea>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="saveSessionWithNotes('')">Skip</button>
                <button class="modal-save" onclick="saveSessionWithNotes(document.getElementById('session-notes').value)">Save</button>
            </div>
        </div>
    </div>

    <!-- Log Set Modal -->
    <div class="modal" id="log-set-modal" onclick="if(event.target === this) closeLogSetModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title" id="log-set-title">Log Set</div>
            <div class="modal-form">
                <div style="font-size: 15px; color: var(--ios-gray); margin-bottom: 12px; text-align: center;" id="log-set-subtitle">
                    Enter actual reps performed
                </div>
                <input type="number" class="modal-input" id="log-set-reps" placeholder="Reps performed" min="0">
                <div id="log-set-side-selector" style="margin: 12px 0;"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeLogSetModal()">Cancel</button>
                <button class="modal-save" onclick="saveLoggedSet()">Save</button>
            </div>
        </div>
    </div>

    <!-- Exercise Details Modal -->
    <div class="modal" id="exercise-details-modal" onclick="if(event.target === this) closeExerciseDetailsModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title" id="exercise-details-title">Exercise Details</div>
            <div class="modal-form">
                <textarea class="modal-input" id="exercise-description" placeholder="Description (what is this exercise?)" style="min-height: 60px; resize: vertical;"></textarea>
                <textarea class="modal-input" id="exercise-tips" placeholder="Execution tips (form, alignment, cues)" style="min-height: 80px; resize: vertical;"></textarea>
                <textarea class="modal-input" id="exercise-feel" placeholder="Where to feel (target muscles)" style="min-height: 50px; resize: vertical;"></textarea>
                <textarea class="modal-input" id="exercise-not-feel" placeholder="Where NOT to feel (avoid strain)" style="min-height: 50px; resize: vertical;"></textarea>
                <textarea class="modal-input" id="exercise-modifications" placeholder="Modifications (easier/harder variations)" style="min-height: 60px; resize: vertical;"></textarea>
                <input type="number" class="modal-input" id="exercise-rest-seconds" placeholder="Rest between sets (seconds, optional)" min="0">
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeExerciseDetailsModal()">Cancel</button>
                <button class="modal-save" onclick="saveExerciseDetails()">Save</button>
            </div>
        </div>
    </div>

    <!-- Rest Timer Modal -->
    <div class="modal" id="rest-timer-modal">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Rest Timer</div>
            <div class="modal-form">
                <div style="text-align: center; font-size: 48px; font-weight: 700; color: var(--ios-blue); margin: 20px 0;" id="rest-countdown">60</div>
                <div style="text-align: center; font-size: 15px; color: var(--ios-gray); margin-bottom: 20px;">Rest between sets</div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="rest-progress-bar"></div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="skipRest()">Skip Rest</button>
                <button class="modal-save" onclick="closeRestTimer()">Continue</button>
            </div>
        </div>
    </div>

    <!-- History Modal -->
    <div class="modal" id="history-modal" onclick="if(event.target === this) closeHistoryModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">History</div>
            <div class="modal-form">
                <div class="history-section">
                    <div class="history-heading">Exercise revisions</div>
                    <div class="history-list" id="exercise-history-list"></div>
                </div>
                <div class="history-section">
                    <div class="history-heading">Recent sessions</div>
                    <div class="history-list" id="session-history-list"></div>
                </div>
                <button class="control-btn btn-primary" onclick="exportForPT()" style="width: 100%; margin-top: 12px;">Export Report for PT</button>
            </div>
        </div>
    </div>

    <!-- iOS Action Sheet -->
    <div class="action-sheet-backdrop" id="action-sheet-backdrop" onclick="hideActionSheet()"></div>
    <div class="action-sheet" id="action-sheet">
        <div class="action-sheet-content">
            <div class="action-sheet-message" id="action-sheet-message"></div>
            <button class="action-sheet-button destructive" id="action-sheet-confirm" onclick="confirmActionSheet()">Confirm</button>
        </div>
        <button class="action-sheet-cancel" onclick="hideActionSheet()">Cancel</button>
    </div>

    <!-- Eyes-free pocket tap overlay -->
    <div class="pocket-overlay" id="pocket-overlay" onclick="handlePocketTap()" aria-live="assertive">
        <div class="pocket-pad" role="button" aria-label="Pocket tap target">
            <div id="pocket-label">Tap to count</div>
            <div class="pocket-meta" id="pocket-meta">Reps left Â· Sets left</div>
        </div>
        <button class="pocket-close" onclick="togglePocketMode(false); event.stopPropagation();">Exit Pocket Mode</button>
    </div>

    <script>
        const STORAGE_KEY = 'pt_tracker_data';
        const LIBRARY_KEY = 'pt_exercise_library';
        const ATLAS_REFERENCE_URL = 'https://github.com/vouser123/rukuba/tree/revert-5-claude/enable-page-code-writing-MNryw';

        const ATLAS_SEED = [
            {
                id: 'goblet_squat',
                name: 'Goblet Squat (Example)',
                dosage: 'S3x10 (both)',
                supersedes: ['ex_basic_squats_01'],
                summary: 'Example exercise - edit or delete as needed'
            },
            {
                id: 'plank_hold',
                name: 'Plank Hold (Example)',
                dosage: 'S3x1',
                hold_seconds: 30,
                supersedes: [],
                summary: 'Example exercise - edit or delete as needed'
            },
            {
                id: 'step_ups',
                name: 'Step Ups (Example)',
                dosage: 'S3x10 (side)',
                supersedes: ['ex_basic_squats_01'],
                summary: 'Example exercise - edit or delete as needed'
            },
            {
                id: 'clamshells',
                name: 'Clamshells (Example)',
                dosage: 'S3x15 (side)',
                supersedes: [],
                summary: 'Example exercise - edit or delete as needed'
            },
            {
                id: 'bridge_hold',
                name: 'Bridge Hold (Example)',
                dosage: 'S3x1',
                hold_seconds: 30,
                supersedes: [],
                summary: 'Example exercise - edit or delete as needed'
            },
            {
                id: 'bike_intervals',
                name: 'Bike Intervals (Example)',
                dosage: 'S4x1',
                duration_seconds: 300,
                supersedes: [],
                summary: 'Example exercise - edit or delete as needed'
            },
            {
                id: 'pushup_amrap',
                name: 'Push-up AMRAP (Example)',
                dosage: 'AMRAP',
                amrap_window_sec: 60,
                supersedes: [],
                summary: 'Example exercise - edit or delete as needed'
            },
            {
                id: 'walk_distance',
                name: 'Walk (Example)',
                dosage: 'S1x400',
                distance_meters: 400,
                supersedes: [],
                summary: 'Example exercise - edit or delete as needed'
            }
        ];

        function parseAtlasDosage(dosage = '') {
            const match = /S(\d+)x(\d+)/i.exec(dosage);
            const sets = match ? parseInt(match[1], 10) : 3;
            const repsPerSet = match ? parseInt(match[2], 10) : 10;
            const isSide = /(side)/i.test(dosage);
            const isBoth = /(both)/i.test(dosage);

            return { sets, repsPerSet, side: isSide ? 'side' : isBoth ? 'both' : null };
        }

        function atlasSeedToSpec(entry) {
            const base = parseAtlasDosage(entry.dosage || '');
            const spec = {
                type: 'reps',
                sets: entry.sets_override || base.sets || 3,
                repsPerSet: base.repsPerSet || 10,
                secondsPerRep: 0
            };

            if (entry.hold_seconds) {
                spec.type = 'hold';
                spec.repsPerSet = base.repsPerSet || 1;
                spec.secondsPerRep = entry.hold_seconds;
            } else if (entry.duration_seconds) {
                spec.type = 'duration';
                spec.repsPerSet = base.repsPerSet || 1;
                spec.secondsPerRep = entry.duration_seconds;
            } else if (entry.amrap_window_sec) {
                spec.type = 'amrap';
                spec.repsPerSet = 0;
                spec.secondsPerRep = entry.amrap_window_sec;
            } else if (entry.distance_meters) {
                spec.type = 'distance';
                spec.repsPerSet = entry.distance_meters;
                spec.secondsPerRep = 0;
            }

            return spec;
        }

        const DEFAULT_LIBRARY = ATLAS_SEED.map(entry => {
            const spec = atlasSeedToSpec(entry);
            return {
                id: entry.id,
                name: entry.name,
                supersedes: entry.supersedes || [],
                atlasUrl: ATLAS_REFERENCE_URL,
                current: spec,
                history: [
                    {
                        timestamp: new Date().toISOString(),
                        summary: entry.summary || 'Seeded from atlas_pt_min_250817.json',
                        previous: null,
                        next: spec,
                        supersedes: entry.supersedes || []
                    }
                ]
            };
        });
        let exerciseLibrary = loadExerciseLibrary();
        let currentExercise = toSessionExercise(exerciseLibrary[0]);

        let timerInterval = null;
        let timerSecondsRemaining = Math.max(currentExercise.secondsPerRep || 0, 1); // counts DOWN
        let timerRunning = false;
        let actionSheetCallback = null;
        let pocketMode = false;

        const TIMER_TYPES = ['timed', 'hold', 'duration'];
        const COUNTER_TYPES = ['reps', 'amrap', 'distance'];

        const AVAILABLE_TAGS = ['knee', 'back', 'ankle', 'hip', 'shoulder', 'core', 'arm', 'leg', 'glute', 'neck', 'wrist', 'elbow'];

        let editingExerciseId = null;
        let selectedTags = [];
        let filterTags = [];
        let selectedSideOptions = [];

        const SIDE_OPTIONS_AVAILABLE = ['left', 'right', 'both'];

        // Audio for timer
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Speech synthesis for voice announcements
        function speak(text) {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 1.0;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                speechSynthesis.speak(utterance);
            }
        }

        function loadExerciseLibrary() {
            const stored = localStorage.getItem(LIBRARY_KEY);
            if (stored) {
                try {
                    const parsed = JSON.parse(stored);
                    if (Array.isArray(parsed) && parsed.length) {
                        return parsed;
                    }
                } catch (e) {
                    console.warn('Unable to parse exercise library; reseeding defaults');
                }
            }
            localStorage.setItem(LIBRARY_KEY, JSON.stringify(DEFAULT_LIBRARY));
            return JSON.parse(localStorage.getItem(LIBRARY_KEY));
        }

        function persistExerciseLibrary() {
            localStorage.setItem(LIBRARY_KEY, JSON.stringify(exerciseLibrary));
        }

        function toSessionExercise(entry) {
            const spec = entry?.current || {};
            return {
                id: entry.id,
                name: entry.name,
                type: spec.type || 'reps',
                sets: spec.sets || 3,
                repsPerSet: spec.repsPerSet || 10,
                secondsPerRep: spec.secondsPerRep ?? 10,
                currentSet: 1,
                currentRep: 0,
                sessionData: []
            };
        }

        function getLibraryEntryById(id) {
            return exerciseLibrary.find(ex => ex.id === id) || exerciseLibrary[0];
        }

        function recordRevision(entry, nextSpec, reason = 'Updated dosage') {
            const previous = { ...(entry.current || {}) };
            const changes = [];

            if ((previous.sets ?? null) !== nextSpec.sets) changes.push(`sets ${previous.sets ?? 'â€”'} â†’ ${nextSpec.sets}`);
            if ((previous.repsPerSet ?? null) !== nextSpec.repsPerSet) changes.push(`reps ${previous.repsPerSet ?? 'â€”'} â†’ ${nextSpec.repsPerSet}`);
            if ((previous.secondsPerRep ?? null) !== nextSpec.secondsPerRep) changes.push(`seconds ${previous.secondsPerRep ?? 'â€”'} â†’ ${nextSpec.secondsPerRep}`);
            if ((previous.type ?? '') !== nextSpec.type) changes.push(`type ${previous.type || 'reps'} â†’ ${nextSpec.type}`);

            entry.history = entry.history || [];
            entry.history.push({
                timestamp: new Date().toISOString(),
                summary: changes.length ? changes.join(', ') : reason,
                previous,
                next: nextSpec,
                supersedes: entry.supersedes || []
            });

            entry.current = nextSpec;
            persistExerciseLibrary();
        }

        function populateExerciseSelect() {
            const select = document.getElementById('exercise-select');
            const selectedValue = currentExercise?.id;
            select.innerHTML = '';

            exerciseLibrary.forEach(entry => {
                const opt = document.createElement('option');
                opt.value = entry.id;
                opt.textContent = entry.name;
                if (entry.id === selectedValue) {
                    opt.selected = true;
                }
                select.appendChild(opt);
            });
        }

        function applyLibraryEntryToForm(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            const spec = entry.current || {};

            document.getElementById('exercise-type').value = spec.type || 'reps';
            document.getElementById('sets-input').value = spec.sets || 3;
            document.getElementById('reps-input').value = spec.repsPerSet || 10;
            document.getElementById('target-input').value = spec.secondsPerRep ?? 10;
            updateTargetLabel();
        }

        function playBeep(frequency = 800, duration = 200) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = 'square'; // More noticeable than sine

            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime); // Louder
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration / 1000);
        }

        function playCompletionSound() {
            // Triple beep for completion
            playBeep(1000, 150);
            setTimeout(() => playBeep(1200, 150), 200);
            setTimeout(() => playBeep(1400, 200), 400);
        }

        // Haptic feedback helper
        function haptic(style = 'light') {
            if ('vibrate' in navigator) {
                switch(style) {
                    case 'light':
                        navigator.vibrate(10);
                        break;
                    case 'medium':
                        navigator.vibrate(20);
                        break;
                    case 'heavy':
                        navigator.vibrate(30);
                        break;
                    case 'success':
                        navigator.vibrate([10, 50, 10]);
                        break;
                    case 'error':
                        navigator.vibrate([20, 100, 20]);
                        break;
                }
            }
        }

        const isTimerType = (type) => TIMER_TYPES.includes(type);

        function togglePocketMode(enabled) {
            pocketMode = enabled;
            const overlay = document.getElementById('pocket-overlay');
            if (enabled) {
                overlay.classList.add('active');
                haptic('medium');
            } else {
                overlay.classList.remove('active');
                haptic('light');
            }
            updatePocketOverlay();
        }

        function handlePocketTap() {
            if (!pocketMode) return;

            if (COUNTER_TYPES.includes(currentExercise.type)) {
                incrementCounter();
            } else if (isTimerType(currentExercise.type)) {
                if (!timerRunning) {
                    startTimer();
                } else {
                    stopTimer();
                }
            }
            updatePocketOverlay();
        }

        function updatePocketOverlay() {
            const overlay = document.getElementById('pocket-overlay');
            if (!overlay.classList.contains('active')) return;

            const setsLeft = Math.max(currentExercise.sets - currentExercise.currentSet, 0);
            const repsLeft = Math.max((currentExercise.repsPerSet || 0) - currentExercise.currentRep, 0);
            const label = COUNTER_TYPES.includes(currentExercise.type)
                ? `${currentExercise.currentRep}`
                : `${formatSeconds(timerSecondsRemaining)}`;

            document.getElementById('pocket-label').textContent = label;

            const metaPieces = [
                `Sets left: ${setsLeft}`
            ];

            if (COUNTER_TYPES.includes(currentExercise.type) && currentExercise.type !== 'amrap' && currentExercise.repsPerSet) {
                metaPieces.push(`Reps left: ${repsLeft}`);
            }

            if (currentExercise.type === 'amrap' && currentExercise.secondsPerRep) {
                metaPieces.push(`AMRAP ${currentExercise.secondsPerRep}s window`);
            }

            if (currentExercise.type === 'distance') {
                metaPieces.push(`Distance goal: ${currentExercise.repsPerSet}`);
            }

            if (isTimerType(currentExercise.type)) {
                metaPieces.push(timerRunning ? 'Timer running' : 'Timer paused');
            }

            document.getElementById('pocket-meta').textContent = metaPieces.join(' Â· ');
        }

        // iOS-style Action Sheet
        function showActionSheet(message, onConfirm) {
            document.getElementById('action-sheet-message').textContent = message;
            actionSheetCallback = onConfirm;

            const backdrop = document.getElementById('action-sheet-backdrop');
            const sheet = document.getElementById('action-sheet');

            backdrop.classList.add('active');
            setTimeout(() => {
                sheet.classList.add('active');
            }, 10);

            haptic('light');
        }

        function hideActionSheet() {
            const backdrop = document.getElementById('action-sheet-backdrop');
            const sheet = document.getElementById('action-sheet');

            sheet.classList.remove('active');
            setTimeout(() => {
                backdrop.classList.remove('active');
            }, 300);

            actionSheetCallback = null;
            haptic('light');
        }

        function confirmActionSheet() {
            if (actionSheetCallback) {
                actionSheetCallback();
            }
            hideActionSheet();
            haptic('medium');
        }

        // Counter Functions
        function incrementCounter() {
            if (!COUNTER_TYPES.includes(currentExercise.type)) return;

            currentExercise.currentRep++;
            haptic('light');

            const repsLeft = currentExercise.repsPerSet - currentExercise.currentRep;

            // Voice announcements at milestones
            if (currentExercise.repsPerSet && currentExercise.type !== 'amrap') {
                if (repsLeft === 5) speak('5 reps left');
                else if (repsLeft === 3) speak('3 reps left');
                else if (repsLeft === 1) speak('Last rep');
                else if (repsLeft === 0) {
                    playCompletionSound();
                    haptic('success');
                    speak('Set complete');
                }
            }

            updateDisplay();
        }

        function formatSeconds(totalSeconds = 0) {
            const minutes = Math.floor(Math.max(totalSeconds, 0) / 60);
            const seconds = Math.max(totalSeconds % 60, 0);
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function updateDisplay() {
            document.getElementById('exercise-name').textContent = currentExercise.name;
            document.getElementById('set-info').textContent = `Set ${currentExercise.currentSet} of ${currentExercise.sets}`;

            const setsLeft = Math.max(currentExercise.sets - currentExercise.currentSet, 0);
            const repsLeft = Math.max((currentExercise.repsPerSet || 0) - currentExercise.currentRep, 0);

            let remainingLabel = `Sets left: ${setsLeft}`;
            if (COUNTER_TYPES.includes(currentExercise.type) && currentExercise.type !== 'amrap' && currentExercise.repsPerSet) {
                remainingLabel += ` Â· Reps left: ${repsLeft}`;
            }
            if (currentExercise.type === 'amrap' && currentExercise.secondsPerRep) {
                remainingLabel += ` Â· ${currentExercise.secondsPerRep}s AMRAP window`;
            }
            if (isTimerType(currentExercise.type)) {
                remainingLabel += ` Â· Time: ${formatSeconds(timerSecondsRemaining)}`;
            }
            document.getElementById('remaining-info').textContent = remainingLabel;

            if (COUNTER_TYPES.includes(currentExercise.type)) {
                document.getElementById('counter-mode').classList.remove('hidden');
                document.getElementById('timer-mode').classList.add('hidden');
                document.getElementById('main-controls').classList.remove('hidden');

                document.getElementById('counter-display').textContent = currentExercise.currentRep;

                let targetText = 'Target: ';
                if (currentExercise.type === 'amrap') {
                    targetText += currentExercise.secondsPerRep ? `${currentExercise.secondsPerRep}s AMRAP window` : 'AMRAP';
                } else if (currentExercise.type === 'distance') {
                    targetText += `${currentExercise.repsPerSet || 0} distance units`;
                } else {
                    targetText += `${currentExercise.repsPerSet} reps`;
                }
                document.getElementById('target-info').textContent = targetText;

                const progress = currentExercise.repsPerSet
                    ? Math.min((currentExercise.currentRep / currentExercise.repsPerSet) * 100, 100)
                    : Math.min((currentExercise.currentSet / currentExercise.sets) * 100, 100);
                document.getElementById('progress-bar').style.width = progress + '%';
            } else {
                document.getElementById('counter-mode').classList.add('hidden');
                document.getElementById('timer-mode').classList.remove('hidden');
                document.getElementById('main-controls').classList.remove('hidden');

                const repLabel = currentExercise.type === 'hold' || currentExercise.type === 'duration'
                    ? `Set ${currentExercise.currentSet} timer`
                    : `Rep ${currentExercise.currentRep + 1} of ${currentExercise.repsPerSet}`;
                document.getElementById('timer-rep-info').textContent = repLabel;

                const display = formatSeconds(timerSecondsRemaining);
                document.getElementById('timer-display').textContent = display;

                const timerLabel = currentExercise.type === 'duration'
                    ? `Target: ${currentExercise.secondsPerRep || 0}s total`
                    : `Target: ${currentExercise.secondsPerRep || 0} seconds`;
                document.getElementById('timer-target').textContent = timerLabel;

                const progress = currentExercise.secondsPerRep
                    ? Math.max(0, (timerSecondsRemaining / currentExercise.secondsPerRep) * 100)
                    : 0;
                document.getElementById('timer-progress-bar').style.width = progress + '%';

                const timerDisplay = document.getElementById('timer-display');
                timerDisplay.classList.remove('warning', 'danger');
                if (timerSecondsRemaining <= 5 && timerSecondsRemaining > 0) {
                    timerDisplay.classList.add('danger');
                } else if (timerSecondsRemaining <= 10 && timerSecondsRemaining > 5) {
                    timerDisplay.classList.add('warning');
                }

                if (timerRunning) {
                    document.getElementById('timer-start-btn').classList.add('hidden');
                    document.getElementById('timer-stop-btn').classList.remove('hidden');
                    document.getElementById('timer-reset-btn').classList.add('hidden');
                } else if (timerSecondsRemaining === 0 || timerSecondsRemaining === currentExercise.secondsPerRep) {
                    document.getElementById('timer-start-btn').classList.remove('hidden');
                    document.getElementById('timer-stop-btn').classList.add('hidden');
                    document.getElementById('timer-reset-btn').classList.add('hidden');
                } else {
                    document.getElementById('timer-start-btn').classList.remove('hidden');
                    document.getElementById('timer-stop-btn').classList.add('hidden');
                    document.getElementById('timer-reset-btn').classList.remove('hidden');
                }
            }

            updatePocketOverlay();
        }

        function startTimer() {
            if (timerInterval || !isTimerType(currentExercise.type)) return;

            const targetSeconds = Math.max(currentExercise.secondsPerRep || 0, 1);

            // Initialize timer if starting fresh
            if (timerSecondsRemaining === 0) {
                timerSecondsRemaining = targetSeconds;
            }

            timerRunning = true;
            haptic('medium');

            timerInterval = setInterval(() => {
                timerSecondsRemaining--;
                updateDisplay();

                // Countdown beeps
                if (timerSecondsRemaining <= 3 && timerSecondsRemaining > 0) {
                    playBeep(600, 100);
                    haptic('light');
                }

                // Timer complete
                if (timerSecondsRemaining <= 0) {
                    stopTimer();
                    playCompletionSound();
                    haptic('success');

                    currentExercise.currentRep++;

                    const repsLeft = currentExercise.repsPerSet - currentExercise.currentRep;
                    if (repsLeft === 0) speak('Set complete');
                    else if (repsLeft === 1) speak('Last rep');
                    else speak(`${repsLeft} reps left`);

                    // Auto-complete holds/durations when rep target is reached
                    if (currentExercise.type !== 'timed' && currentExercise.repsPerSet && currentExercise.currentRep >= currentExercise.repsPerSet) {
                        updateDisplay();
                        return;
                    }

                    // Reset timer for next rep
                    timerSecondsRemaining = targetSeconds;
                    updateDisplay();
                }
            }, 1000);

            updateDisplay();
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            timerRunning = false;
            haptic('light');
            updateDisplay();
        }

        function seedTimerSeconds() {
            timerSecondsRemaining = isTimerType(currentExercise.type)
                ? Math.max(currentExercise.secondsPerRep || 0, 1)
                : 0;
        }

        function resetTimer() {
            stopTimer();
            seedTimerSeconds();
            haptic('medium');
            updateDisplay();
        }

        function completeSet() {
            const reps = currentExercise.currentRep;

            if (reps === 0) {
                showActionSheet('No reps recorded. Complete set anyway?', () => {
                    finishSet();
                });
                return;
            }

            currentExercise.sessionData.push({
                set: currentExercise.currentSet,
                reps: reps,
                type: currentExercise.type,
                timestamp: new Date().toISOString()
            });

            haptic('success');
            speak(`Set ${currentExercise.currentSet} complete`);

            // Check for progress
            detectProgress(currentExercise.currentSet, reps);

            if (currentExercise.currentSet < currentExercise.sets) {
                currentExercise.currentSet++;
                currentExercise.currentRep = 0;
                seedTimerSeconds();
                stopTimer();
                updateDisplay();

                // Show rest timer if rest time is recommended
                const entry = getLibraryEntryById(currentExercise.id);
                const restSeconds = entry.details?.restSeconds;
                if (restSeconds && restSeconds > 0) {
                    showRestTimer(restSeconds);
                }
            } else {
                speak('All sets complete');
                showSessionNotesModal();
            }
        }

        function finishSet() {
            currentExercise.sessionData.push({
                set: currentExercise.currentSet,
                reps: currentExercise.currentRep,
                type: currentExercise.type,
                timestamp: new Date().toISOString()
            });

            if (currentExercise.currentSet < currentExercise.sets) {
                currentExercise.currentSet++;
                currentExercise.currentRep = 0;
                seedTimerSeconds();
                stopTimer();
                updateDisplay();
            } else {
                showSessionNotesModal();
            }
        }

        let logSetSide = 'both'; // Track which side for unilateral exercises

        function showLogSetModal() {
            const targetReps = currentExercise.repsPerSet || 0;
            document.getElementById('log-set-title').textContent = `Log Set ${currentExercise.currentSet}`;
            document.getElementById('log-set-subtitle').textContent = `Target: ${targetReps} reps Â· Enter actual reps performed`;
            document.getElementById('log-set-reps').value = targetReps;

            // Show side selector for unilateral exercises
            const entry = getLibraryEntryById(currentExercise.id);
            const isBilateral = entry.bilateral === true;
            const sideOptions = entry.sideOptions || [];

            const sideContainer = document.getElementById('log-set-side-selector');
            if (sideOptions.length > 0 && !isBilateral) {
                logSetSide = sideOptions[0] || 'left';
                sideContainer.innerHTML = '<div style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">Side:</div>' +
                    sideOptions.map(side => {
                        return `<span class="pill" style="cursor: pointer; background: ${logSetSide === side ? 'var(--ios-blue)' : 'rgba(0,122,255,0.1)'}; color: ${logSetSide === side ? 'white' : 'var(--ios-blue)'};" onclick="selectLogSetSide('${side}')">${side}</span>`;
                    }).join(' ');
            } else {
                sideContainer.innerHTML = '';
                logSetSide = 'both';
            }

            document.getElementById('log-set-modal').classList.add('active');
            haptic('light');

            // Auto-focus the input
            setTimeout(() => {
                document.getElementById('log-set-reps').focus();
                document.getElementById('log-set-reps').select();
            }, 300);
        }

        function selectLogSetSide(side) {
            logSetSide = side;
            const sideOptions = getLibraryEntryById(currentExercise.id).sideOptions || [];
            const sideContainer = document.getElementById('log-set-side-selector');
            sideContainer.innerHTML = '<div style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">Side:</div>' +
                sideOptions.map(s => {
                    return `<span class="pill" style="cursor: pointer; background: ${logSetSide === s ? 'var(--ios-blue)' : 'rgba(0,122,255,0.1)'}; color: ${logSetSide === s ? 'white' : 'var(--ios-blue)'};" onclick="selectLogSetSide('${s}')">${s}</span>`;
                }).join(' ');
        }

        function closeLogSetModal() {
            document.getElementById('log-set-modal').classList.remove('active');
            haptic('light');
        }

        function saveLoggedSet() {
            const reps = parseInt(document.getElementById('log-set-reps').value);

            if (isNaN(reps) || reps < 0) {
                alert('Please enter a valid number of reps (0 or more).');
                return;
            }

            const setData = {
                set: currentExercise.currentSet,
                reps: reps,
                type: currentExercise.type,
                timestamp: new Date().toISOString(),
                manualLog: true
            };

            // Add side if applicable
            if (logSetSide && logSetSide !== 'both') {
                setData.side = logSetSide;
            }

            currentExercise.sessionData.push(setData);

            closeLogSetModal();
            haptic('success');
            speak(`Set ${currentExercise.currentSet} logged: ${reps} reps`);

            // Check for progress
            detectProgress(currentExercise.currentSet, reps);

            if (currentExercise.currentSet < currentExercise.sets) {
                currentExercise.currentSet++;
                currentExercise.currentRep = 0;
                seedTimerSeconds();
                stopTimer();
                updateDisplay();
            } else {
                speak('All sets complete');
                showSessionNotesModal();
            }
        }

        // Smart Progress Detection
        function detectProgress(setNumber, reps) {
            const sessions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            const previousSessions = sessions.filter(s => s.exerciseId === currentExercise.id);

            if (previousSessions.length === 0) return; // First time doing this exercise

            const lastSession = previousSessions[previousSessions.length - 1];
            const lastSetReps = lastSession.sets && lastSession.sets[setNumber - 1]?.reps;

            if (!lastSetReps) return; // No comparison data

            const diff = reps - lastSetReps;

            if (diff > 0) {
                setTimeout(() => {
                    speak(`${diff} more rep${diff > 1 ? 's' : ''} than last time!`);
                    haptic('success');
                }, 1500);
            } else if (diff < 0 && Math.abs(diff) > 2) {
                // Only mention if significantly fewer (more than 2 reps)
                setTimeout(() => {
                    speak(`${Math.abs(diff)} fewer reps than last time`);
                }, 1500);
            }
        }

        function previousSet() {
            if (currentExercise.currentSet > 1) {
                currentExercise.currentSet--;
                currentExercise.currentRep = 0;
                seedTimerSeconds();
                stopTimer();
                haptic('light');
                updateDisplay();
            }
        }

        function showSessionNotesModal() {
            document.getElementById('session-notes').value = '';
            document.getElementById('session-notes-modal').classList.add('active');
            haptic('light');
        }

        function closeSessionNotesModal() {
            document.getElementById('session-notes-modal').classList.remove('active');
            haptic('light');
        }

        function saveSessionWithNotes(notes) {
            const sessions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            sessions.push({
                exerciseId: currentExercise.id,
                exerciseName: currentExercise.name,
                exerciseType: currentExercise.type,
                date: new Date().toISOString(),
                notes: notes.trim(),
                exerciseSpec: {
                    sets: currentExercise.sets,
                    repsPerSet: currentExercise.repsPerSet,
                    secondsPerRep: currentExercise.secondsPerRep,
                    type: currentExercise.type
                },
                sets: currentExercise.sessionData
            });
            localStorage.setItem(STORAGE_KEY, JSON.stringify(sessions));

            haptic('success');
            closeSessionNotesModal();

            // Reset for new session
            currentExercise.currentSet = 1;
            currentExercise.currentRep = 0;
            currentExercise.sessionData = [];
            seedTimerSeconds();
            stopTimer();
            updateDisplay();
        }

        // Modal Functions
        function showExerciseModal() {
            populateExerciseSelect();
            applyLibraryEntryToForm(currentExercise.id);
            document.getElementById('exercise-modal').classList.add('active');
            haptic('light');
        }

        function closeExerciseModal() {
            document.getElementById('exercise-modal').classList.remove('active');
            haptic('light');
        }

        function updateTargetLabel() {
            const type = document.getElementById('exercise-type').value;
            const targetInput = document.getElementById('target-input');

            const placeholders = {
                timed: 'Seconds per rep (timed reps)',
                hold: 'Seconds to hold',
                duration: 'Seconds per set (duration)',
                amrap: 'AMRAP window (seconds, optional)',
                distance: 'Distance goal (steps/meters)',
                reps: 'Target (seconds optional)'
            };

            targetInput.placeholder = placeholders[type] || 'Target (seconds or distance)';
            targetInput.disabled = type === 'reps';
        }

        function updateExerciseType() {
            const select = document.getElementById('exercise-select');
            applyLibraryEntryToForm(select.value);
        }

        function saveExercise() {
            const select = document.getElementById('exercise-select');
            const exerciseName = select.options[select.selectedIndex].text;
            const exerciseId = select.value;
            const type = document.getElementById('exercise-type').value;
            const sets = parseInt(document.getElementById('sets-input').value);
            const reps = parseInt(document.getElementById('reps-input').value);
            const seconds = parseInt(document.getElementById('target-input').value);

            if (!sets) {
                alert('Please enter a valid number for sets.');
                return;
            }

            if (COUNTER_TYPES.includes(type) && type !== 'amrap' && (!reps && reps !== 0)) {
                alert('Please enter a valid number for reps/distance.');
                return;
            }

            if (type === 'distance' && (!reps || reps <= 0)) {
                alert('Please enter a distance goal.');
                return;
            }

            if (isTimerType(type) && (!seconds || seconds <= 0)) {
                alert('Please enter seconds for the timer-based exercise.');
                return;
            }

            const entry = getLibraryEntryById(exerciseId);
            const nextSpec = {
                type: type,
                sets: sets,
                repsPerSet: reps,
                secondsPerRep: (isTimerType(type) || type === 'amrap') ? (seconds || 0) : 0
            };

            const prevSpec = entry.current || {};
            if (
                prevSpec.type !== nextSpec.type ||
                prevSpec.sets !== nextSpec.sets ||
                prevSpec.repsPerSet !== nextSpec.repsPerSet ||
                (prevSpec.secondsPerRep ?? null) !== (nextSpec.secondsPerRep ?? null)
            ) {
                recordRevision(entry, nextSpec, 'Manual exercise update');
            } else {
                entry.current = nextSpec;
                persistExerciseLibrary();
            }

            exerciseLibrary = loadExerciseLibrary();
            currentExercise = toSessionExercise({ ...entry, name: exerciseName, id: exerciseId });

            seedTimerSeconds();
            stopTimer();

            haptic('success');
            updateDisplay();
            closeExerciseModal();
        }

        function showHistory() {
            renderHistory();
            document.getElementById('history-modal').classList.add('active');
            haptic('light');
        }

        function closeHistoryModal() {
            document.getElementById('history-modal').classList.remove('active');
            haptic('light');
        }

        function describeSpec(spec) {
            if (!spec) return 'No spec available';
            const parts = [
                `${spec.sets || 0} sets`,
                spec.type === 'timed' ? `${spec.repsPerSet || 0} reps Ã— ${spec.secondsPerRep || 0}s` : `${spec.repsPerSet || 0} reps`
            ];
            return parts.join(' Â· ');
        }

        function renderHistory() {
            const sessions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            const exerciseHistoryList = document.getElementById('exercise-history-list');
            const sessionHistoryList = document.getElementById('session-history-list');
            const exerciseEntry = getLibraryEntryById(currentExercise.id);

            if (!exerciseEntry.history || exerciseEntry.history.length === 0) {
                exerciseHistoryList.innerHTML = '<div class="history-item">No revisions logged yet.</div>';
            } else {
                exerciseHistoryList.innerHTML = exerciseEntry.history
                    .slice()
                    .reverse()
                    .map(revision => {
                        const supersedesLabel = revision.supersedes && revision.supersedes.length
                            ? `<span class="pill">Supersedes ${revision.supersedes.join(', ')}</span>`
                            : '';
                        return `
                            <div class="history-item">
                                <div>${revision.summary}</div>
                                ${supersedesLabel}
                                <div class="history-meta">${new Date(revision.timestamp).toLocaleString()} Â· ${describeSpec(revision.next)}</div>
                            </div>
                        `;
                    })
                    .join('');
            }

            const relevantSessions = sessions
                .filter(s => (s.exerciseId && s.exerciseId === currentExercise.id) || s.exerciseName === currentExercise.name)
                .slice()
                .reverse();

            if (relevantSessions.length === 0) {
                sessionHistoryList.innerHTML = '<div class="history-item">No sessions tracked yet.</div>';
            } else {
                sessionHistoryList.innerHTML = relevantSessions
                    .slice(0, 10)
                    .map(session => {
                        const totalReps = (session.sets || []).reduce((sum, set) => sum + (set.reps || 0), 0);
                        const sessionLabel = session.exerciseType === 'timed'
                            ? `${session.sets?.length || 0} sets Â· ${session.exerciseType} Â· ${totalReps} reps`
                            : `${session.sets?.length || 0} sets Â· ${totalReps} reps`;

                        // Show side info for unilateral exercises
                        const setDetails = (session.sets || []).map((set, idx) => {
                            const sideLabel = set.side ? ` (${set.side})` : '';
                            const manualLabel = set.manualLog ? ' ðŸ“' : '';
                            return `Set ${idx + 1}: ${set.reps}${sideLabel}${manualLabel}`;
                        }).join(' Â· ');

                        const notesHtml = session.notes ? `<div style="margin-top: 6px; font-style: italic; color: #555;">"${session.notes}"</div>` : '';
                        return `
                            <div class="history-item">
                                <div>${session.exerciseName}</div>
                                <div class="history-meta">${new Date(session.date).toLocaleString()} Â· ${sessionLabel}</div>
                                <div style="font-size: 12px; color: #888; margin-top: 4px;">${setDetails}</div>
                                ${notesHtml}
                            </div>
                        `;
                    })
                    .join('');
            }
        }

        // Exercise List Management
        function showExerciseList() {
            renderRecentExercises();
            renderExerciseList();
            renderTagFilters();
            document.getElementById('exercise-list-modal').classList.add('active');
            haptic('light');
        }

        function renderRecentExercises() {
            const sessions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            if (sessions.length === 0) {
                document.getElementById('recent-exercises-container').innerHTML = '';
                return;
            }

            // Get unique exercises from most recent sessions
            const recentExerciseIds = new Set();
            const recentExercises = [];

            sessions.slice().reverse().forEach(session => {
                if (session.exerciseId && !recentExerciseIds.has(session.exerciseId) && recentExercises.length < 5) {
                    recentExerciseIds.add(session.exerciseId);
                    const entry = getLibraryEntryById(session.exerciseId);
                    if (entry) {
                        recentExercises.push(entry);
                    }
                }
            });

            if (recentExercises.length === 0) {
                document.getElementById('recent-exercises-container').innerHTML = '';
                return;
            }

            const container = document.getElementById('recent-exercises-container');
            container.innerHTML = `
                <div style="font-size: 13px; font-weight: 600; color: #666; margin-bottom: 8px;">âš¡ Recent Exercises</div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 8px;">
                    ${recentExercises.map(ex =>
                        `<button class="pill" style="cursor: pointer; padding: 6px 12px; background: var(--ios-blue); color: white;" onclick="selectExerciseFromList('${ex.id}'); event.stopPropagation();">${ex.name}</button>`
                    ).join('')}
                </div>
            `;
        }

        function closeExerciseList() {
            document.getElementById('exercise-list-modal').classList.remove('active');
            document.getElementById('exercise-search').value = '';
            filterTags = [];
            haptic('light');
        }

        function renderTagFilters() {
            const container = document.getElementById('tag-filter-container');
            container.innerHTML = AVAILABLE_TAGS.map(tag => {
                const active = filterTags.includes(tag);
                return `<span class="pill" style="cursor: pointer; background: ${active ? 'var(--ios-blue)' : 'rgba(0,122,255,0.1)'}; color: ${active ? 'white' : 'var(--ios-blue)'};" onclick="toggleFilterTag('${tag}')">${tag}</span>`;
            }).join(' ');
        }

        function toggleFilterTag(tag) {
            if (filterTags.includes(tag)) {
                filterTags = filterTags.filter(t => t !== tag);
            } else {
                filterTags.push(tag);
            }
            renderTagFilters();
            filterExercises();
        }

        function filterExercises() {
            const searchTerm = document.getElementById('exercise-search').value.toLowerCase();
            const filtered = exerciseLibrary.filter(ex => {
                const matchesSearch = !searchTerm || ex.name.toLowerCase().includes(searchTerm);
                const matchesTags = filterTags.length === 0 || (ex.tags && filterTags.some(tag => ex.tags.includes(tag)));
                const notArchived = !ex.archived;
                return matchesSearch && matchesTags && notArchived;
            });
            renderExerciseList(filtered);
        }

        function toggleFavorite(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            entry.favorite = !entry.favorite;
            persistExerciseLibrary();
            exerciseLibrary = loadExerciseLibrary();
            renderExerciseList();
            haptic('light');
        }

        function archiveExercise(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            showActionSheet(`Archive "${entry.name}"? You can restore it later from archived exercises.`, () => {
                entry.archived = true;
                persistExerciseLibrary();
                exerciseLibrary = loadExerciseLibrary();
                renderExerciseList();
                haptic('success');
            });
        }

        let viewingArchived = false;

        function showArchivedExercises() {
            viewingArchived = !viewingArchived;
            const btn = document.getElementById('archived-btn');

            if (viewingArchived) {
                const archived = exerciseLibrary.filter(ex => ex.archived);
                btn.textContent = 'â† Back';
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
                renderArchivedList(archived);
            } else {
                btn.textContent = 'ðŸ“¦ Archived';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
                renderExerciseList();
            }
        }

        function renderArchivedList(archivedExercises) {
            const container = document.getElementById('exercise-list-content');

            if (archivedExercises.length === 0) {
                container.innerHTML = '<div class="history-item">No archived exercises.</div>';
                return;
            }

            container.innerHTML = archivedExercises.map(ex => {
                const spec = ex.current || {};
                return `
                    <div class="history-item">
                        <div>${ex.name}</div>
                        <div class="history-meta">${describeSpec(spec)}</div>
                        <div style="margin-top: 8px; display: flex; gap: 8px;">
                            <button class="control-btn btn-success" onclick="unarchiveExercise('${ex.id}'); event.stopPropagation();" style="flex: 1; padding: 8px; font-size: 14px;">Restore</button>
                            <button class="control-btn btn-danger" onclick="permanentlyDeleteExercise('${ex.id}'); event.stopPropagation();" style="flex: 1; padding: 8px; font-size: 14px;">Delete Forever</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function unarchiveExercise(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            entry.archived = false;
            persistExerciseLibrary();
            exerciseLibrary = loadExerciseLibrary();
            haptic('success');
            speak('Exercise restored');
            showArchivedExercises(); // Refresh archived view
        }

        function permanentlyDeleteExercise(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            showActionSheet(`PERMANENTLY delete "${entry.name}"? This cannot be undone!`, () => {
                exerciseLibrary = exerciseLibrary.filter(ex => ex.id !== exerciseId);
                persistExerciseLibrary();
                exerciseLibrary = loadExerciseLibrary();
                haptic('success');
                showArchivedExercises(); // Refresh archived view
            });
        }

        function renderExerciseList(filteredLibrary = null) {
            let list = filteredLibrary || exerciseLibrary.filter(ex => !ex.archived);
            const container = document.getElementById('exercise-list-content');

            if (list.length === 0) {
                container.innerHTML = '<div class="history-item">No exercises found.</div>';
                return;
            }

            // Sort: favorites first, then by last used, then alphabetically
            const sessions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            list = list.slice().sort((a, b) => {
                // Favorites first
                if (a.favorite && !b.favorite) return -1;
                if (!a.favorite && b.favorite) return 1;

                // Then by most recently used
                const aSession = sessions.filter(s => s.exerciseId === a.id).pop();
                const bSession = sessions.filter(s => s.exerciseId === b.id).pop();
                const aDate = aSession ? new Date(aSession.date).getTime() : 0;
                const bDate = bSession ? new Date(bSession.date).getTime() : 0;
                if (aDate !== bDate) return bDate - aDate;

                // Then alphabetically
                return a.name.localeCompare(b.name);
            });

            container.innerHTML = list.map(ex => {
                const spec = ex.current || {};
                const tags = ex.tags || [];
                const tagHtml = tags.length ? tags.map(t => `<span class="pill">${t}</span>`).join('') : '';
                const hasDetails = ex.details && (ex.details.description || ex.details.executionTips);
                const detailsIndicator = hasDetails ? ' ðŸ“‹' : '';

                // Calculate quick stats
                const exerciseSessions = sessions.filter(s => s.exerciseId === ex.id || s.exerciseName === ex.name);
                const totalSessions = exerciseSessions.length;
                const lastSession = exerciseSessions.length ? new Date(exerciseSessions[exerciseSessions.length - 1].date) : null;
                const statsHtml = totalSessions > 0
                    ? `<div style="font-size: 11px; color: #999; margin-top: 2px;">Last: ${lastSession.toLocaleDateString()} Â· ${totalSessions} session${totalSessions > 1 ? 's' : ''}</div>`
                    : '';

                return `
                    <div class="history-item" style="cursor: pointer;">
                        <div onclick="selectExerciseFromList('${ex.id}')">${ex.name}${detailsIndicator}</div>
                        ${tagHtml ? `<div style="margin-top: 4px;">${tagHtml}</div>` : ''}
                        <div class="history-meta">${describeSpec(spec)}</div>
                        ${statsHtml}
                        <div style="margin-top: 8px; display: flex; gap: 8px;">
                            <button class="control-btn ${ex.favorite ? 'btn-primary' : 'btn-secondary'}" onclick="toggleFavorite('${ex.id}'); event.stopPropagation();" style="flex: 0 0 auto; padding: 8px 12px; font-size: 18px;">${ex.favorite ? 'â­' : 'â˜†'}</button>
                            <button class="control-btn btn-secondary" onclick="showExerciseDetailsModal('${ex.id}'); event.stopPropagation();" style="flex: 1; padding: 8px; font-size: 14px;">Details</button>
                            <button class="control-btn btn-secondary" onclick="editExerciseFromList('${ex.id}'); event.stopPropagation();" style="flex: 1; padding: 8px; font-size: 14px;">Edit</button>
                            <button class="control-btn btn-danger" onclick="archiveExercise('${ex.id}'); event.stopPropagation();" style="flex: 1; padding: 8px; font-size: 14px;">Archive</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function selectExerciseFromList(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            currentExercise = toSessionExercise(entry);
            seedTimerSeconds();
            stopTimer();
            updateDisplay();
            closeExerciseList();
            haptic('success');

            // Announce last session info if available
            const sessions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            const lastSession = sessions.filter(s => s.exerciseId === exerciseId).pop();
            if (lastSession) {
                const daysSince = Math.floor((Date.now() - new Date(lastSession.date).getTime()) / (1000 * 60 * 60 * 24));
                if (daysSince === 0) {
                    speak('Last session: today');
                } else if (daysSince === 1) {
                    speak('Last session: yesterday');
                } else if (daysSince < 7) {
                    speak(`Last session: ${daysSince} days ago`);
                }
            }
        }

        function showAddExerciseModal() {
            editingExerciseId = null;
            selectedTags = [];
            selectedSideOptions = [];
            document.getElementById('add-exercise-title').textContent = 'Add Exercise';
            document.getElementById('new-exercise-name').value = '';
            document.getElementById('new-exercise-type').value = 'reps';
            document.getElementById('new-sets').value = '3';
            document.getElementById('new-reps').value = '10';
            document.getElementById('new-seconds').value = '';
            document.getElementById('bilateral-checkbox').checked = false;
            document.getElementById('supersedes-input').value = '';
            document.getElementById('primary-muscles').value = '';
            document.getElementById('anatomic-regions').value = '';
            document.getElementById('equipment-select').selectedIndex = -1;
            document.getElementById('difficulty-select').value = '';
            renderTagSelector();
            renderSideOptionsSelector();
            document.getElementById('add-exercise-modal').classList.add('active');
            haptic('light');
        }

        function closeAddExerciseModal() {
            document.getElementById('add-exercise-modal').classList.remove('active');
            haptic('light');
        }

        function renderTagSelector() {
            const container = document.getElementById('tag-selector-container');
            container.innerHTML = '<div style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">Tags (body parts):</div>' +
                AVAILABLE_TAGS.map(tag => {
                    const active = selectedTags.includes(tag);
                    return `<span class="pill" style="cursor: pointer; background: ${active ? 'var(--ios-blue)' : 'rgba(0,122,255,0.1)'}; color: ${active ? 'white' : 'var(--ios-blue)'};" onclick="toggleTag('${tag}')">${tag}</span>`;
                }).join(' ');
        }

        function toggleTag(tag) {
            if (selectedTags.includes(tag)) {
                selectedTags = selectedTags.filter(t => t !== tag);
            } else {
                selectedTags.push(tag);
            }
            renderTagSelector();
        }

        function renderSideOptionsSelector() {
            const container = document.getElementById('side-options-container');
            const isBilateral = document.getElementById('bilateral-checkbox').checked;

            if (isBilateral) {
                container.innerHTML = '';
                selectedSideOptions = [];
                return;
            }

            container.innerHTML = '<div style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">Side options (for unilateral):</div>' +
                SIDE_OPTIONS_AVAILABLE.map(side => {
                    const active = selectedSideOptions.includes(side);
                    return `<span class="pill" style="cursor: pointer; background: ${active ? 'var(--ios-blue)' : 'rgba(0,122,255,0.1)'}; color: ${active ? 'white' : 'var(--ios-blue)'};" onclick="toggleSideOption('${side}')">${side}</span>`;
                }).join(' ');
        }

        function toggleSideOption(side) {
            if (selectedSideOptions.includes(side)) {
                selectedSideOptions = selectedSideOptions.filter(s => s !== side);
            } else {
                selectedSideOptions.push(side);
            }
            renderSideOptionsSelector();
        }

        // Update bilateral checkbox listener
        document.addEventListener('DOMContentLoaded', () => {
            const bilateralCheckbox = document.getElementById('bilateral-checkbox');
            if (bilateralCheckbox) {
                bilateralCheckbox.addEventListener('change', renderSideOptionsSelector);
            }
        });

        function saveNewExercise() {
            const name = document.getElementById('new-exercise-name').value.trim();
            const type = document.getElementById('new-exercise-type').value;
            const sets = parseInt(document.getElementById('new-sets').value);
            const reps = parseInt(document.getElementById('new-reps').value);
            const seconds = parseInt(document.getElementById('new-seconds').value);
            const isBilateral = document.getElementById('bilateral-checkbox').checked;
            const supersedesValue = document.getElementById('supersedes-input').value.trim();

            // ATLAS fields
            const primaryMuscles = document.getElementById('primary-muscles').value.trim();
            const anatomicRegions = document.getElementById('anatomic-regions').value.trim();
            const equipmentSelect = document.getElementById('equipment-select');
            const equipment = Array.from(equipmentSelect.selectedOptions).map(opt => opt.value);
            const difficulty = document.getElementById('difficulty-select').value;

            if (!name) {
                alert('Please enter an exercise name.');
                return;
            }

            if (!sets || sets <= 0) {
                alert('Please enter a valid number of sets.');
                return;
            }

            const spec = {
                type: type,
                sets: sets,
                repsPerSet: reps || 0,
                secondsPerRep: seconds || 0
            };

            const supersedes = supersedesValue ? supersedesValue.split(',').map(s => s.trim()).filter(Boolean) : [];

            if (editingExerciseId) {
                // Edit existing
                const entry = getLibraryEntryById(editingExerciseId);
                entry.name = name;
                entry.tags = selectedTags;
                entry.bilateral = isBilateral;
                entry.sideOptions = isBilateral ? [] : selectedSideOptions;
                entry.supersedes = supersedes;
                entry.primaryMuscles = primaryMuscles;
                entry.anatomicRegions = anatomicRegions;
                entry.equipment = equipment;
                entry.difficulty = difficulty;
                entry.favorite = entry.favorite || false; // Preserve favorite status
                recordRevision(entry, spec, 'Manual edit');
            } else {
                // Add new
                const newId = 'ex_' + Date.now();
                const newEntry = {
                    id: newId,
                    name: name,
                    tags: selectedTags,
                    bilateral: isBilateral,
                    sideOptions: isBilateral ? [] : selectedSideOptions,
                    supersedes: supersedes,
                    primaryMuscles: primaryMuscles,
                    anatomicRegions: anatomicRegions,
                    equipment: equipment,
                    difficulty: difficulty,
                    favorite: false,
                    archived: false,
                    current: spec,
                    history: [{
                        timestamp: new Date().toISOString(),
                        summary: 'Exercise created',
                        previous: null,
                        next: spec,
                        supersedes: supersedes
                    }]
                };
                exerciseLibrary.push(newEntry);
                persistExerciseLibrary();
            }

            exerciseLibrary = loadExerciseLibrary();
            renderExerciseList();
            closeAddExerciseModal();
            haptic('success');
        }

        function editExerciseFromList(exerciseId) {
            editingExerciseId = exerciseId;
            const entry = getLibraryEntryById(exerciseId);
            const spec = entry.current || {};

            document.getElementById('add-exercise-title').textContent = 'Edit Exercise';
            document.getElementById('new-exercise-name').value = entry.name;
            document.getElementById('new-exercise-type').value = spec.type || 'reps';
            document.getElementById('new-sets').value = spec.sets || 3;
            document.getElementById('new-reps').value = spec.repsPerSet || 10;
            document.getElementById('new-seconds').value = spec.secondsPerRep || '';
            document.getElementById('bilateral-checkbox').checked = entry.bilateral || false;
            document.getElementById('supersedes-input').value = (entry.supersedes || []).join(', ');
            document.getElementById('primary-muscles').value = entry.primaryMuscles || '';
            document.getElementById('anatomic-regions').value = entry.anatomicRegions || '';
            document.getElementById('difficulty-select').value = entry.difficulty || '';

            // Set equipment multi-select
            const equipmentSelect = document.getElementById('equipment-select');
            Array.from(equipmentSelect.options).forEach(opt => {
                opt.selected = (entry.equipment || []).includes(opt.value);
            });

            selectedTags = entry.tags || [];
            selectedSideOptions = entry.sideOptions || [];
            renderTagSelector();
            renderSideOptionsSelector();
            document.getElementById('add-exercise-modal').classList.add('active');
            haptic('light');
        }

        function deleteExerciseFromList(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            showActionSheet(`Delete "${entry.name}"? This cannot be undone.`, () => {
                exerciseLibrary = exerciseLibrary.filter(ex => ex.id !== exerciseId);
                persistExerciseLibrary();
                exerciseLibrary = loadExerciseLibrary();
                renderExerciseList();
                haptic('success');
            });
        }

        // Exercise Details Modal
        let editingDetailsExerciseId = null;

        function showExerciseDetailsModal(exerciseId = null) {
            editingDetailsExerciseId = exerciseId || currentExercise.id;
            const entry = getLibraryEntryById(editingDetailsExerciseId);
            const details = entry.details || {};

            document.getElementById('exercise-details-title').textContent = entry.name;
            document.getElementById('exercise-description').value = details.description || '';
            document.getElementById('exercise-tips').value = details.executionTips || '';
            document.getElementById('exercise-feel').value = details.shouldFeel || '';
            document.getElementById('exercise-not-feel').value = details.shouldNotFeel || '';
            document.getElementById('exercise-modifications').value = details.modifications || '';
            document.getElementById('exercise-rest-seconds').value = details.restSeconds || '';

            document.getElementById('exercise-details-modal').classList.add('active');
            haptic('light');
        }

        function closeExerciseDetailsModal() {
            document.getElementById('exercise-details-modal').classList.remove('active');
            haptic('light');
        }

        function saveExerciseDetails() {
            const entry = getLibraryEntryById(editingDetailsExerciseId);
            const details = {
                description: document.getElementById('exercise-description').value.trim(),
                executionTips: document.getElementById('exercise-tips').value.trim(),
                shouldFeel: document.getElementById('exercise-feel').value.trim(),
                shouldNotFeel: document.getElementById('exercise-not-feel').value.trim(),
                modifications: document.getElementById('exercise-modifications').value.trim(),
                restSeconds: parseInt(document.getElementById('exercise-rest-seconds').value) || null
            };

            entry.details = details;
            persistExerciseLibrary();
            exerciseLibrary = loadExerciseLibrary();

            closeExerciseDetailsModal();
            haptic('success');
        }

        // Rest Timer
        let restTimerInterval = null;
        let restSecondsRemaining = 0;
        let restSecondsTotal = 0;

        function showRestTimer(seconds) {
            restSecondsTotal = seconds;
            restSecondsRemaining = seconds;
            document.getElementById('rest-countdown').textContent = restSecondsRemaining;
            document.getElementById('rest-progress-bar').style.width = '100%';
            document.getElementById('rest-timer-modal').classList.add('active');
            haptic('light');

            restTimerInterval = setInterval(() => {
                restSecondsRemaining--;
                document.getElementById('rest-countdown').textContent = restSecondsRemaining;
                const progress = (restSecondsRemaining / restSecondsTotal) * 100;
                document.getElementById('rest-progress-bar').style.width = progress + '%';

                // Countdown beeps
                if (restSecondsRemaining <= 3 && restSecondsRemaining > 0) {
                    playBeep(500, 100);
                    haptic('light');
                }

                if (restSecondsRemaining <= 0) {
                    clearInterval(restTimerInterval);
                    restTimerInterval = null;
                    playCompletionSound();
                    haptic('success');
                    speak('Rest complete');
                    closeRestTimer();
                }
            }, 1000);
        }

        function closeRestTimer() {
            if (restTimerInterval) {
                clearInterval(restTimerInterval);
                restTimerInterval = null;
            }
            document.getElementById('rest-timer-modal').classList.remove('active');
            haptic('light');
        }

        function skipRest() {
            if (restTimerInterval) {
                clearInterval(restTimerInterval);
                restTimerInterval = null;
            }
            closeRestTimer();
            haptic('medium');
        }

        // Session Recovery
        const RECOVERY_KEY = 'pt_session_recovery';

        function saveSessionRecovery() {
            if (currentExercise.sessionData.length > 0 || currentExercise.currentSet > 1 || currentExercise.currentRep > 0) {
                const recovery = {
                    exerciseId: currentExercise.id,
                    exerciseName: currentExercise.name,
                    currentSet: currentExercise.currentSet,
                    currentRep: currentExercise.currentRep,
                    sessionData: currentExercise.sessionData,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem(RECOVERY_KEY, JSON.stringify(recovery));
            } else {
                localStorage.removeItem(RECOVERY_KEY);
            }
        }

        function checkSessionRecovery() {
            const recoveryData = localStorage.getItem(RECOVERY_KEY);
            if (!recoveryData) return;

            try {
                const recovery = JSON.parse(recoveryData);
                const timeDiff = Date.now() - new Date(recovery.timestamp).getTime();
                const hoursSince = timeDiff / (1000 * 60 * 60);

                // Only offer recovery if less than 24 hours old
                if (hoursSince < 24 && recovery.sessionData.length > 0) {
                    showActionSheet(
                        `Recover incomplete session for "${recovery.exerciseName}"? (${recovery.sessionData.length} sets completed)`,
                        () => {
                            const entry = getLibraryEntryById(recovery.exerciseId);
                            if (entry) {
                                currentExercise = toSessionExercise(entry);
                                currentExercise.currentSet = recovery.currentSet;
                                currentExercise.currentRep = recovery.currentRep;
                                currentExercise.sessionData = recovery.sessionData;
                                seedTimerSeconds();
                                updateDisplay();
                                haptic('success');
                                speak(`Recovered session: Set ${recovery.currentSet}`);
                            } else {
                                localStorage.removeItem(RECOVERY_KEY);
                            }
                        }
                    );
                } else {
                    localStorage.removeItem(RECOVERY_KEY);
                }
            } catch (e) {
                console.warn('Failed to parse recovery data:', e);
                localStorage.removeItem(RECOVERY_KEY);
            }
        }

        // Auto-save recovery every time session data changes
        window.addEventListener('beforeunload', saveSessionRecovery);
        setInterval(saveSessionRecovery, 5000); // Save every 5 seconds

        // PT Export Function
        function exportForPT() {
            const sessions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            const entry = getLibraryEntryById(currentExercise.id);
            const exerciseSessions = sessions.filter(s => s.exerciseId === currentExercise.id || s.exerciseName === currentExercise.name);

            if (exerciseSessions.length === 0) {
                alert('No sessions to export yet.');
                return;
            }

            let report = `PHYSICAL THERAPY PROGRESS REPORT\n`;
            report += `Generated: ${new Date().toLocaleDateString()}\n`;
            report += `\n${'='.repeat(50)}\n\n`;
            report += `EXERCISE: ${entry.name}\n`;

            // Exercise details
            if (entry.details?.description) {
                report += `Description: ${entry.details.description}\n`;
            }
            if (entry.details?.executionTips) {
                report += `Form: ${entry.details.executionTips}\n`;
            }
            if (entry.tags && entry.tags.length) {
                report += `Body parts: ${entry.tags.join(', ')}\n`;
            }
            if (entry.bilateral !== undefined) {
                report += `Type: ${entry.bilateral ? 'Bilateral' : 'Unilateral'}\n`;
            }

            report += `\n${'='.repeat(50)}\n`;
            report += `SESSION HISTORY (${exerciseSessions.length} sessions)\n`;
            report += `${'='.repeat(50)}\n\n`;

            exerciseSessions.reverse().forEach((session, idx) => {
                const sessionDate = new Date(session.date);
                report += `Session ${exerciseSessions.length - idx} - ${sessionDate.toLocaleDateString()} at ${sessionDate.toLocaleTimeString()}\n`;
                report += `${'-'.repeat(50)}\n`;

                session.sets.forEach((set, setIdx) => {
                    const sideInfo = set.side ? ` (${set.side} side)` : '';
                    const manualInfo = set.manualLog ? ' [manually logged]' : '';
                    report += `  Set ${setIdx + 1}: ${set.reps} reps${sideInfo}${manualInfo}\n`;
                });

                const totalReps = session.sets.reduce((sum, set) => sum + (set.reps || 0), 0);
                report += `  Total: ${session.sets.length} sets, ${totalReps} reps\n`;

                if (session.notes) {
                    report += `  Notes: "${session.notes}"\n`;
                }

                report += `\n`;
            });

            report += `${'='.repeat(50)}\n`;
            report += `SUMMARY\n`;
            report += `${'='.repeat(50)}\n`;
            report += `Total sessions: ${exerciseSessions.length}\n`;

            const allReps = exerciseSessions.flatMap(s => s.sets.map(set => set.reps || 0));
            const avgReps = allReps.length ? (allReps.reduce((a, b) => a + b, 0) / allReps.length).toFixed(1) : 0;
            const maxReps = allReps.length ? Math.max(...allReps) : 0;
            const minReps = allReps.length ? Math.min(...allReps) : 0;

            report += `Average reps per set: ${avgReps}\n`;
            report += `Best set: ${maxReps} reps\n`;
            report += `Lowest set: ${minReps} reps\n`;

            const firstSession = exerciseSessions[exerciseSessions.length - 1];
            const lastSession = exerciseSessions[0];
            const firstAvg = firstSession.sets.reduce((sum, set) => sum + set.reps, 0) / firstSession.sets.length;
            const lastAvg = lastSession.sets.reduce((sum, set) => sum + set.reps, 0) / lastSession.sets.length;
            const improvement = ((lastAvg - firstAvg) / firstAvg * 100).toFixed(1);

            if (exerciseSessions.length > 1) {
                report += `\nProgress: ${improvement > 0 ? '+' : ''}${improvement}% from first to most recent session\n`;
            }

            report += `\n${'='.repeat(50)}\n`;
            report += `END OF REPORT\n`;

            // Copy to clipboard
            navigator.clipboard.writeText(report).then(() => {
                speak('Report copied');
                haptic('success');
                alert('PT report copied to clipboard! You can paste it in a text message or email to your physical therapist.');
            }).catch(() => {
                // Fallback: show in a textarea for manual copy
                const textarea = document.createElement('textarea');
                textarea.value = report;
                textarea.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; font-family: monospace; font-size: 12px; padding: 20px;';
                document.body.appendChild(textarea);
                textarea.select();
                alert('Report generated! Copy this text and share with your PT.');
            });
        }

        // Initialize
        updateDisplay();
        setTimeout(checkSessionRecovery, 500); // Check for recovery after UI loads
    </script>
</body>
</html>
