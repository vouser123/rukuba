<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="PT Tracker">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%23007AFF' rx='20'/><text x='50' y='70' font-size='60' text-anchor='middle' fill='white'>ðŸ’ª</text></svg>">
    <meta name="theme-color" content="#007AFF">
    <title>PT Exercise Tracker</title>
    <style>
        :root {
            --ios-blue: #007AFF;
            --ios-red: #FF3B30;
            --ios-green: #34C759;
            --ios-orange: #FF9500;
            --ios-gray: #8E8E93;
            --ios-background: #F2F2F7;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: var(--ios-background);
            color: #000;
            touch-action: manipulation;
            user-select: none;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            background: white;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header h1 {
            font-size: 20px;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .exercise-name {
            font-size: 17px;
            color: var(--ios-blue);
            font-weight: 600;
        }

        /* Main Counter View */
        .counter-view {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 250px);
            padding: 20px;
        }

        .set-info {
            font-size: 17px;
            color: var(--ios-gray);
            margin-bottom: 20px;
        }

        .counter-display {
            width: min(320px, 85vw);
            height: min(320px, 85vw);
            border-radius: 50%;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 72px;
            font-weight: 700;
            color: var(--ios-blue);
            box-shadow: 0 4px 20px rgba(0, 122, 255, 0.3);
            margin-bottom: 30px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .counter-display:active {
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(0, 122, 255, 0.2);
        }

        .timer-display {
            font-size: 64px;
            font-weight: 700;
            color: var(--ios-blue);
            margin-bottom: 20px;
        }

        .timer-display.warning {
            color: var(--ios-orange);
        }

        .timer-display.danger {
            color: var(--ios-red);
        }

        .target-info {
            font-size: 17px;
            color: var(--ios-gray);
            margin-bottom: 30px;
        }

        .remaining-info {
            font-size: 18px;
            font-weight: 600;
            color: #1c1c1e;
            text-align: center;
            margin-bottom: 12px;
        }

        .progress-bar-container {
            width: 100%;
            max-width: 300px;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--ios-blue), var(--ios-green));
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 12px;
            width: 100%;
            max-width: 400px;
            padding: 0 20px;
        }

        .control-btn {
            flex: 1;
            padding: 14px;
            font-size: 17px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
        }

        .control-btn:active {
            transform: scale(0.98);
            opacity: 0.8;
        }

        .btn-primary {
            background: var(--ios-blue);
            color: white;
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3);
        }

        .btn-secondary {
            background: white;
            color: var(--ios-blue);
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
        }

        .btn-success {
            background: var(--ios-green);
            color: white;
            box-shadow: 0 2px 8px rgba(52, 199, 89, 0.3);
        }

        .btn-danger {
            background: var(--ios-red);
            color: white;
            box-shadow: 0 2px 8px rgba(255, 59, 48, 0.3);
        }

        /* Footer */
        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            padding: 12px;
            padding-bottom: max(12px, env(safe-area-inset-bottom));
            border-top: 0.5px solid rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 12px;
            z-index: 999;
        }

        .footer button {
            flex: 1;
            padding: 14px;
            font-size: 17px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.1s, opacity 0.2s;
        }

        .footer button:active {
            transform: scale(0.98);
            opacity: 0.8;
        }

        /* iOS Bottom Sheet Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.4);
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.25s ease;
        }

        .modal.active {
            display: block;
            opacity: 1;
        }

        .modal-content {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--ios-background);
            border-radius: 20px 20px 0 0;
            padding: 0;
            max-height: 90vh;
            overflow-y: auto;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 -2px 20px rgba(0,0,0,0.15);
        }

        .modal.active .modal-content {
            transform: translateY(0);
        }

        .modal-drag-handle {
            width: 36px;
            height: 5px;
            background: rgba(0,0,0,0.2);
            border-radius: 3px;
            margin: 12px auto 8px;
        }

        .modal-title {
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            padding: 8px 20px 16px;
            color: #000;
            border-bottom: 0.5px solid rgba(0,0,0,0.1);
        }

        .modal-form {
            padding: 20px;
        }

        .modal-input, .modal-select {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 17px;
            margin-bottom: 12px;
            font-family: inherit;
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .modal-input:focus, .modal-select:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--ios-blue);
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            padding: 0 20px 20px;
        }

        .modal-buttons button {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 12px;
            font-size: 17px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.1s;
        }

        .modal-buttons button:active {
            transform: scale(0.98);
            opacity: 0.8;
        }

        .modal-save {
            background: var(--ios-blue);
            color: white;
        }

        .modal-cancel {
            background: white;
            color: var(--ios-blue);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        /* iOS Action Sheet */
        .action-sheet-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.25s ease;
        }

        .action-sheet-backdrop.active {
            display: block;
            opacity: 1;
        }

        .action-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: transparent;
            z-index: 3001;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 8px;
        }

        .action-sheet.active {
            transform: translateY(0);
        }

        .action-sheet-content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 14px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .action-sheet-message {
            padding: 20px;
            text-align: center;
            color: var(--ios-gray);
            font-size: 13px;
            border-bottom: 0.5px solid rgba(0, 0, 0, 0.1);
        }

        .action-sheet-button {
            width: 100%;
            padding: 16px;
            background: transparent;
            border: none;
            font-size: 20px;
            cursor: pointer;
            border-bottom: 0.5px solid rgba(0, 0, 0, 0.1);
            color: var(--ios-blue);
            transition: background 0.2s;
        }

        .action-sheet-button:last-child {
            border-bottom: none;
        }

        .action-sheet-button:active {
            background: rgba(0, 0, 0, 0.05);
        }

        .action-sheet-button.destructive {
            color: var(--ios-red);
            font-weight: 600;
        }

        .action-sheet-cancel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 14px;
            width: 100%;
            padding: 16px;
            border: none;
            font-size: 20px;
            font-weight: 600;
            color: var(--ios-blue);
            cursor: pointer;
            transition: background 0.2s;
        }

        .action-sheet-cancel:active {
            background: rgba(0, 0, 0, 0.05);
        }

        .history-section {
            margin-bottom: 16px;
        }

        .history-heading {
            font-size: 15px;
            font-weight: 700;
            color: #1c1c1e;
            margin-bottom: 8px;
        }

        .history-list {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
            padding: 12px;
        }

        .history-item {
            padding: 10px 8px;
            border-bottom: 0.5px solid rgba(0, 0, 0, 0.06);
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-meta {
            font-size: 12px;
            color: var(--ios-gray);
            margin-top: 4px;
        }

        .pill {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            background: rgba(0, 122, 255, 0.1);
            color: var(--ios-blue);
            margin-right: 6px;
        }

        .pocket-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 4000;
        }

        .pocket-overlay.active {
            display: flex;
        }

        .pocket-pad {
            width: min(360px, 95vw);
            height: min(360px, 70vh);
            border-radius: 28px;
            background: white;
            color: var(--ios-blue);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            font-size: 56px;
            font-weight: 800;
            box-shadow: 0 12px 40px rgba(0,0,0,0.35);
            text-align: center;
            padding: 20px;
        }

        .pocket-meta {
            color: #3a3a3c;
            font-size: 16px;
            font-weight: 600;
        }

        .pocket-close {
            margin-top: 18px;
            background: rgba(0,0,0,0.75);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 20px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            width: 100%;
            max-width: 320px;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸ’ª PT Exercise Tracker</h1>
        <div class="exercise-name" id="exercise-name">Goblet Squat</div>
    </div>

    <!-- Counter View -->
    <div class="counter-view" id="counter-view">
        <div class="set-info" id="set-info">Set 1 of 3</div>
        <div class="remaining-info" id="remaining-info">Reps left: 10 Â· Sets left: 3</div>

        <!-- Counter Mode -->
        <div id="counter-mode">
            <div class="counter-display" id="counter-display" onclick="incrementCounter()" aria-live="assertive">0</div>
            <div class="target-info" id="target-info">Target: 10 reps</div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
        </div>

        <!-- Timer Mode -->
        <div id="timer-mode" class="hidden">
            <div class="target-info" id="timer-rep-info">Rep 1 of 10</div>
            <div class="timer-display" id="timer-display">00:00</div>
            <div class="target-info" id="timer-target">Target: 10 seconds</div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="timer-progress-bar"></div>
            </div>
            <div class="controls" style="margin-bottom: 20px;">
                <button class="control-btn btn-primary" id="timer-start-btn" onclick="startTimer()">Start Timer</button>
                <button class="control-btn btn-danger hidden" id="timer-stop-btn" onclick="stopTimer()">Stop</button>
                <button class="control-btn btn-secondary hidden" id="timer-reset-btn" onclick="resetTimer()">Reset</button>
            </div>
        </div>

        <div class="controls" id="main-controls">
            <button class="control-btn btn-secondary" onclick="previousSet()">Previous</button>
            <button class="control-btn btn-primary" onclick="skipSet()">Skip Set</button>
            <button class="control-btn btn-success" onclick="completeSet()">Complete Set</button>
        </div>
    </div>

    <div class="footer">
        <button class="btn-primary" onclick="showExerciseList()">Exercises</button>
        <button class="btn-secondary" onclick="showHistory()">History</button>
        <button class="btn-success" onclick="togglePocketMode(true)">Pocket</button>
    </div>

    <!-- Exercise Selection Modal -->
    <div class="modal" id="exercise-modal" onclick="if(event.target === this) closeExerciseModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Select Exercise</div>
            <div class="modal-form">
                <select class="modal-select" id="exercise-select" onchange="updateExerciseType()">
                    <option value="goblet_squat">Goblet Squat</option>
                    <option value="plank">Plank Hold</option>
                    <option value="step_ups">Step Ups</option>
                    <option value="clamshells">Clamshells</option>
                    <option value="bridge_hold">Bridge Hold</option>
                    <option value="pushup_amrap">Push-up AMRAP</option>
                    <option value="walk_distance">Walk (Distance)</option>
                </select>
                <select class="modal-select" id="exercise-type" onchange="updateTargetLabel()">
                    <option value="reps">Rep-based</option>
                    <option value="timed">Timed Reps</option>
                    <option value="hold">Hold</option>
                    <option value="duration">Duration</option>
                    <option value="amrap">AMRAP</option>
                    <option value="distance">Distance</option>
                </select>
                <input type="number" class="modal-input" id="sets-input" placeholder="Number of sets" value="3">
                <input type="number" class="modal-input" id="reps-input" placeholder="Reps per set" value="10">
                <input type="number" class="modal-input" id="target-input" placeholder="Target (seconds or distance)" value="10">
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeExerciseModal()">Cancel</button>
                <button class="modal-save" onclick="saveExercise()">Start</button>
            </div>
        </div>
    </div>

    <!-- History Modal -->
    <div class="modal" id="history-modal" onclick="if(event.target === this) closeHistoryModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">History</div>
            <div class="modal-form">
                <div class="history-section">
                    <div class="history-heading">Exercise revisions</div>
                    <div class="history-list" id="exercise-history-list"></div>
                </div>
                <div class="history-section">
                    <div class="history-heading">Recent sessions</div>
                    <div class="history-list" id="session-history-list"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- iOS Action Sheet -->
    <div class="action-sheet-backdrop" id="action-sheet-backdrop" onclick="hideActionSheet()"></div>
    <div class="action-sheet" id="action-sheet">
        <div class="action-sheet-content">
            <div class="action-sheet-message" id="action-sheet-message"></div>
            <button class="action-sheet-button destructive" id="action-sheet-confirm" onclick="confirmActionSheet()">Confirm</button>
        </div>
        <button class="action-sheet-cancel" onclick="hideActionSheet()">Cancel</button>
    </div>

    <!-- Eyes-free pocket tap overlay -->
    <div class="pocket-overlay" id="pocket-overlay" onclick="handlePocketTap()" aria-live="assertive">
        <div class="pocket-pad" role="button" aria-label="Pocket tap target">
            <div id="pocket-label">Tap to count</div>
            <div class="pocket-meta" id="pocket-meta">Reps left Â· Sets left</div>
        </div>
        <button class="pocket-close" onclick="togglePocketMode(false); event.stopPropagation();">Exit Pocket Mode</button>
    </div>

    <script>
        const STORAGE_KEY = 'pt_tracker_data';
        const LIBRARY_KEY = 'pt_exercise_library';
        const ATLAS_REFERENCE_URL = 'https://github.com/vouser123/rukuba/tree/revert-5-claude/enable-page-code-writing-MNryw';

        const ATLAS_SEED = [
            {
                id: 'goblet_squat',
                name: 'Goblet Squat (Example)',
                dosage: 'S3x10 (both)',
                supersedes: ['ex_basic_squats_01'],
                summary: 'Example exercise - edit or delete as needed'
            },
            {
                id: 'plank_hold',
                name: 'Plank Hold (Example)',
                dosage: 'S3x1',
                hold_seconds: 30,
                supersedes: [],
                summary: 'Example exercise - edit or delete as needed'
            },
            {
                id: 'step_ups',
                name: 'Step Ups (Example)',
                dosage: 'S3x10 (side)',
                supersedes: ['ex_basic_squats_01'],
                summary: 'Example exercise - edit or delete as needed'
            },
            {
                id: 'clamshells',
                name: 'Clamshells (Example)',
                dosage: 'S3x15 (side)',
                supersedes: [],
                summary: 'Example exercise - edit or delete as needed'
            },
            {
                id: 'bridge_hold',
                name: 'Bridge Hold (Example)',
                dosage: 'S3x1',
                hold_seconds: 30,
                supersedes: [],
                summary: 'Example exercise - edit or delete as needed'
            },
            {
                id: 'bike_intervals',
                name: 'Bike Intervals (Example)',
                dosage: 'S4x1',
                duration_seconds: 300,
                supersedes: [],
                summary: 'Example exercise - edit or delete as needed'
            },
            {
                id: 'pushup_amrap',
                name: 'Push-up AMRAP (Example)',
                dosage: 'AMRAP',
                amrap_window_sec: 60,
                supersedes: [],
                summary: 'Example exercise - edit or delete as needed'
            },
            {
                id: 'walk_distance',
                name: 'Walk (Example)',
                dosage: 'S1x400',
                distance_meters: 400,
                supersedes: [],
                summary: 'Example exercise - edit or delete as needed'
            }
        ];

        function parseAtlasDosage(dosage = '') {
            const match = /S(\d+)x(\d+)/i.exec(dosage);
            const sets = match ? parseInt(match[1], 10) : 3;
            const repsPerSet = match ? parseInt(match[2], 10) : 10;
            const isSide = /(side)/i.test(dosage);
            const isBoth = /(both)/i.test(dosage);

            return { sets, repsPerSet, side: isSide ? 'side' : isBoth ? 'both' : null };
        }

        function atlasSeedToSpec(entry) {
            const base = parseAtlasDosage(entry.dosage || '');
            const spec = {
                type: 'reps',
                sets: entry.sets_override || base.sets || 3,
                repsPerSet: base.repsPerSet || 10,
                secondsPerRep: 0
            };

            if (entry.hold_seconds) {
                spec.type = 'hold';
                spec.repsPerSet = base.repsPerSet || 1;
                spec.secondsPerRep = entry.hold_seconds;
            } else if (entry.duration_seconds) {
                spec.type = 'duration';
                spec.repsPerSet = base.repsPerSet || 1;
                spec.secondsPerRep = entry.duration_seconds;
            } else if (entry.amrap_window_sec) {
                spec.type = 'amrap';
                spec.repsPerSet = 0;
                spec.secondsPerRep = entry.amrap_window_sec;
            } else if (entry.distance_meters) {
                spec.type = 'distance';
                spec.repsPerSet = entry.distance_meters;
                spec.secondsPerRep = 0;
            }

            return spec;
        }

        const DEFAULT_LIBRARY = ATLAS_SEED.map(entry => {
            const spec = atlasSeedToSpec(entry);
            return {
                id: entry.id,
                name: entry.name,
                supersedes: entry.supersedes || [],
                atlasUrl: ATLAS_REFERENCE_URL,
                current: spec,
                history: [
                    {
                        timestamp: new Date().toISOString(),
                        summary: entry.summary || 'Seeded from atlas_pt_min_250817.json',
                        previous: null,
                        next: spec,
                        supersedes: entry.supersedes || []
                    }
                ]
            };
        });
        let exerciseLibrary = loadExerciseLibrary();
        let currentExercise = toSessionExercise(exerciseLibrary[0]);

        let timerInterval = null;
        let timerSecondsRemaining = Math.max(currentExercise.secondsPerRep || 0, 1); // counts DOWN
        let timerRunning = false;
        let actionSheetCallback = null;
        let pocketMode = false;

        const TIMER_TYPES = ['timed', 'hold', 'duration'];
        const COUNTER_TYPES = ['reps', 'amrap', 'distance'];

        // Audio for timer
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function loadExerciseLibrary() {
            const stored = localStorage.getItem(LIBRARY_KEY);
            if (stored) {
                try {
                    const parsed = JSON.parse(stored);
                    if (Array.isArray(parsed) && parsed.length) {
                        return parsed;
                    }
                } catch (e) {
                    console.warn('Unable to parse exercise library; reseeding defaults');
                }
            }
            localStorage.setItem(LIBRARY_KEY, JSON.stringify(DEFAULT_LIBRARY));
            return JSON.parse(localStorage.getItem(LIBRARY_KEY));
        }

        function persistExerciseLibrary() {
            localStorage.setItem(LIBRARY_KEY, JSON.stringify(exerciseLibrary));
        }

        function toSessionExercise(entry) {
            const spec = entry?.current || {};
            return {
                id: entry.id,
                name: entry.name,
                type: spec.type || 'reps',
                sets: spec.sets || 3,
                repsPerSet: spec.repsPerSet || 10,
                secondsPerRep: spec.secondsPerRep ?? 10,
                currentSet: 1,
                currentRep: 0,
                sessionData: []
            };
        }

        function getLibraryEntryById(id) {
            return exerciseLibrary.find(ex => ex.id === id) || exerciseLibrary[0];
        }

        function recordRevision(entry, nextSpec, reason = 'Updated dosage') {
            const previous = { ...(entry.current || {}) };
            const changes = [];

            if ((previous.sets ?? null) !== nextSpec.sets) changes.push(`sets ${previous.sets ?? 'â€”'} â†’ ${nextSpec.sets}`);
            if ((previous.repsPerSet ?? null) !== nextSpec.repsPerSet) changes.push(`reps ${previous.repsPerSet ?? 'â€”'} â†’ ${nextSpec.repsPerSet}`);
            if ((previous.secondsPerRep ?? null) !== nextSpec.secondsPerRep) changes.push(`seconds ${previous.secondsPerRep ?? 'â€”'} â†’ ${nextSpec.secondsPerRep}`);
            if ((previous.type ?? '') !== nextSpec.type) changes.push(`type ${previous.type || 'reps'} â†’ ${nextSpec.type}`);

            entry.history = entry.history || [];
            entry.history.push({
                timestamp: new Date().toISOString(),
                summary: changes.length ? changes.join(', ') : reason,
                previous,
                next: nextSpec,
                supersedes: entry.supersedes || []
            });

            entry.current = nextSpec;
            persistExerciseLibrary();
        }

        function populateExerciseSelect() {
            const select = document.getElementById('exercise-select');
            const selectedValue = currentExercise?.id;
            select.innerHTML = '';

            exerciseLibrary.forEach(entry => {
                const opt = document.createElement('option');
                opt.value = entry.id;
                opt.textContent = entry.name;
                if (entry.id === selectedValue) {
                    opt.selected = true;
                }
                select.appendChild(opt);
            });
        }

        function applyLibraryEntryToForm(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            const spec = entry.current || {};

            document.getElementById('exercise-type').value = spec.type || 'reps';
            document.getElementById('sets-input').value = spec.sets || 3;
            document.getElementById('reps-input').value = spec.repsPerSet || 10;
            document.getElementById('target-input').value = spec.secondsPerRep ?? 10;
            updateTargetLabel();
        }

        function playBeep(frequency = 800, duration = 200) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = 'square'; // More noticeable than sine

            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime); // Louder
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration / 1000);
        }

        function playCompletionSound() {
            // Triple beep for completion
            playBeep(1000, 150);
            setTimeout(() => playBeep(1200, 150), 200);
            setTimeout(() => playBeep(1400, 200), 400);
        }

        // Haptic feedback helper
        function haptic(style = 'light') {
            if ('vibrate' in navigator) {
                switch(style) {
                    case 'light':
                        navigator.vibrate(10);
                        break;
                    case 'medium':
                        navigator.vibrate(20);
                        break;
                    case 'heavy':
                        navigator.vibrate(30);
                        break;
                    case 'success':
                        navigator.vibrate([10, 50, 10]);
                        break;
                    case 'error':
                        navigator.vibrate([20, 100, 20]);
                        break;
                }
            }
        }

        const isTimerType = (type) => TIMER_TYPES.includes(type);

        function togglePocketMode(enabled) {
            pocketMode = enabled;
            const overlay = document.getElementById('pocket-overlay');
            if (enabled) {
                overlay.classList.add('active');
                haptic('medium');
            } else {
                overlay.classList.remove('active');
                haptic('light');
            }
            updatePocketOverlay();
        }

        function handlePocketTap() {
            if (!pocketMode) return;

            if (COUNTER_TYPES.includes(currentExercise.type)) {
                incrementCounter();
            } else if (isTimerType(currentExercise.type)) {
                if (!timerRunning) {
                    startTimer();
                } else {
                    stopTimer();
                }
            }
            updatePocketOverlay();
        }

        function updatePocketOverlay() {
            const overlay = document.getElementById('pocket-overlay');
            if (!overlay.classList.contains('active')) return;

            const setsLeft = Math.max(currentExercise.sets - currentExercise.currentSet, 0);
            const repsLeft = Math.max((currentExercise.repsPerSet || 0) - currentExercise.currentRep, 0);
            const label = COUNTER_TYPES.includes(currentExercise.type)
                ? `${currentExercise.currentRep}`
                : `${formatSeconds(timerSecondsRemaining)}`;

            document.getElementById('pocket-label').textContent = label;

            const metaPieces = [
                `Sets left: ${setsLeft}`
            ];

            if (COUNTER_TYPES.includes(currentExercise.type) && currentExercise.type !== 'amrap' && currentExercise.repsPerSet) {
                metaPieces.push(`Reps left: ${repsLeft}`);
            }

            if (currentExercise.type === 'amrap' && currentExercise.secondsPerRep) {
                metaPieces.push(`AMRAP ${currentExercise.secondsPerRep}s window`);
            }

            if (currentExercise.type === 'distance') {
                metaPieces.push(`Distance goal: ${currentExercise.repsPerSet}`);
            }

            if (isTimerType(currentExercise.type)) {
                metaPieces.push(timerRunning ? 'Timer running' : 'Timer paused');
            }

            document.getElementById('pocket-meta').textContent = metaPieces.join(' Â· ');
        }

        // iOS-style Action Sheet
        function showActionSheet(message, onConfirm) {
            document.getElementById('action-sheet-message').textContent = message;
            actionSheetCallback = onConfirm;

            const backdrop = document.getElementById('action-sheet-backdrop');
            const sheet = document.getElementById('action-sheet');

            backdrop.classList.add('active');
            setTimeout(() => {
                sheet.classList.add('active');
            }, 10);

            haptic('light');
        }

        function hideActionSheet() {
            const backdrop = document.getElementById('action-sheet-backdrop');
            const sheet = document.getElementById('action-sheet');

            sheet.classList.remove('active');
            setTimeout(() => {
                backdrop.classList.remove('active');
            }, 300);

            actionSheetCallback = null;
            haptic('light');
        }

        function confirmActionSheet() {
            if (actionSheetCallback) {
                actionSheetCallback();
            }
            hideActionSheet();
            haptic('medium');
        }

        // Counter Functions
        function incrementCounter() {
            if (!COUNTER_TYPES.includes(currentExercise.type)) return;

            currentExercise.currentRep++;
            haptic('light');

            // Check if target reached
            if (currentExercise.repsPerSet && currentExercise.currentRep >= currentExercise.repsPerSet && currentExercise.type !== 'amrap') {
                playCompletionSound();
                haptic('success');
            }

            updateDisplay();
        }

        function formatSeconds(totalSeconds = 0) {
            const minutes = Math.floor(Math.max(totalSeconds, 0) / 60);
            const seconds = Math.max(totalSeconds % 60, 0);
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function updateDisplay() {
            document.getElementById('exercise-name').textContent = currentExercise.name;
            document.getElementById('set-info').textContent = `Set ${currentExercise.currentSet} of ${currentExercise.sets}`;

            const setsLeft = Math.max(currentExercise.sets - currentExercise.currentSet, 0);
            const repsLeft = Math.max((currentExercise.repsPerSet || 0) - currentExercise.currentRep, 0);

            let remainingLabel = `Sets left: ${setsLeft}`;
            if (COUNTER_TYPES.includes(currentExercise.type) && currentExercise.type !== 'amrap' && currentExercise.repsPerSet) {
                remainingLabel += ` Â· Reps left: ${repsLeft}`;
            }
            if (currentExercise.type === 'amrap' && currentExercise.secondsPerRep) {
                remainingLabel += ` Â· ${currentExercise.secondsPerRep}s AMRAP window`;
            }
            if (isTimerType(currentExercise.type)) {
                remainingLabel += ` Â· Time: ${formatSeconds(timerSecondsRemaining)}`;
            }
            document.getElementById('remaining-info').textContent = remainingLabel;

            if (COUNTER_TYPES.includes(currentExercise.type)) {
                document.getElementById('counter-mode').classList.remove('hidden');
                document.getElementById('timer-mode').classList.add('hidden');
                document.getElementById('main-controls').classList.remove('hidden');

                document.getElementById('counter-display').textContent = currentExercise.currentRep;

                let targetText = 'Target: ';
                if (currentExercise.type === 'amrap') {
                    targetText += currentExercise.secondsPerRep ? `${currentExercise.secondsPerRep}s AMRAP window` : 'AMRAP';
                } else if (currentExercise.type === 'distance') {
                    targetText += `${currentExercise.repsPerSet || 0} distance units`;
                } else {
                    targetText += `${currentExercise.repsPerSet} reps`;
                }
                document.getElementById('target-info').textContent = targetText;

                const progress = currentExercise.repsPerSet
                    ? Math.min((currentExercise.currentRep / currentExercise.repsPerSet) * 100, 100)
                    : Math.min((currentExercise.currentSet / currentExercise.sets) * 100, 100);
                document.getElementById('progress-bar').style.width = progress + '%';
            } else {
                document.getElementById('counter-mode').classList.add('hidden');
                document.getElementById('timer-mode').classList.remove('hidden');
                document.getElementById('main-controls').classList.remove('hidden');

                const repLabel = currentExercise.type === 'hold' || currentExercise.type === 'duration'
                    ? `Set ${currentExercise.currentSet} timer`
                    : `Rep ${currentExercise.currentRep + 1} of ${currentExercise.repsPerSet}`;
                document.getElementById('timer-rep-info').textContent = repLabel;

                const display = formatSeconds(timerSecondsRemaining);
                document.getElementById('timer-display').textContent = display;

                const timerLabel = currentExercise.type === 'duration'
                    ? `Target: ${currentExercise.secondsPerRep || 0}s total`
                    : `Target: ${currentExercise.secondsPerRep || 0} seconds`;
                document.getElementById('timer-target').textContent = timerLabel;

                const progress = currentExercise.secondsPerRep
                    ? Math.max(0, (timerSecondsRemaining / currentExercise.secondsPerRep) * 100)
                    : 0;
                document.getElementById('timer-progress-bar').style.width = progress + '%';

                const timerDisplay = document.getElementById('timer-display');
                timerDisplay.classList.remove('warning', 'danger');
                if (timerSecondsRemaining <= 5 && timerSecondsRemaining > 0) {
                    timerDisplay.classList.add('danger');
                } else if (timerSecondsRemaining <= 10 && timerSecondsRemaining > 5) {
                    timerDisplay.classList.add('warning');
                }

                if (timerRunning) {
                    document.getElementById('timer-start-btn').classList.add('hidden');
                    document.getElementById('timer-stop-btn').classList.remove('hidden');
                    document.getElementById('timer-reset-btn').classList.add('hidden');
                } else if (timerSecondsRemaining === 0 || timerSecondsRemaining === currentExercise.secondsPerRep) {
                    document.getElementById('timer-start-btn').classList.remove('hidden');
                    document.getElementById('timer-stop-btn').classList.add('hidden');
                    document.getElementById('timer-reset-btn').classList.add('hidden');
                } else {
                    document.getElementById('timer-start-btn').classList.remove('hidden');
                    document.getElementById('timer-stop-btn').classList.add('hidden');
                    document.getElementById('timer-reset-btn').classList.remove('hidden');
                }
            }

            updatePocketOverlay();
        }

        function startTimer() {
            if (timerInterval || !isTimerType(currentExercise.type)) return;

            const targetSeconds = Math.max(currentExercise.secondsPerRep || 0, 1);

            // Initialize timer if starting fresh
            if (timerSecondsRemaining === 0) {
                timerSecondsRemaining = targetSeconds;
            }

            timerRunning = true;
            haptic('medium');

            timerInterval = setInterval(() => {
                timerSecondsRemaining--;
                updateDisplay();

                // Countdown beeps
                if (timerSecondsRemaining <= 3 && timerSecondsRemaining > 0) {
                    playBeep(600, 100);
                    haptic('light');
                }

                // Timer complete
                if (timerSecondsRemaining <= 0) {
                    stopTimer();
                    playCompletionSound();
                    haptic('success');

                    currentExercise.currentRep++;

                    // Auto-complete holds/durations when rep target is reached
                    if (currentExercise.type !== 'timed' && currentExercise.repsPerSet && currentExercise.currentRep >= currentExercise.repsPerSet) {
                        updateDisplay();
                        return;
                    }

                    // Reset timer for next rep
                    timerSecondsRemaining = targetSeconds;
                    updateDisplay();
                }
            }, 1000);

            updateDisplay();
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            timerRunning = false;
            haptic('light');
            updateDisplay();
        }

        function seedTimerSeconds() {
            timerSecondsRemaining = isTimerType(currentExercise.type)
                ? Math.max(currentExercise.secondsPerRep || 0, 1)
                : 0;
        }

        function resetTimer() {
            stopTimer();
            seedTimerSeconds();
            haptic('medium');
            updateDisplay();
        }

        function completeSet() {
            const reps = currentExercise.currentRep;

            if (reps === 0) {
                showActionSheet('No reps recorded. Complete set anyway?', () => {
                    finishSet();
                });
                return;
            }

            currentExercise.sessionData.push({
                set: currentExercise.currentSet,
                reps: reps,
                type: currentExercise.type,
                timestamp: new Date().toISOString()
            });

            haptic('success');

            if (currentExercise.currentSet < currentExercise.sets) {
                currentExercise.currentSet++;
                currentExercise.currentRep = 0;
                seedTimerSeconds();
                stopTimer();
                updateDisplay();
            } else {
                showActionSheet('Exercise complete! Save this session?', () => {
                    saveSession();
                });
            }
        }

        function finishSet() {
            currentExercise.sessionData.push({
                set: currentExercise.currentSet,
                reps: currentExercise.currentRep,
                type: currentExercise.type,
                timestamp: new Date().toISOString()
            });

            if (currentExercise.currentSet < currentExercise.sets) {
                currentExercise.currentSet++;
                currentExercise.currentRep = 0;
                seedTimerSeconds();
                stopTimer();
                updateDisplay();
            } else {
                saveSession();
            }
        }

        function skipSet() {
            // Log set as complete with target reps (assumes you did it manually)
            const targetReps = currentExercise.repsPerSet || 0;

            currentExercise.sessionData.push({
                set: currentExercise.currentSet,
                reps: targetReps,
                type: currentExercise.type,
                timestamp: new Date().toISOString(),
                skipped: true // Mark that this was manually logged
            });

            haptic('medium');

            if (currentExercise.currentSet < currentExercise.sets) {
                currentExercise.currentSet++;
                currentExercise.currentRep = 0;
                seedTimerSeconds();
                stopTimer();
                updateDisplay();
            } else {
                showActionSheet('Exercise complete! Save this session?', () => {
                    saveSession();
                });
            }
        }

        function previousSet() {
            if (currentExercise.currentSet > 1) {
                currentExercise.currentSet--;
                currentExercise.currentRep = 0;
                seedTimerSeconds();
                stopTimer();
                haptic('light');
                updateDisplay();
            }
        }

        function saveSession() {
            const sessions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            sessions.push({
                exerciseId: currentExercise.id,
                exerciseName: currentExercise.name,
                exerciseType: currentExercise.type,
                date: new Date().toISOString(),
                exerciseSpec: {
                    sets: currentExercise.sets,
                    repsPerSet: currentExercise.repsPerSet,
                    secondsPerRep: currentExercise.secondsPerRep,
                    type: currentExercise.type
                },
                sets: currentExercise.sessionData
            });
            localStorage.setItem(STORAGE_KEY, JSON.stringify(sessions));

            haptic('success');

            // Reset for new session
            currentExercise.currentSet = 1;
            currentExercise.currentRep = 0;
            currentExercise.sessionData = [];
            seedTimerSeconds();
            stopTimer();
            updateDisplay();
        }

        // Modal Functions
        function showExerciseModal() {
            populateExerciseSelect();
            applyLibraryEntryToForm(currentExercise.id);
            document.getElementById('exercise-modal').classList.add('active');
            haptic('light');
        }

        function closeExerciseModal() {
            document.getElementById('exercise-modal').classList.remove('active');
            haptic('light');
        }

        function updateTargetLabel() {
            const type = document.getElementById('exercise-type').value;
            const targetInput = document.getElementById('target-input');

            const placeholders = {
                timed: 'Seconds per rep (timed reps)',
                hold: 'Seconds to hold',
                duration: 'Seconds per set (duration)',
                amrap: 'AMRAP window (seconds, optional)',
                distance: 'Distance goal (steps/meters)',
                reps: 'Target (seconds optional)'
            };

            targetInput.placeholder = placeholders[type] || 'Target (seconds or distance)';
            targetInput.disabled = type === 'reps';
        }

        function updateExerciseType() {
            const select = document.getElementById('exercise-select');
            applyLibraryEntryToForm(select.value);
        }

        function saveExercise() {
            const select = document.getElementById('exercise-select');
            const exerciseName = select.options[select.selectedIndex].text;
            const exerciseId = select.value;
            const type = document.getElementById('exercise-type').value;
            const sets = parseInt(document.getElementById('sets-input').value);
            const reps = parseInt(document.getElementById('reps-input').value);
            const seconds = parseInt(document.getElementById('target-input').value);

            if (!sets) {
                alert('Please enter a valid number for sets.');
                return;
            }

            if (COUNTER_TYPES.includes(type) && type !== 'amrap' && (!reps && reps !== 0)) {
                alert('Please enter a valid number for reps/distance.');
                return;
            }

            if (type === 'distance' && (!reps || reps <= 0)) {
                alert('Please enter a distance goal.');
                return;
            }

            if (isTimerType(type) && (!seconds || seconds <= 0)) {
                alert('Please enter seconds for the timer-based exercise.');
                return;
            }

            const entry = getLibraryEntryById(exerciseId);
            const nextSpec = {
                type: type,
                sets: sets,
                repsPerSet: reps,
                secondsPerRep: (isTimerType(type) || type === 'amrap') ? (seconds || 0) : 0
            };

            const prevSpec = entry.current || {};
            if (
                prevSpec.type !== nextSpec.type ||
                prevSpec.sets !== nextSpec.sets ||
                prevSpec.repsPerSet !== nextSpec.repsPerSet ||
                (prevSpec.secondsPerRep ?? null) !== (nextSpec.secondsPerRep ?? null)
            ) {
                recordRevision(entry, nextSpec, 'Manual exercise update');
            } else {
                entry.current = nextSpec;
                persistExerciseLibrary();
            }

            exerciseLibrary = loadExerciseLibrary();
            currentExercise = toSessionExercise({ ...entry, name: exerciseName, id: exerciseId });

            seedTimerSeconds();
            stopTimer();

            haptic('success');
            updateDisplay();
            closeExerciseModal();
        }

        function showHistory() {
            renderHistory();
            document.getElementById('history-modal').classList.add('active');
            haptic('light');
        }

        function closeHistoryModal() {
            document.getElementById('history-modal').classList.remove('active');
            haptic('light');
        }

        function describeSpec(spec) {
            if (!spec) return 'No spec available';
            const parts = [
                `${spec.sets || 0} sets`,
                spec.type === 'timed' ? `${spec.repsPerSet || 0} reps Ã— ${spec.secondsPerRep || 0}s` : `${spec.repsPerSet || 0} reps`
            ];
            return parts.join(' Â· ');
        }

        function renderHistory() {
            const sessions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            const exerciseHistoryList = document.getElementById('exercise-history-list');
            const sessionHistoryList = document.getElementById('session-history-list');
            const exerciseEntry = getLibraryEntryById(currentExercise.id);

            if (!exerciseEntry.history || exerciseEntry.history.length === 0) {
                exerciseHistoryList.innerHTML = '<div class="history-item">No revisions logged yet.</div>';
            } else {
                exerciseHistoryList.innerHTML = exerciseEntry.history
                    .slice()
                    .reverse()
                    .map(revision => {
                        const supersedesLabel = revision.supersedes && revision.supersedes.length
                            ? `<span class="pill">Supersedes ${revision.supersedes.join(', ')}</span>`
                            : '';
                        return `
                            <div class="history-item">
                                <div>${revision.summary}</div>
                                ${supersedesLabel}
                                <div class="history-meta">${new Date(revision.timestamp).toLocaleString()} Â· ${describeSpec(revision.next)}</div>
                            </div>
                        `;
                    })
                    .join('');
            }

            const relevantSessions = sessions
                .filter(s => (s.exerciseId && s.exerciseId === currentExercise.id) || s.exerciseName === currentExercise.name)
                .slice()
                .reverse();

            if (relevantSessions.length === 0) {
                sessionHistoryList.innerHTML = '<div class="history-item">No sessions tracked yet.</div>';
            } else {
                sessionHistoryList.innerHTML = relevantSessions
                    .slice(0, 10)
                    .map(session => {
                        const totalReps = (session.sets || []).reduce((sum, set) => sum + (set.reps || 0), 0);
                        const sessionLabel = session.exerciseType === 'timed'
                            ? `${session.sets?.length || 0} sets Â· ${session.exerciseType} Â· ${totalReps} reps`
                            : `${session.sets?.length || 0} sets Â· ${totalReps} reps`;
                        return `
                            <div class="history-item">
                                <div>${session.exerciseName}</div>
                                <div class="history-meta">${new Date(session.date).toLocaleString()} Â· ${sessionLabel}</div>
                            </div>
                        `;
                    })
                    .join('');
            }
        }

        // Initialize
        updateDisplay();
    </script>
</body>
</html>
