<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Migrate Roles to pt_shared</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            background: #007AFF;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px 5px;
        }
        button:hover {
            background: #0051D5;
        }
        .log {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
            font-family: monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        .success { color: #34C759; }
        .error { color: #FF3B30; }
        .info { color: #007AFF; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Migrate Roles to pt_shared</h1>
        <p>This will copy roles from your pt_runtime modifications to the shared pt_shared/exercise_roles document.</p>
        <div id="status" style="padding: 10px; margin: 10px 0; border-radius: 4px; background: #f0f0f0;">
            Checking login status...
        </div>
        <button id="retry-btn" onclick="checkAuthManually()" style="margin-right: 10px;">üîÑ Retry Login Check</button>
        <button id="migrate-btn" onclick="migrateRoles()" disabled style="opacity: 0.5;">Migrate Roles</button>
        <div id="log" class="log"></div>
    </div>

    <script type="module">
        import {
            auth,
            db,
            onAuthStateChanged,
            setPersistence,
            browserLocalPersistence
        } from './firebase.js';
        import { doc, getDoc, setDoc, collection, query, where, getDocs } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js';

        let currentUserId = null;

        function log(message, type = 'info') {
            const logEl = document.getElementById('log');
            const span = document.createElement('div');
            span.className = type;
            span.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEl.appendChild(span);
            logEl.scrollTop = logEl.scrollHeight;
            console.log(message);
        }

        // Debug: log auth initialization
        log('Firebase initialized, waiting for auth state...', 'info');
        console.log('[Debug] Auth instance:', auth);
        console.log('[Debug] Current user (immediate):', auth.currentUser);

        // Ensure auth state persists across pages (pt_tracker -> migrate_roles).
        async function initAuthPersistence() {
            try {
                await setPersistence(auth, browserLocalPersistence);
                log('Auth persistence set to local storage.', 'info');
                console.log('[Debug] Auth persistence set to browserLocalPersistence');
            } catch (error) {
                log(`Auth persistence setup failed: ${error.message}`, 'error');
                console.error('[Debug] Auth persistence error:', error);
            }
        }

        async function handleAuthUser(user) {
            const statusEl = document.getElementById('status');
            const btnEl = document.getElementById('migrate-btn');

            console.log('[Debug] handleAuthUser called with user:', user);

            if (user) {
                statusEl.textContent = 'Checking user type...';
                statusEl.style.background = '#FFF9C4';
                log(`User detected: ${user.email || user.uid}`, 'info');

                try {
                    // Check if therapist or patient
                    const usersRef = collection(db, 'users');
                    const q = query(usersRef, where('therapistUid', '==', user.uid));
                    const snapshot = await getDocs(q);

                    if (!snapshot.empty) {
                        currentUserId = snapshot.docs[0].id;
                        statusEl.textContent = `‚úì Logged in as therapist (patient: ${currentUserId})`;
                        statusEl.style.background = '#C8E6C9';
                        log(`Logged in as therapist, patient ID: ${currentUserId}`, 'success');
                    } else {
                        currentUserId = user.uid;
                        statusEl.textContent = `‚úì Logged in as patient (${user.email || currentUserId})`;
                        statusEl.style.background = '#C8E6C9';
                        log(`Logged in as patient: ${currentUserId}`, 'success');
                    }

                    // Enable button
                    btnEl.disabled = false;
                    btnEl.style.opacity = '1';
                } catch (error) {
                    log(`Error checking user type: ${error.message}`, 'error');
                    console.error(error);
                }
            } else {
                statusEl.innerHTML = '‚ö†Ô∏è Not logged in - <a href="pt_tracker.html">Open PT Tracker to sign in first</a>';
                statusEl.style.background = '#FFCDD2';
                log('Not logged in - please sign in first', 'error');
                btnEl.disabled = true;
                btnEl.style.opacity = '0.5';
            }
        }

        async function watchAuthState() {
            await initAuthPersistence();
            onAuthStateChanged(auth, async (user) => {
                console.log('[Debug] onAuthStateChanged fired with user:', user);
                await handleAuthUser(user);
            });
        }

        watchAuthState();

        window.checkAuthManually = async function() {
            log('Manually checking auth state...', 'info');
            const user = auth.currentUser;
            console.log('[Debug] Manual check - current user:', user);
            await handleAuthUser(user);
        };

        window.migrateRoles = async function() {
            if (!currentUserId) {
                log('ERROR: Not logged in', 'error');
                return;
            }

            try {
                log('Starting migration...', 'info');

                // 1. Load roles from pt_runtime modifications
                const runtimeRef = doc(db, `users/${currentUserId}/pt_runtime/state`);
                const runtimeSnap = await getDoc(runtimeRef);

                if (!runtimeSnap.exists()) {
                    log('ERROR: No runtime data found', 'error');
                    return;
                }

                const runtimeData = runtimeSnap.data();
                const modifications = runtimeData.pt_modifications || {};
                const newRoles = modifications.newRoles || {};
                const editedRoles = modifications.editedRoles || {};

                log(`Found ${Object.keys(newRoles).length} exercises with new roles`, 'info');
                log(`Found ${Object.keys(editedRoles).length} exercises with edited roles`, 'info');

                // 2. Load existing pt_shared/exercise_roles
                const rolesRef = doc(db, 'pt_shared/exercise_roles');
                const rolesSnap = await getDoc(rolesRef);

                let rolesData = rolesSnap.exists() ? rolesSnap.data() : { exercise_roles: {} };
                if (!rolesData.exercise_roles) {
                    rolesData.exercise_roles = {};
                }

                log(`Current pt_shared has ${Object.keys(rolesData.exercise_roles).length} exercises`, 'info');

                // 3. Merge roles
                let migratedCount = 0;

                // Process newRoles
                for (const [exerciseId, roles] of Object.entries(newRoles)) {
                    const exerciseName = runtimeData.exerciseLibrary?.find(ex => ex.id === exerciseId)?.canonical_name || exerciseId;

                    if (!rolesData.exercise_roles[exerciseId]) {
                        rolesData.exercise_roles[exerciseId] = {
                            id: exerciseId,
                            name: exerciseName,
                            roles: []
                        };
                    }

                    // Add new roles
                    rolesData.exercise_roles[exerciseId].roles.push(...roles);
                    migratedCount++;
                    log(`‚úì Migrated ${roles.length} role(s) for ${exerciseName}`, 'success');
                }

                // Process editedRoles (these replace all roles for an exercise)
                for (const [exerciseId, roles] of Object.entries(editedRoles)) {
                    const exerciseName = runtimeData.exerciseLibrary?.find(ex => ex.id === exerciseId)?.canonical_name || exerciseId;

                    rolesData.exercise_roles[exerciseId] = {
                        id: exerciseId,
                        name: exerciseName,
                        roles: roles
                    };
                    migratedCount++;
                    log(`‚úì Replaced all roles for ${exerciseName}`, 'success');
                }

                // 4. Save to pt_shared/exercise_roles
                await setDoc(rolesRef, rolesData, { merge: true });
                log(`SUCCESS: Migrated roles for ${migratedCount} exercises to pt_shared/exercise_roles`, 'success');
                log(`Total exercises with roles: ${Object.keys(rolesData.exercise_roles).length}`, 'info');

                // 5. Clear modifications from runtime (optional - keeps them as backup)
                // log('Clearing modifications from pt_runtime...', 'info');
                // await setDoc(runtimeRef, {
                //     pt_modifications: {
                //         ...modifications,
                //         newRoles: {},
                //         editedRoles: {}
                //     }
                // }, { merge: true });

                log('COMPLETE! Refresh rehab_coverage to see your data.', 'success');

            } catch (error) {
                log(`ERROR: ${error.message}`, 'error');
                console.error(error);
            }
        };
    </script>
</body>
</html>
