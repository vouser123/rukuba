<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Migrate Roles to pt_shared</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            background: #007AFF;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px 5px;
        }
        button:hover {
            background: #0051D5;
        }
        .log {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
            font-family: monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        .success { color: #34C759; }
        .error { color: #FF3B30; }
        .info { color: #007AFF; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Migrate Roles to pt_shared</h1>
        <p>This will copy roles from your pt_runtime modifications to the shared pt_shared/exercise_roles document.</p>
        <div id="status" style="padding: 10px; margin: 10px 0; border-radius: 4px; background: #f0f0f0;">
            Checking login status...
        </div>
        <button id="retry-btn" onclick="checkAuthManually()" style="margin-right: 10px;">üîÑ Retry Login Check</button>
        <button id="migrate-btn" onclick="migrateRoles()" disabled style="opacity: 0.5;">Migrate Roles</button>
        <div id="log" class="log"></div>
        <div id="debug-panel" style="margin-top: 20px; background: #fff7e6; padding: 12px; border-radius: 6px; border: 1px solid #ffcc80; font-size: 12px; font-family: monospace;">
            <div style="font-weight: 600; margin-bottom: 8px; color: #FF9500;">Debug Info</div>
            <div id="debug-content">Waiting for auth state...</div>
        </div>
    </div>

    <script type="module">
        import {
            auth,
            db,
            onAuthStateChanged,
            setPersistence,
            browserLocalPersistence
        } from './firebase.js';
        import { doc, getDoc, setDoc, collection, query, where, getDocs } from 'https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js';

        let currentUserId = null;
        const debugState = {
            authUser: null,
            resolvedUserId: null,
            resolvedUserType: null,
            therapistMatchCount: null,
            runtimeExists: null,
            runtimeNewRolesCount: 0,
            runtimeEditedRolesCount: 0,
            sharedRolesCount: null,
            lastMigrationSummary: null,
            lastError: null
        };

        function updateDebug(partial) {
            Object.assign(debugState, partial);
            const debugEl = document.getElementById('debug-content');
            if (!debugEl) return;

            const authLabel = debugState.authUser
                ? `${debugState.authUser.email || debugState.authUser.uid}`
                : 'none';
            const resolvedId = debugState.resolvedUserId || 'unknown';
            const resolvedType = debugState.resolvedUserType || 'unknown';
            const therapistCount = debugState.therapistMatchCount ?? 'unknown';
            const runtimeStatus = debugState.runtimeExists === null
                ? 'unknown'
                : (debugState.runtimeExists ? 'found' : 'missing');
            const sharedCount = debugState.sharedRolesCount ?? 'unknown';
            const lastMigration = debugState.lastMigrationSummary || 'none';
            const lastError = debugState.lastError || 'none';

            debugEl.innerHTML = `
                <div><strong>Auth user:</strong> ${authLabel}</div>
                <div><strong>User type:</strong> ${resolvedType}</div>
                <div><strong>Resolved user ID:</strong> ${resolvedId}</div>
                <div><strong>Therapist match count:</strong> ${therapistCount}</div>
                <div><strong>Runtime doc:</strong> ${runtimeStatus}</div>
                <div><strong>Runtime newRoles count:</strong> ${debugState.runtimeNewRolesCount}</div>
                <div><strong>Runtime editedRoles count:</strong> ${debugState.runtimeEditedRolesCount}</div>
                <div><strong>Shared roles count:</strong> ${sharedCount}</div>
                <div><strong>Last migration:</strong> ${lastMigration}</div>
                <div><strong>Last error:</strong> ${lastError}</div>
            `;
        }

        function log(message, type = 'info') {
            const logEl = document.getElementById('log');
            const span = document.createElement('div');
            span.className = type;
            span.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEl.appendChild(span);
            logEl.scrollTop = logEl.scrollHeight;
            console.log(message);
        }

        // Debug: log auth initialization
        log('Firebase initialized, waiting for auth state...', 'info');
        console.log('[Debug] Auth instance:', auth);
        console.log('[Debug] Current user (immediate):', auth.currentUser);
        updateDebug({ authUser: auth.currentUser });

        // Ensure auth state persists across pages (pt_tracker -> migrate_roles).
        async function initAuthPersistence() {
            try {
                await setPersistence(auth, browserLocalPersistence);
                log('Auth persistence set to local storage.', 'info');
                console.log('[Debug] Auth persistence set to browserLocalPersistence');
            } catch (error) {
                log(`Auth persistence setup failed: ${error.message}`, 'error');
                console.error('[Debug] Auth persistence error:', error);
                updateDebug({ lastError: `Auth persistence failed: ${error.message}` });
            }
        }

        async function handleAuthUser(user) {
            const statusEl = document.getElementById('status');
            const btnEl = document.getElementById('migrate-btn');

            console.log('[Debug] handleAuthUser called with user:', user);

            updateDebug({ authUser: user });

            if (user) {
                statusEl.textContent = 'Checking user type...';
                statusEl.style.background = '#FFF9C4';
                log(`User detected: ${user.email || user.uid}`, 'info');

                try {
                    // Check if therapist or patient
                    const usersRef = collection(db, 'users');
                    const q = query(usersRef, where('therapistUid', '==', user.uid));
                    const snapshot = await getDocs(q);

                    if (!snapshot.empty) {
                        currentUserId = snapshot.docs[0].id;
                        statusEl.textContent = `‚úì Logged in as therapist (patient: ${currentUserId})`;
                        statusEl.style.background = '#C8E6C9';
                        log(`Logged in as therapist, patient ID: ${currentUserId}`, 'success');
                        updateDebug({
                            resolvedUserId: currentUserId,
                            resolvedUserType: 'therapist',
                            therapistMatchCount: snapshot.size
                        });
                    } else {
                        currentUserId = user.uid;
                        statusEl.textContent = `‚úì Logged in as patient (${user.email || currentUserId})`;
                        statusEl.style.background = '#C8E6C9';
                        log(`Logged in as patient: ${currentUserId}`, 'success');
                        updateDebug({
                            resolvedUserId: currentUserId,
                            resolvedUserType: 'patient',
                            therapistMatchCount: snapshot.size
                        });
                    }

                    // Enable button
                    btnEl.disabled = false;
                    btnEl.style.opacity = '1';
                } catch (error) {
                    log(`Error checking user type: ${error.message}`, 'error');
                    console.error(error);
                    updateDebug({ lastError: `Auth user resolution failed: ${error.message}` });
                }
            } else {
                statusEl.innerHTML = '‚ö†Ô∏è Not logged in - <a href="pt_tracker.html">Open PT Tracker to sign in first</a>';
                statusEl.style.background = '#FFCDD2';
                log('Not logged in - please sign in first', 'error');
                btnEl.disabled = true;
                btnEl.style.opacity = '0.5';
                updateDebug({
                    resolvedUserId: null,
                    resolvedUserType: null,
                    therapistMatchCount: null
                });
            }
        }

        async function watchAuthState() {
            await initAuthPersistence();
            onAuthStateChanged(auth, async (user) => {
                console.log('[Debug] onAuthStateChanged fired with user:', user);
                await handleAuthUser(user);
            });
        }

        watchAuthState();

        window.checkAuthManually = async function() {
            log('Manually checking auth state...', 'info');
            const user = auth.currentUser;
            console.log('[Debug] Manual check - current user:', user);
            await handleAuthUser(user);
        };

        function sanitizeRolePayload(rolesData) {
            const exerciseRoles = rolesData?.exercise_roles;
            if (!exerciseRoles || typeof exerciseRoles !== 'object') {
                return { exercise_roles: {} };
            }

            const sanitized = {};
            Object.entries(exerciseRoles).forEach(([exerciseId, entry]) => {
                if (!exerciseId || typeof exerciseId !== 'string') return;
                if (!entry || typeof entry !== 'object') return;
                const roles = Array.isArray(entry.roles) ? entry.roles : [];
                sanitized[exerciseId] = {
                    id: entry.id || exerciseId,
                    name: entry.name || exerciseId,
                    roles: roles.filter(role => role && typeof role === 'object')
                };
            });

            return { ...rolesData, exercise_roles: sanitized };
        }

        function sanitizeRoleList(roles) {
            if (!Array.isArray(roles)) return [];
            return roles.filter(role => role && typeof role === 'object');
        }

        window.migrateRoles = async function() {
            if (!currentUserId) {
                log('ERROR: Not logged in', 'error');
                return;
            }

            try {
                log('Starting migration...', 'info');
                updateDebug({ lastMigrationSummary: 'in progress', lastError: null });

                // 1. Load roles from pt_runtime modifications
                const runtimeRef = doc(db, `users/${currentUserId}/pt_runtime/state`);
                const runtimeSnap = await getDoc(runtimeRef);

                if (!runtimeSnap.exists()) {
                    log('ERROR: No runtime data found', 'error');
                    updateDebug({ runtimeExists: false, lastError: 'No runtime data found.' });
                    return;
                }

                const runtimeData = runtimeSnap.data();
                const modifications = runtimeData.pt_modifications || {};
                const newRoles = modifications.newRoles || {};
                const editedRoles = modifications.editedRoles || {};

                log(`Found ${Object.keys(newRoles).length} exercises with new roles`, 'info');
                log(`Found ${Object.keys(editedRoles).length} exercises with edited roles`, 'info');
                updateDebug({
                    runtimeExists: true,
                    runtimeNewRolesCount: Object.keys(newRoles).length,
                    runtimeEditedRolesCount: Object.keys(editedRoles).length
                });

                // 2. Load existing pt_shared/exercise_roles
                const rolesRef = doc(db, 'pt_shared/exercise_roles');
                const rolesSnap = await getDoc(rolesRef);

                let rolesData = rolesSnap.exists() ? rolesSnap.data() : { exercise_roles: {} };
                if (!rolesData.exercise_roles) {
                    rolesData.exercise_roles = {};
                }

                log(`Current pt_shared has ${Object.keys(rolesData.exercise_roles).length} exercises`, 'info');
                updateDebug({ sharedRolesCount: Object.keys(rolesData.exercise_roles).length });

                // 3. Merge roles
                let migratedCount = 0;

                // Process newRoles
                for (const [exerciseId, roles] of Object.entries(newRoles)) {
                    if (!exerciseId || typeof exerciseId !== 'string') {
                        continue;
                    }
                    const exerciseName = runtimeData.exerciseLibrary?.find(ex => ex.id === exerciseId)?.canonical_name || exerciseId;

                    if (!rolesData.exercise_roles[exerciseId]) {
                        rolesData.exercise_roles[exerciseId] = {
                            id: exerciseId,
                            name: exerciseName,
                            roles: []
                        };
                    }

                    // Add new roles
                    rolesData.exercise_roles[exerciseId].roles.push(...sanitizeRoleList(roles));
                    migratedCount++;
                    log(`‚úì Migrated ${roles.length} role(s) for ${exerciseName}`, 'success');
                }

                // Process editedRoles (these replace all roles for an exercise)
                for (const [exerciseId, roles] of Object.entries(editedRoles)) {
                    if (!exerciseId || typeof exerciseId !== 'string') {
                        continue;
                    }
                    const exerciseName = runtimeData.exerciseLibrary?.find(ex => ex.id === exerciseId)?.canonical_name || exerciseId;

                    rolesData.exercise_roles[exerciseId] = {
                        id: exerciseId,
                        name: exerciseName,
                        roles: sanitizeRoleList(roles)
                    };
                    migratedCount++;
                    log(`‚úì Replaced all roles for ${exerciseName}`, 'success');
                }

                // 4. Save to pt_shared/exercise_roles
                const sanitizedRolesData = sanitizeRolePayload(rolesData);
                await setDoc(rolesRef, sanitizedRolesData, { merge: true });
                log(`SUCCESS: Migrated roles for ${migratedCount} exercises to pt_shared/exercise_roles`, 'success');
                log(`Total exercises with roles: ${Object.keys(sanitizedRolesData.exercise_roles).length}`, 'info');
                updateDebug({
                    sharedRolesCount: Object.keys(sanitizedRolesData.exercise_roles).length,
                    lastMigrationSummary: `migrated ${migratedCount} exercise(s)`
                });

                // 5. Clear modifications from runtime (optional - keeps them as backup)
                // log('Clearing modifications from pt_runtime...', 'info');
                // await setDoc(runtimeRef, {
                //     pt_modifications: {
                //         ...modifications,
                //         newRoles: {},
                //         editedRoles: {}
                //     }
                // }, { merge: true });

                log('COMPLETE! Refresh rehab_coverage to see your data.', 'success');

            } catch (error) {
                log(`ERROR: ${error.message}`, 'error');
                console.error(error);
                updateDebug({ lastError: error.message, lastMigrationSummary: 'failed' });
            }
        };
    </script>
</body>
</html>
