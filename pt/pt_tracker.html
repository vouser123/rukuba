<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="PT Tracker">
    <link rel="manifest" href="manifest-pt.json">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%23007AFF' rx='20'/><text x='50' y='70' font-size='60' text-anchor='middle' fill='white'>üí™</text></svg>">
    <meta name="theme-color" content="#007AFF" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
    <title>PT Exercise Tracker</title>
    <style>
        :root {
            --ios-blue: #007AFF;
            --ios-red: #FF3B30;
            --ios-green: #34C759;
            --ios-orange: #FF9500;
            --ios-gray: #8E8E93;
            --ios-background: #F2F2F7;
            --bg-primary: #FFFFFF;
            --bg-secondary: #F2F2F7;
            --text-primary: #000000;
            --text-secondary: #3a3a3c;
            --border-color: rgba(0,0,0,0.1);
            --modal-bg: #FFFFFF;
            --input-bg: #FFFFFF;
            --shadow: rgba(0,0,0,0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --ios-background: #000000;
                --bg-primary: #1c1c1e;
                --bg-secondary: #2c2c2e;
                --text-primary: #FFFFFF;
                --text-secondary: #adadb3; /* Improved from #98989d for better WCAG contrast */
                --border-color: rgba(255,255,255,0.15);
                --modal-bg: #1c1c1e;
                --input-bg: #2c2c2e;
                --shadow: rgba(0,0,0,0.5);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: var(--ios-background);
            color: var(--text-primary);
            touch-action: manipulation;
            user-select: none;
            overflow-x: hidden;
            padding-bottom: 100px;
        }

        /* Header */
        .header {
            background: var(--bg-primary);
            padding: 16px 20px;
            box-shadow: 0 1px 0 rgba(0,0,0,0.08);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
            letter-spacing: -0.5px;
        }

        .exercise-name {
            font-size: 17px;
            color: var(--ios-blue);
            font-weight: 600;
            letter-spacing: -0.3px;
        }

        /* Main Counter View */
        .counter-view {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 250px);
            padding: 20px;
        }

        .set-info {
            font-size: 17px;
            color: var(--ios-gray);
            margin-bottom: 20px;
        }

        .counter-display {
            width: min(320px, 85vw);
            height: min(320px, 85vw);
            border-radius: 50%;
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 72px;
            font-weight: 700;
            color: var(--ios-blue);
            box-shadow: 0 4px 20px rgba(0, 122, 255, 0.3);
            margin-bottom: 30px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            /* Mobile Safari touch fixes for large tap target */
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }

        .counter-display:active {
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(0, 122, 255, 0.2);
        }

        .timer-display {
            font-size: 64px;
            font-weight: 700;
            color: var(--ios-blue);
            margin-bottom: 20px;
        }

        .timer-display.warning {
            color: var(--ios-orange);
        }

        .timer-display.danger {
            color: var(--ios-red);
        }

        .target-info {
            font-size: 17px;
            color: var(--ios-gray);
            margin-bottom: 30px;
        }

        .remaining-info {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            text-align: center;
            margin-bottom: 12px;
        }

        .progress-bar-container {
            width: 100%;
            max-width: 300px;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--ios-blue), var(--ios-green));
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 12px;
            width: 100%;
            max-width: 400px;
            padding: 0 20px;
        }

        .control-btn {
            flex: 1;
            padding: 10px 12px;
            font-size: 15px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
            /* Mobile Safari touch fixes */
            -webkit-appearance: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            min-height: 44px; /* Apple HIG minimum touch target */
            -webkit-user-select: none;
            user-select: none;
        }

        .control-btn:active {
            transform: scale(0.98);
            opacity: 0.8;
        }

        /* Force cursor pointer on all interactive elements */
        button, [onclick], .pill, .history-item {
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        .btn-primary {
            background: var(--ios-blue);
            color: white;
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.25);
            font-weight: 600;
            letter-spacing: -0.2px;
        }

        .btn-secondary {
            background: rgba(0, 122, 255, 0.08);
            color: var(--ios-blue);
            box-shadow: none;
            font-weight: 600;
            letter-spacing: -0.2px;
        }

        .btn-success {
            background: var(--ios-green);
            color: white;
            box-shadow: 0 2px 8px rgba(52, 199, 89, 0.25);
            font-weight: 600;
            letter-spacing: -0.2px;
        }

        .btn-danger {
            background: var(--ios-red);
            color: white;
            box-shadow: 0 2px 8px rgba(255, 59, 48, 0.25);
            font-weight: 600;
            letter-spacing: -0.2px;
        }

        /* Footer */
        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--modal-bg);
            backdrop-filter: blur(20px);
            padding: 12px;
            padding-bottom: max(12px, env(safe-area-inset-bottom));
            border-top: 0.5px solid rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 12px;
            z-index: 999;
        }

        .footer button {
            flex: 1;
            padding: 12px;
            font-size: 15px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.1s, opacity 0.2s;
        }

        .footer button:active {
            transform: scale(0.98);
            opacity: 0.8;
        }

        /* iOS Bottom Sheet Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.4);
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.25s ease;
        }

        .modal.active {
            display: block;
            opacity: 1;
        }

        .modal-content {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--modal-bg);
            border-radius: 20px 20px 0 0;
            padding: 0;
            max-height: 90vh;
            overflow-y: auto;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 -2px 20px var(--shadow);
            /* iOS Safari modal scroll fixes */
            -webkit-overflow-scrolling: touch; /* Smooth momentum scrolling on iOS */
            overscroll-behavior: contain; /* Prevent scroll chaining */
        }

        .modal.active .modal-content {
            transform: translateY(0);
        }

        .modal-drag-handle {
            width: 36px;
            height: 5px;
            background: rgba(60, 60, 67, 0.3);
            border-radius: 3px;
            margin: 8px auto 12px;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            letter-spacing: -0.4px;
            text-align: center;
            padding: 0 20px 20px;
            color: var(--text-primary);
            border-bottom: 0.5px solid rgba(0,0,0,0.1);
        }

        .modal-form {
            padding: 20px;
        }

        .modal-input, .modal-select {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 17px; /* Prevents iOS zoom on focus (must be ‚â•16px) */
            margin-bottom: 12px;
            font-family: inherit;
            background: var(--input-bg);
            color: var(--text-primary);
            box-shadow: 0 1px 3px var(--shadow);
            /* Mobile Safari input fixes */
            -webkit-appearance: none;
            -webkit-tap-highlight-color: transparent;
        }

        .modal-input:focus, .modal-select:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--ios-blue);
        }

        /* iOS-specific input type fixes */
        input[type="number"], input[type="text"], textarea {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        /* Prevent iOS Safari from adding default styling to buttons */
        input[type="submit"], input[type="button"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            padding: 0 20px 20px;
        }

        .modal-buttons button {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 12px;
            font-size: 17px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.1s;
        }

        .modal-buttons button:active {
            transform: scale(0.98);
            opacity: 0.8;
        }

        .modal-save {
            background: var(--ios-blue);
            color: white;
        }

        .modal-cancel {
            background: var(--bg-primary);
            color: var(--ios-blue);
            box-shadow: 0 1px 3px var(--shadow);
        }

        /* iOS Action Sheet */
        .action-sheet-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.25s ease;
        }

        .action-sheet-backdrop.active {
            display: block;
            opacity: 1;
        }

        .action-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: transparent;
            z-index: 3001;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 8px;
        }

        .action-sheet.active {
            transform: translateY(0);
        }

        .action-sheet-content {
            background: var(--modal-bg);
            backdrop-filter: blur(20px);
            border-radius: 14px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .action-sheet-message {
            padding: 20px;
            text-align: center;
            color: var(--ios-gray);
            font-size: 13px;
            border-bottom: 0.5px solid var(--border-color);
        }

        .action-sheet-button {
            width: 100%;
            padding: 16px;
            background: transparent;
            border: none;
            font-size: 20px;
            cursor: pointer;
            border-bottom: 0.5px solid var(--border-color);
            color: var(--ios-blue);
            transition: background 0.2s;
        }

        .action-sheet-button:last-child {
            border-bottom: none;
        }

        .action-sheet-button:active {
            background: rgba(0, 0, 0, 0.05);
        }

        .action-sheet-button.destructive {
            color: var(--ios-red);
            font-weight: 600;
        }

        .action-sheet-cancel {
            background: var(--modal-bg);
            backdrop-filter: blur(20px);
            border-radius: 14px;
            width: 100%;
            padding: 16px;
            border: none;
            font-size: 20px;
            font-weight: 600;
            color: var(--ios-blue);
            cursor: pointer;
            transition: background 0.2s;
        }

        .action-sheet-cancel:active {
            background: rgba(0, 0, 0, 0.05);
        }

        .history-section {
            margin-bottom: 16px;
        }

        .history-heading {
            font-size: 15px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .history-list {
            background: var(--bg-primary);
            border-radius: 12px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
            padding: 12px;
        }

        .history-item {
            padding: 10px 8px;
            border-bottom: 0.5px solid var(--border-color);
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-meta {
            font-size: 12px;
            color: var(--ios-gray);
            margin-top: 4px;
        }

        .pill {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            background: rgba(0, 122, 255, 0.1);
            color: var(--ios-blue);
            margin-right: 6px;
        }

        .pocket-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 4000;
        }

        .pocket-overlay.active {
            display: flex;
        }

        .pocket-pad {
            width: min(420px, 95vw);
            height: min(500px, 80vh);
            border-radius: 28px;
            background: var(--bg-primary);
            color: var(--ios-blue);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            font-size: 56px;
            font-weight: 800;
            box-shadow: 0 12px 40px rgba(0,0,0,0.35);
            text-align: center;
            padding: 20px;
        }

        .pocket-meta {
            color: #3a3a3c;
            font-size: 16px;
            font-weight: 600;
        }

        .pocket-close {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 44px;
            height: 44px;
            background: rgba(0,0,0,0.75);
            color: white;
            border: none;
            border-radius: 22px;
            font-size: 20px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4001;
        }

        .hidden {
            display: none !important;
        }

        /* Body Heatmap - REPLACED BY REHAB COVERAGE VIEW
        .body-diagram {
            position: relative;
            width: 200px;
            height: 380px;
            margin: 20px auto;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 380"><ellipse cx="100" cy="40" rx="25" ry="30" fill="%23e0e0e0"/><rect x="75" y="65" width="50" height="80" rx="10" fill="%23e0e0e0"/><rect x="45" y="70" width="30" height="60" rx="8" fill="%23e0e0e0"/><rect x="125" y="70" width="30" height="60" rx="8" fill="%23e0e0e0"/><rect x="70" y="145" width="60" height="40" rx="8" fill="%23e0e0e0"/><rect x="65" y="185" width="30" height="90" rx="8" fill="%23e0e0e0"/><rect x="105" y="185" width="30" height="90" rx="8" fill="%23e0e0e0"/><rect x="60" y="275" width="35" height="100" rx="8" fill="%23e0e0e0"/><rect x="105" y="275" width="35" height="100" rx="8" fill="%23e0e0e0"/></svg>') no-repeat center;
            background-size: contain;
        }

        .body-part-overlay {
            position: absolute;
            border-radius: 8px;
            transition: all 0.3s;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .heat-none { background: rgba(142, 142, 147, 0.2); }
        .heat-low { background: rgba(0, 122, 255, 0.4); }
        .heat-medium { background: rgba(255, 149, 0, 0.5); }
        .heat-high { background: rgba(255, 59, 48, 0.6); }
        .heat-very-high { background: rgba(255, 59, 48, 0.8); }

        .body-part-overlay:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .heatmap-legend {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin: 20px 0;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        */
    </style>
</head>
<body>
    <div class="header">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;">
            <div>
                <h1 style="margin: 0; display: inline;"><span style="display: inline-block; background: var(--ios-blue); color: white; padding: 4px 10px; border-radius: 6px; font-size: 20px; font-weight: 700; margin-right: 8px;">PT</span>Exercise Tracker</h1>
                <span style="font-size: 11px; color: var(--ios-gray); margin-left: 6px; vertical-align: super;" id="header-version">v1.4.0</span>
            </div>
            <div id="streak-display" style="font-size: 14px; font-weight: 600; color: var(--ios-orange);"></div>
        </div>
        <div style="display: flex; align-items: center; justify-content: space-between;">
            <div class="exercise-name" id="exercise-name" onclick="showQuickSwitcher()" style="cursor: pointer;">No Exercise Selected ‚ñæ</div>
            <div style="display: flex; gap: 4px;">
                <button onclick="showWeeklyStats()" style="background: transparent; border: none; font-size: 20px; cursor: pointer; padding: 4px 8px;">üìà</button>
                <button onclick="showExerciseDetailsModal()" style="background: transparent; border: none; font-size: 20px; cursor: pointer; padding: 4px 8px;">üìã</button>
                <button onclick="toggleHamburgerMenu()" style="background: transparent; border: none; font-size: 22px; cursor: pointer; padding: 4px 8px;">‚ò∞</button>
            </div>
        </div>
    </div>

    <!-- Hamburger Menu Overlay & Slide-out -->
    <div id="hamburger-overlay" onclick="toggleHamburgerMenu()" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 9998;"></div>
    <div id="hamburger-menu" style="display: none; position: fixed; top: 0; right: 0; bottom: 0; width: 280px; background: var(--bg-secondary); z-index: 9999; box-shadow: -2px 0 8px rgba(0, 0, 0, 0.3); overflow-y: auto;">
        <div style="padding: 20px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center;">
            <div style="font-size: 18px; font-weight: 600;">Menu</div>
            <button onclick="toggleHamburgerMenu()" style="background: transparent; border: none; color: var(--ios-blue); font-size: 16px; cursor: pointer; padding: 8px;">Close</button>
        </div>
        <div style="padding: 0;">
            <!-- Auth Status -->
            <div id="menu-auth-section">
                <!-- Signed In State -->
                <div id="menu-auth-signed-in" style="display: none;">
                    <div style="padding: 16px 20px; border-bottom: 1px solid var(--border-color); background: var(--bg-primary);">
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Signed in as</div>
                        <div id="menu-auth-email" style="font-size: 14px; font-weight: 500; color: var(--text-primary); margin-bottom: 12px; word-break: break-all;"></div>
                        <button id="menu-signout-btn" style="width: 100%; padding: 10px; background: var(--ios-red); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">Sign Out</button>
                    </div>
                </div>
                <!-- Signed Out State -->
                <div id="menu-auth-signed-out" style="display: none;">
                    <div style="padding: 16px 20px; border-bottom: 1px solid var(--border-color); background: var(--bg-primary);">
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Cloud sync disabled</div>
                        <button id="menu-signin-btn" style="width: 100%; padding: 10px; background: var(--ios-blue); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">Sign In</button>
                    </div>
                </div>
            </div>

            <div onclick="window.location.href='pt_report.html'" style="padding: 16px 20px; border-bottom: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px; width: 24px; text-align: center;">‚úèÔ∏è</span>
                <span>PT Editor Mode</span>
            </div>
            <div onclick="window.location.href='rehab_coverage.html'" style="padding: 16px 20px; border-bottom: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px; width: 24px; text-align: center;">üìä</span>
                <span>Coverage View</span>
            </div>
            <div onclick="showSettings(); toggleHamburgerMenu();" style="padding: 16px 20px; border-bottom: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px; width: 24px; text-align: center;">‚öôÔ∏è</span>
                <span>Settings</span>
            </div>
            <div onclick="exportForPT(); toggleHamburgerMenu();" style="padding: 16px 20px; border-bottom: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px; width: 24px; text-align: center;">üè•</span>
                <span>Export for PT</span>
            </div>
            <div onclick="importPTModifications(); toggleHamburgerMenu();" style="padding: 16px 20px; border-bottom: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px; width: 24px; text-align: center;">üì®</span>
                <span>Import PT Modifications</span>
            </div>
            <div onclick="showLibraryDiagnostics(); toggleHamburgerMenu();" style="padding: 16px 20px; border-bottom: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px; width: 24px; text-align: center;">üß™</span>
                <span>Library Debug</span>
            </div>
            <div onclick="location.reload()" style="padding: 16px 20px; cursor: pointer; display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px; width: 24px; text-align: center;">üîÑ</span>
                <span>Reload</span>
            </div>
        </div>
    </div>

    <!-- Library Debug Modal -->
    <div class="modal" id="library-debug-modal">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Library Debug</div>
            <div style="padding: 16px 20px 20px;">
                <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                    Snapshot of local + shared library sources to explain count differences.
                </div>
                <div id="library-debug-output" style="white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size: 12px; color: var(--text-primary); background: var(--bg-secondary); padding: 12px; border-radius: 10px;"></div>
                <button class="modal-cancel" style="margin-top: 16px; width: 100%;" onclick="closeLibraryDiagnostics()">Close</button>
            </div>
        </div>
    </div>

    <!-- Session Plan -->
    <div id="session-plan-container" style="padding: 12px 15px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); display: none;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
            <div style="font-size: 13px; font-weight: 600; color: var(--text-secondary);">Today's Session</div>
            <button onclick="endSessionEarly()" style="background: transparent; border: none; color: var(--ios-red); font-size: 12px; font-weight: 600; cursor: pointer; padding: 4px 8px;">End Session</button>
        </div>
        <div id="session-plan-list" style="display: flex; flex-direction: column; gap: 6px;"></div>
    </div>

    <!-- App Load Warning (shown if module script fails) -->
    <div id="app-load-warning" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.65); z-index: 5000; padding: 20px;">
        <div style="max-width: 420px; margin: 80px auto 0; background: var(--bg-primary); padding: 20px; border-radius: 16px; box-shadow: 0 12px 40px rgba(0,0,0,0.4); text-align: center;">
            <div style="font-size: 18px; font-weight: 700; margin-bottom: 8px;">App failed to load</div>
            <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 16px;">
                The tracker scripts didn‚Äôt initialize. Buttons may not work. Try reloading the page.
            </div>
            <button class="control-btn btn-primary" onclick="location.reload()">Reload</button>
        </div>
    </div>

    <!-- Counter View -->
    <div class="counter-view" id="counter-view">
        <div class="set-info" id="set-info">Tap "Exercises" below to choose</div>
        <div class="remaining-info" id="remaining-info"></div>

        <!-- Side Selector for Unilateral Exercises -->
        <div id="current-side-selector" style="display: none; margin: 16px 0; width: 100%; max-width: 400px;">
            <div style="font-size: 14px; font-weight: 600; margin-bottom: 10px; text-align: center; color: var(--text-secondary);">Working Side:</div>
            <div id="current-side-buttons" style="display: flex; gap: 10px;"></div>
        </div>

        <!-- Counter Mode -->
        <div id="counter-mode" class="hidden">
            <div class="counter-display" id="counter-display" onclick="incrementCounter()" aria-live="assertive">0</div>
            <div class="target-info" id="target-info">Target: 10 reps</div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
        </div>

        <!-- Timer Mode -->
        <div id="timer-mode" class="hidden">
            <div class="target-info" id="timer-rep-info">Rep 1 of 10</div>
            <div class="timer-display" id="timer-display">00:00</div>
            <div class="target-info" id="timer-target">Target: 10 seconds</div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="timer-progress-bar"></div>
            </div>
            <div class="controls" style="margin-bottom: 20px;">
                <button class="control-btn btn-primary" id="timer-start-btn" onclick="startTimer()">Start Timer</button>
                <button class="control-btn btn-danger hidden" id="timer-stop-btn" onclick="stopTimer()">Pause</button>
                <button class="control-btn btn-secondary hidden" id="timer-reset-btn" onclick="resetTimer()">Reset</button>
            </div>
            <!-- Log partial rep (only shown when paused) -->
            <div class="controls" id="timer-log-controls" style="margin-bottom: 10px; display: none;">
                <button class="control-btn btn-warning" onclick="logPartialTimerRep()" style="font-size: 13px; padding: 8px;">‚è±Ô∏è Log This Time & Next Rep</button>
            </div>
        </div>

        <div class="controls hidden" id="main-controls">
            <button class="control-btn btn-secondary" onclick="previousSet()">Previous</button>
            <button class="control-btn btn-primary" onclick="showLogSetModal()">Log Set</button>
            <button class="control-btn btn-success" onclick="completeSet()">Complete Set</button>
        </div>
    </div>

    <div class="footer">
        <button class="btn-secondary" onclick="showExerciseList()">Exercises</button>
        <button class="btn-secondary" onclick="showHistory()">History</button>
        <button class="btn-secondary" onclick="window.location.href='rehab_coverage.html'">Coverage</button>
        <button class="btn-secondary" onclick="togglePocketMode(true)">Pocket Tap</button>
    </div>

    <!-- Exercise Selection Modal -->
    <div class="modal" id="exercise-modal" onclick="if(event.target === this) closeExerciseModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Select Exercise</div>
            <div class="modal-form">
                <select class="modal-select" id="exercise-select" onchange="updateExerciseType()"></select>
                <select class="modal-select" id="exercise-type" onchange="updateTargetLabel()">
                    <option value="reps">Rep-based</option>
                    <option value="timed">Timed Reps</option>
                    <option value="hold">Hold</option>
                    <option value="duration">Duration</option>
                    <option value="amrap">AMRAP</option>
                    <option value="distance">Distance</option>
                </select>
                <input type="number" class="modal-input" id="sets-input" placeholder="Number of sets" value="3">
                <input type="number" class="modal-input" id="reps-input" placeholder="Reps per set" value="10">
                <input type="number" class="modal-input" id="target-input" placeholder="Target (seconds or distance)" value="10">
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeExerciseModal()">Cancel</button>
                <button class="modal-save" onclick="saveExercise()">Start</button>
            </div>
        </div>
    </div>

    <!-- Exercise List Modal -->
    <div class="modal" id="exercise-list-modal" onclick="if(event.target === this) closeExerciseList()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">My Exercises</div>

            <!-- Sticky Actions at Top -->
            <div style="padding: 12px 20px; border-bottom: 1px solid var(--border-color); background: var(--modal-bg);">
                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <button class="control-btn btn-primary" onclick="showPlanSessionModal()" style="flex: 1; font-size: 14px;">üìÖ Plan Session</button>
                    <button class="control-btn btn-primary" onclick="showLibraryBrowser()" style="flex: 1; font-size: 14px;">üìö Browse Library</button>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button class="control-btn btn-secondary" onclick="showArchivedExercises()" style="flex: 1; font-size: 13px;" id="archived-btn">üì¶ Archived</button>
                    <button class="control-btn btn-secondary" onclick="showDataBackup()" style="flex: 1; font-size: 13px;">üíæ Data</button>
                </div>
            </div>

            <!-- Scrollable Content -->
            <div class="modal-form" style="max-height: 60vh; overflow-y: auto;">
                <input type="text" class="modal-input" id="exercise-search" placeholder="Search exercises..." oninput="filterExercises()">
                <div id="tag-filter-container" style="margin-bottom: 12px;"></div>
                <div id="recent-exercises-container" style="margin-bottom: 12px;"></div>
                <div class="history-list" id="exercise-list-content"></div>
            </div>
        </div>
    </div>

    <!-- Form Parameters Modal (shown after completing all sets) -->
    <div class="modal" id="form-params-modal" onclick="if(event.target === this) closeFormParamsModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Exercise Parameters</div>
            <div class="modal-form">
                <div style="font-size: 15px; color: var(--ios-gray); margin-bottom: 16px; text-align: center;" id="form-params-subtitle">
                    Enter details for this session
                </div>
                <div id="form-params-fields"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="skipFormParams()">Skip</button>
                <button class="modal-save" onclick="saveFormParams()">Save & Continue</button>
            </div>
        </div>
    </div>

    <!-- Session Notes Modal -->
    <!-- Auth Modal -->
    <div class="modal" id="auth-modal" style="background: rgba(0,0,0,0.6);">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0 20px;">
                <div class="modal-title">Sign In to Sync</div>
                <button id="auth-skip-btn" style="background: transparent; border: none; color: var(--ios-blue); font-size: 16px; cursor: pointer; padding: 8px;">Skip</button>
            </div>
            <div class="modal-form">
                <div style="font-size: 15px; color: var(--ios-gray); margin-bottom: 16px; text-align: center;">
                    Sign in to sync your session data across devices
                </div>
                <input type="email" class="modal-input" id="auth-email" placeholder="Email" autocomplete="email">
                <input type="password" class="modal-input" id="auth-password" placeholder="Password" autocomplete="current-password">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; padding: 0 4px;">
                    <input type="checkbox" id="auth-remember" style="width: 20px; height: 20px; cursor: pointer;">
                    <label for="auth-remember" style="font-size: 15px; color: var(--text-secondary); cursor: pointer;">Remember me</label>
                </div>
                <div id="auth-error" style="display: none; color: var(--ios-red); font-size: 14px; margin-bottom: 12px; text-align: center;"></div>
                <div style="text-align: center; margin-bottom: 12px;">
                    <a href="#" id="auth-forgot-password" style="color: var(--ios-blue); font-size: 14px; text-decoration: none;">Forgot Password?</a>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" id="auth-signup-btn">Sign Up</button>
                <button class="modal-save" id="auth-signin-btn">Sign In</button>
            </div>
        </div>
    </div>

    <div class="modal" id="session-notes-modal" onclick="if(event.target === this) closeSessionNotesModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Session Notes (Optional)</div>
            <div class="modal-form">
                <textarea class="modal-input" id="session-notes" placeholder="How did it feel? Any pain? Progress notes..." style="min-height: 100px; resize: vertical;"></textarea>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="confirmSkipNotes()">Skip Notes</button>
                <button class="modal-save" onclick="saveSessionWithNotes(document.getElementById('session-notes').value)">Save & Finish</button>
            </div>
        </div>
    </div>

    <!-- Log Set Modal -->
    <div class="modal" id="log-set-modal" onclick="if(event.target === this) closeLogSetModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title" id="log-set-title">Log Set</div>
            <div class="modal-form">
                <div style="font-size: 15px; color: var(--ios-gray); margin-bottom: 12px; text-align: center;" id="log-set-subtitle">
                    Enter actual reps performed
                </div>
                <input type="number" class="modal-input" id="log-set-reps" placeholder="Reps performed" min="0">
                <input type="number" class="modal-input" id="log-set-distance" placeholder="Distance (feet)" min="0" step="1" style="display: none;">
                <div id="log-set-side-selector" style="margin: 12px 0;"></div>

                <!-- Dynamic Form Parameters -->
                <div id="log-set-form-params" style="background: rgba(0,122,255,0.05); padding: 12px; border-radius: 8px; margin: 12px 0; display: none;">
                    <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px;">Form Parameters:</div>
                    <div id="log-set-form-params-fields"></div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeLogSetModal()">Cancel</button>
                <button class="modal-save" onclick="saveLoggedSet()">Save</button>
            </div>
        </div>
    </div>

    <!-- Exercise Details Modal -->
    <div class="modal" id="exercise-details-modal" onclick="if(event.target === this) closeExerciseDetailsModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title" id="exercise-details-title">Exercise Details</div>
            <div class="modal-form" style="max-height: 500px; overflow-y: auto;">
                <!-- Professional Guidance Section (for imported exercises) -->
                <div id="professional-guidance-section" style="display: none; margin-bottom: 16px;">
                    <div style="background: rgba(0,122,255,0.05); padding: 12px; border-radius: 8px; margin-bottom: 12px;">
                        <div style="font-weight: 600; font-size: 14px; margin-bottom: 8px; color: var(--ios-blue);">
                            üìö Professional Guidance
                        </div>
                        <div id="professional-guidance-content"></div>
                    </div>
                    <hr style="border: none; border-top: 1px solid rgba(0,0,0,0.1); margin: 16px 0;">
                </div>

                <!-- User's Personal Notes -->
                <div style="font-size: 13px; color: var(--ios-gray); margin-bottom: 8px;">Your Personal Notes:</div>
                <textarea class="modal-input" id="exercise-description" placeholder="Description (what is this exercise?)" style="min-height: 60px; resize: vertical;"></textarea>
                <textarea class="modal-input" id="exercise-tips" placeholder="Execution tips (form, alignment, cues)" style="min-height: 80px; resize: vertical;"></textarea>
                <textarea class="modal-input" id="exercise-feel" placeholder="Where to feel (target muscles)" style="min-height: 50px; resize: vertical;"></textarea>
                <textarea class="modal-input" id="exercise-not-feel" placeholder="Where NOT to feel (avoid strain)" style="min-height: 50px; resize: vertical;"></textarea>
                <textarea class="modal-input" id="exercise-modifications" placeholder="Modifications (easier/harder variations)" style="min-height: 60px; resize: vertical;"></textarea>
                <input type="number" class="modal-input" id="exercise-rest-seconds" placeholder="Rest between sets (seconds, optional)" min="0">
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeExerciseDetailsModal()">Cancel</button>
                <button class="modal-save" onclick="saveExerciseDetails()">Save</button>
            </div>
        </div>
    </div>

    <!-- Rest Timer Modal -->
    <div class="modal" id="rest-timer-modal">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Rest Timer</div>
            <div class="modal-form">
                <div style="text-align: center; font-size: 48px; font-weight: 700; color: var(--ios-blue); margin: 20px 0;" id="rest-countdown">60</div>
                <div style="text-align: center; font-size: 15px; color: var(--ios-gray); margin-bottom: 20px;">Rest between sets</div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="rest-progress-bar"></div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="skipRest()">Skip Rest</button>
                <button class="modal-save" onclick="closeRestTimer()">Continue</button>
            </div>
        </div>
    </div>

    <!-- Quick Exercise Switcher Modal -->
    <div class="modal" id="quick-switcher-modal" onclick="if(event.target === this) closeQuickSwitcher()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Switch Exercise</div>
            <div class="modal-form">
                <div style="font-size: 13px; color: var(--ios-gray); margin-bottom: 12px; text-align: center;">Tap to switch (current progress will be saved)</div>
                <div class="history-list" id="quick-switcher-list"></div>
            </div>
        </div>
    </div>

    <!-- History Modal -->
    <div class="modal" id="history-modal" onclick="if(event.target === this) closeHistoryModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">History</div>
            <div class="modal-form">
                <div class="history-section">
                    <div class="history-heading">Exercise revisions</div>
                    <div class="history-list" id="exercise-history-list"></div>
                </div>
                <div class="history-section">
                    <div class="history-heading">Recent sessions</div>
                    <div class="history-list" id="session-history-list"></div>
                </div>
                <div style="display: flex; gap: 8px; margin-top: 12px;">
                    <button class="control-btn btn-secondary" onclick="exportWeeklySummary()" style="flex: 1;">üìà 7-Day Summary</button>
                    <button class="control-btn btn-primary" onclick="exportForPT()" style="flex: 1;">Full Report</button>
                    <button class="control-btn btn-secondary" onclick="reloadApp()" style="flex: 1;">Reload app (use after updates)</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Session Modal -->
    <div class="modal" id="edit-session-modal" onclick="if(event.target === this) closeEditSession()">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Edit Session</div>
            <div class="modal-form" style="max-height: 70vh; overflow-y: auto;">
                <!-- Session Date -->
                <div style="margin-bottom: 20px;">
                    <label style="font-weight: 600; margin-bottom: 8px; display: block;">Session Date & Time</label>
                    <input type="datetime-local" class="modal-input" id="edit-session-date">
                </div>

                <!-- Exercise Info (Read-only) -->
                <div style="margin-bottom: 20px; padding: 12px; background: rgba(0,122,255,0.05); border-radius: 8px;">
                    <div style="font-weight: 600; margin-bottom: 4px;" id="edit-session-exercise-name"></div>
                    <div style="font-size: 12px; color: var(--ios-gray);" id="edit-session-exercise-pattern"></div>
                </div>

                <!-- Sets -->
                <div style="margin-bottom: 20px;">
                    <label style="font-weight: 600; margin-bottom: 8px; display: block;">Sets</label>
                    <div id="edit-session-sets-container"></div>
                    <button type="button" class="modal-cancel" onclick="addSetToEditSession()" style="margin-top: 8px; font-size: 13px; padding: 6px 12px;">+ Add Set</button>
                </div>

                <!-- Notes -->
                <div style="margin-bottom: 20px;">
                    <label style="font-weight: 600; margin-bottom: 8px; display: block;">Notes</label>
                    <textarea class="modal-input" id="edit-session-notes" placeholder="Session notes..." style="min-height: 60px; resize: vertical;"></textarea>
                </div>

                <!-- Delete Section -->
                <div style="padding-top: 12px; border-top: 1px solid var(--border-color);">
                    <button type="button" class="modal-cancel" onclick="deleteSession()" style="background: var(--ios-red); color: white; width: 100%;">üóë Delete Session</button>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeEditSession()">Cancel</button>
                <button class="modal-save" onclick="saveEditedSession()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Body Heatmap Modal - REPLACED BY REHAB COVERAGE VIEW
    <div class="modal" id="body-heatmap-modal" onclick="if(event.target === this) closeBodyHeatmap()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Body Parts Worked (Last 7 Days)</div>
            <div class="modal-form">
                <div style="font-size: 13px; color: var(--ios-gray); text-align: center; margin-bottom: 12px;">
                    Tap body parts to see exercises
                </div>
                <div class="body-diagram" id="body-diagram"></div>
                <div class="heatmap-legend">
                    <div class="legend-item">
                        <div class="legend-color heat-none"></div>
                        <span>None</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color heat-low"></div>
                        <span>1-2√ó</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color heat-medium"></div>
                        <span>3-4√ó</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color heat-high"></div>
                        <span>5+√ó</span>
                    </div>
                </div>
                <div id="body-part-details" style="margin-top: 12px;"></div>
            </div>
        </div>
    </div>
    -->

    <!-- All Sessions Modal (grouped by workout session) -->
    <div class="modal" id="all-sessions-modal" onclick="if(event.target === this) closeAllSessions()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Complete Workout Sessions</div>
            <div class="modal-form" style="max-height: 500px; overflow-y: auto;">
                <div style="font-size: 13px; color: var(--ios-gray); margin-bottom: 12px; text-align: center;">
                    All exercises grouped by workout session
                </div>
                <div id="all-sessions-list"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeAllSessions()">Close</button>
            </div>
        </div>
    </div>

    <!-- Weekly Stats Modal -->
    <div class="modal" id="weekly-stats-modal" onclick="if(event.target === this) closeWeeklyStats()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Weekly Stats</div>
            <div class="modal-form" style="max-height: 500px; overflow-y: auto;">
                <div id="weekly-overview"></div>
                <div id="weekly-volume-chart"></div>
                <div id="weekly-exercises"></div>
                <div id="weekly-adherence"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeWeeklyStats()">Close</button>
                <button class="modal-save" onclick="showAllSessions()">View All Sessions</button>
            </div>
        </div>
    </div>

    <!-- Exercise Progress Modal -->
    <div class="modal" id="exercise-progress-modal" onclick="if(event.target === this) closeExerciseProgress()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title" id="progress-modal-title">Exercise Progress</div>
            <div class="modal-form" style="max-height: 500px; overflow-y: auto;">
                <div id="progress-summary" style="margin-bottom: 16px;"></div>
                <div id="progress-chart" style="margin-bottom: 16px;"></div>
                <div id="progress-sessions" style="margin-bottom: 16px;"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeExerciseProgress()">Close</button>
            </div>
        </div>
    </div>

    <!-- Exercise Library Browser Modal -->
    <div class="modal" id="library-browser-modal" onclick="if(event.target === this) closeLibraryBrowser()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Exercise Library</div>
            <div class="modal-form">
                <div style="font-size: 13px; color: var(--ios-gray); text-align: center; margin-bottom: 12px;">
                    Professional PT exercises with detailed guidance
                </div>
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; padding: 8px 12px; background: rgba(0,122,255,0.05); border-radius: 8px;">
                    <label style="font-size: 14px; font-weight: 500; cursor: pointer;" for="show-new-toggle">
                        Show only new
                    </label>
                    <input type="checkbox" id="show-new-toggle" checked onchange="toggleShowOnlyNew()" style="width: 20px; height: 20px; cursor: pointer;">
                </div>
                <input type="text" class="modal-input" id="library-search" placeholder="Search exercises..." oninput="filterLibraryExercises()">
                <div class="history-list" id="library-exercises-list" style="max-height: 400px; overflow-y: auto;"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeLibraryBrowser()">Close</button>
                <button class="modal-save" id="bulk-import-btn" onclick="bulkImportExercises()" style="display: none;">Import Selected</button>
            </div>
        </div>
    </div>

    <!-- Exercise Detail View Modal -->
    <div class="modal" id="exercise-detail-modal" onclick="if(event.target === this) closeExerciseDetail()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title" id="exercise-detail-title">Exercise Details</div>
            <div class="modal-form">
                <div id="exercise-detail-content" style="max-height: 500px; overflow-y: auto;"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeExerciseDetail()">Back</button>
                <button class="modal-save" id="import-exercise-btn" onclick="importLibraryExercise()">Import to My Exercises</button>
            </div>
        </div>
    </div>

    <!-- Data / Backup Modal -->
    <div class="modal" id="data-backup-modal" onclick="if(event.target === this) closeDataBackup()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Data / Backup</div>
            <div class="modal-form">
                <div style="font-size: 13px; color: var(--ios-gray); margin-bottom: 16px;">Export your data to save a backup or commit to GitHub.</div>
                <button class="control-btn btn-primary" onclick="exportAllData()" style="width: 100%; margin-bottom: 12px; font-weight: 600;">üíæ Export All Data</button>
                <div style="font-size: 12px; color: var(--ios-gray); margin: -8px 0 16px 0; text-align: center;">Single file with library, history, and version</div>
                <button class="control-btn btn-secondary" onclick="exportExerciseLibrary()" style="width: 100%; margin-bottom: 12px;">üìö Export Exercise Library</button>
                <button class="control-btn btn-secondary" onclick="exportExerciseHistory()" style="width: 100%; margin-bottom: 20px;">üìä Export Exercise History</button>

                <div style="border-top: 1px solid var(--ios-separator); padding-top: 16px; margin-top: 4px;">
                    <div style="font-size: 13px; color: var(--ios-gray); margin-bottom: 12px;">Restore from backup file</div>
                    <input type="file" id="import-file-input" accept=".json" style="display: none;" onchange="handleImportFile(event)">
                    <button class="control-btn btn-secondary" onclick="document.getElementById('import-file-input').click()" style="width: 100%; margin-bottom: 12px;">üì• Import Data</button>
                </div>

                <div style="border-top: 1px solid var(--ios-separator); padding-top: 16px; margin-top: 4px;">
                    <div style="font-size: 13px; color: var(--ios-gray); margin-bottom: 12px;">Advanced: Schema-driven exercise editor</div>
                    <button class="control-btn btn-primary" onclick="window.open('./exercise_editor.html', '_blank')" style="width: 100%;">üõ†Ô∏è Open Exercise Editor</button>
                    <div style="font-size: 11px; color: var(--ios-gray); margin-top: 8px; text-align: center;">Create/edit exercises with full schema validation</div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeDataBackup()">Close</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settings-modal" onclick="if(event.target === this) closeSettings()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">‚öôÔ∏è Settings</div>
            <div class="modal-form" style="max-height: 600px; overflow-y: auto;">

                <!-- Data & Backup Section -->
                <div style="margin-bottom: 24px;">
                    <div style="font-size: 13px; font-weight: 700; color: var(--text-secondary); margin-bottom: 12px; padding-left: 8px;">üìä DATA & BACKUP</div>
                    <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden;">
                        <button onclick="exportAllData()" style="width: 100%; padding: 10px 12px; border: none; background: transparent; text-align: left; border-bottom: 1px solid var(--border-color); cursor: pointer; font-size: 15px; color: var(--text-primary);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span>üíæ Export All Data</span>
                                <span style="color: var(--ios-gray); font-size: 14px;">‚Ä∫</span>
                            </div>
                            <div style="font-size: 12px; color: var(--ios-gray); margin-top: 2px;">Library + history + version</div>
                        </button>
                        <button onclick="exportExerciseLibrary()" style="width: 100%; padding: 10px 12px; border: none; background: transparent; text-align: left; border-bottom: 1px solid var(--border-color); cursor: pointer; font-size: 15px; color: var(--text-primary);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span>üìö Export Library Only</span>
                                <span style="color: var(--ios-gray); font-size: 14px;">‚Ä∫</span>
                            </div>
                        </button>
                        <button onclick="exportExerciseHistory()" style="width: 100%; padding: 10px 12px; border: none; background: transparent; text-align: left; border-bottom: 1px solid var(--border-color); cursor: pointer; font-size: 15px; color: var(--text-primary);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span>üìä Export History Only</span>
                                <span style="color: var(--ios-gray); font-size: 14px;">‚Ä∫</span>
                            </div>
                        </button>
                        <button onclick="document.getElementById('import-file-input').click()" style="width: 100%; padding: 10px 12px; border: none; background: transparent; text-align: left; cursor: pointer; font-size: 15px; color: var(--text-primary);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span>üì• Import Data</span>
                                <span style="color: var(--ios-gray); font-size: 14px;">‚Ä∫</span>
                            </div>
                            <div style="font-size: 12px; color: var(--ios-gray); margin-top: 2px;">Restore from backup</div>
                        </button>
                    </div>
                </div>

                <!-- Exercise Library Section -->
                <div style="margin-bottom: 24px;">
                    <div style="font-size: 13px; font-weight: 700; color: var(--text-secondary); margin-bottom: 12px; padding-left: 8px;">üí™ EXERCISE LIBRARY</div>
                    <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden;">
                        <button onclick="closeSettings(); showLibraryBrowser();" style="width: 100%; padding: 10px 12px; border: none; background: transparent; text-align: left; border-bottom: 1px solid var(--border-color); cursor: pointer; font-size: 15px; color: var(--text-primary);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span>üìö Browse Library</span>
                                <span style="color: var(--ios-gray); font-size: 14px;">‚Ä∫</span>
                            </div>
                            <div style="font-size: 12px; color: var(--ios-gray); margin-top: 2px;">Professional PT exercises</div>
                        </button>
                        <button onclick="window.open('./exercise_editor.html', '_blank')" style="width: 100%; padding: 10px 12px; border: none; background: transparent; text-align: left; cursor: pointer; font-size: 15px; color: var(--text-primary);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span>üõ†Ô∏è Exercise Editor</span>
                                <span style="color: var(--ios-gray); font-size: 14px;">‚Üó</span>
                            </div>
                            <div style="font-size: 12px; color: var(--ios-gray); margin-top: 2px;">Create custom exercises</div>
                        </button>
                    </div>
                </div>

                <!-- Tracking Preferences Section -->
                <div style="margin-bottom: 24px;">
                    <div style="font-size: 13px; font-weight: 700; color: var(--text-secondary); margin-bottom: 12px; padding-left: 8px;">üéØ TRACKING PREFERENCES</div>
                    <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden;">
                        <div style="padding: 10px 12px; border-bottom: 1px solid var(--border-color);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div>
                                    <div style="font-size: 15px; color: var(--text-primary);">Haptic Feedback</div>
                                    <div style="font-size: 11px; color: var(--ios-gray); margin-top: 2px;">Vibration on actions</div>
                                </div>
                                <input type="checkbox" id="haptic-toggle" checked onchange="toggleHaptic()" style="width: 42px; height: 24px; cursor: pointer;">
                            </div>
                        </div>
                        <div style="padding: 10px 12px;">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div>
                                    <div style="font-size: 15px; color: var(--text-primary);">Voice Announcements</div>
                                    <div style="font-size: 11px; color: var(--ios-gray); margin-top: 2px;">Speak progress updates</div>
                                </div>
                                <input type="checkbox" id="voice-toggle" checked onchange="toggleVoice()" style="width: 42px; height: 24px; cursor: pointer;">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- App Management Section -->
                <div style="margin-bottom: 24px;">
                    <div style="font-size: 13px; font-weight: 700; color: var(--text-secondary); margin-bottom: 12px; padding-left: 8px;">üì± APP MANAGEMENT</div>
                    <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden;">
                        <div style="padding: 10px 12px; border-bottom: 1px solid var(--border-color);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span style="font-size: 15px; color: var(--text-primary);">App Version</span>
                                <span style="color: var(--ios-gray); font-size: 13px;" id="app-version-display">v1.4.0</span>
                            </div>
                        </div>
                        <button onclick="reloadApp()" style="width: 100%; padding: 10px 12px; border: none; background: transparent; text-align: left; cursor: pointer; font-size: 15px; color: var(--text-primary);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span>üîÑ Reload App</span>
                                <span style="color: var(--ios-gray); font-size: 14px;">‚Ä∫</span>
                            </div>
                            <div style="font-size: 12px; color: var(--ios-gray); margin-top: 2px;">Check for updates</div>
                        </button>
                    </div>
                </div>

                <!-- About Section -->
                <div style="margin-bottom: 24px;">
                    <div style="font-size: 13px; font-weight: 700; color: var(--text-secondary); margin-bottom: 12px; padding-left: 8px;">‚ÑπÔ∏è ABOUT</div>
                    <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden;">
                        <div style="padding: 14px 16px;">
                            <div style="font-size: 14px; color: var(--ios-gray); line-height: 1.6;">
                                All data stored locally on your device. No cloud sync. Export regularly to back up your progress.
                            </div>
                        </div>
                    </div>
                </div>

            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeSettings()">Close</button>
            </div>
        </div>
    </div>

    <!-- Dosage Prompt Modal -->
    <div class="modal" id="dosage-prompt-modal" onclick="if(event.target === this) closeDosagePrompt()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">üíä Set Initial Dosage</div>
            <div class="modal-form">
                <div style="font-size: 15px; color: var(--text-primary); margin-bottom: 20px; text-align: center; font-weight: 600;" id="dosage-exercise-name"></div>
                <div style="font-size: 14px; color: var(--ios-gray); margin-bottom: 24px; text-align: center;">What did your PT prescribe?</div>

                <div style="margin-bottom: 16px;">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px;">Sets</label>
                    <input type="number" id="dosage-sets" class="modal-input" placeholder="e.g., 3" min="1" style="font-size: 20px; text-align: center; font-weight: 600;">
                </div>

                <div style="margin-bottom: 16px;" id="dosage-reps-container">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px;">Reps (per set)</label>
                    <input type="number" id="dosage-reps" class="modal-input" placeholder="e.g., 10" min="1" style="font-size: 20px; text-align: center; font-weight: 600;">
                </div>

                <div id="dosage-seconds-container" style="margin-bottom: 16px; display: none;">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px;" id="dosage-seconds-label">Seconds (per rep)</label>
                    <input type="number" id="dosage-seconds" class="modal-input" placeholder="e.g., 30" min="1" style="font-size: 20px; text-align: center; font-weight: 600;">
                    <div style="font-size: 12px; color: var(--ios-gray); margin-top: 4px; text-align: center;">Hold exercises typically 20-30s</div>
                </div>

                <div id="dosage-distance-container" style="margin-bottom: 16px; display: none;">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px;">Distance (feet)</label>
                    <input type="number" id="dosage-distance" class="modal-input" placeholder="e.g., 100" min="1" style="font-size: 20px; text-align: center; font-weight: 600;">
                    <div style="font-size: 12px; color: var(--ios-gray); margin-top: 4px; text-align: center;">Distance to walk/move</div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeDosagePrompt()">Cancel</button>
                <button class="modal-save" onclick="confirmDosage()">Add to My Program</button>
            </div>
        </div>
    </div>

    <!-- Edit Dosage Modal -->
    <div class="modal" id="edit-dosage-modal" onclick="if(event.target === this) closeEditDosage()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">‚úèÔ∏è Edit Dosage</div>
            <div class="modal-form">
                <div style="font-size: 15px; color: var(--text-primary); margin-bottom: 20px; text-align: center; font-weight: 600;" id="edit-dosage-exercise-name"></div>

                <div style="margin-bottom: 16px;">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px;">Sets</label>
                    <input type="number" id="edit-dosage-sets" class="modal-input" placeholder="e.g., 3" min="1" style="font-size: 20px; text-align: center; font-weight: 600;">
                </div>

                <div style="margin-bottom: 16px;" id="edit-dosage-reps-container">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px;">Reps (per set)</label>
                    <input type="number" id="edit-dosage-reps" class="modal-input" placeholder="e.g., 10" min="1" style="font-size: 20px; text-align: center; font-weight: 600;">
                </div>

                <div id="edit-dosage-seconds-container" style="margin-bottom: 16px; display: none;">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px;" id="edit-dosage-seconds-label">Seconds (per rep)</label>
                    <input type="number" id="edit-dosage-seconds" class="modal-input" placeholder="e.g., 30" min="1" style="font-size: 20px; text-align: center; font-weight: 600;">
                </div>

                <div id="edit-dosage-distance-container" style="margin-bottom: 16px; display: none;">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px;">Distance (feet)</label>
                    <input type="number" id="edit-dosage-distance" class="modal-input" placeholder="e.g., 100" min="1" style="font-size: 20px; text-align: center; font-weight: 600;">
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeEditDosage()">Cancel</button>
                <button class="modal-save" onclick="saveEditedDosage()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Plan Session Modal -->
    <div class="modal" id="plan-session-modal" onclick="if(event.target === this) closePlanSessionModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Plan Today's Session</div>
            <div class="modal-form">
                <div style="font-size: 13px; color: var(--ios-gray); margin-bottom: 12px;">Select exercises for today's workout. Tap to add/remove.</div>
                <div id="plan-session-list" class="history-list" style="max-height: 400px; overflow-y: auto;"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closePlanSessionModal()">Cancel</button>
                <button class="modal-save" id="start-session-btn" onclick="startPlannedSession()">Start Session</button>
            </div>
        </div>
    </div>

    <!-- iOS Action Sheet -->
    <div class="action-sheet-backdrop" id="action-sheet-backdrop" onclick="hideActionSheet()"></div>
    <div class="action-sheet" id="action-sheet">
        <div class="action-sheet-content">
            <div class="action-sheet-message" id="action-sheet-message"></div>
            <button class="action-sheet-button destructive" id="action-sheet-confirm" onclick="confirmActionSheet()">Confirm</button>
        </div>
        <button class="action-sheet-cancel" onclick="hideActionSheet()">Cancel</button>
    </div>

    <!-- Export for PT Modal (Email) -->
    <div class="modal" id="export-pt-modal" onclick="if(event.target === this) closeExportPTModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">üì§ Send to PT</div>
            <div class="modal-form">
                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px; line-height: 1.5;">
                    Enter your PT's email address (optional). You can copy the payload only or open your email client with the payload ready to send.
                </div>
                <input type="email" class="modal-input" id="pt-email-address" placeholder="your.pt@example.com" style="margin-bottom: 12px;">
                <textarea class="modal-input" id="pt-note" placeholder="Optional: Add a note for your PT" style="min-height: 80px; resize: vertical;"></textarea>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeExportPTModal()">Cancel</button>
                <button class="modal-save" onclick="copyPtPayloadOnly()">üìã Copy Payload Only</button>
                <button class="modal-save" onclick="sendToPT()">üìß Send Email</button>
            </div>
        </div>
    </div>

    <!-- Import PT Modifications Modal (Paste) -->
    <div class="modal" id="import-pt-modal" onclick="if(event.target === this) closeImportPTModal()">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">üì® Import from PT</div>
            <div class="modal-form" style="max-height: 60vh;">
                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px; line-height: 1.5;">
                    Paste the text from your PT's email below. The app will automatically extract and import the data.
                </div>
                <textarea id="import-pt-content" placeholder="Paste the entire email content here (including markers)..." style="
                    width: 100%;
                    min-height: 300px;
                    padding: 12px;
                    font-family: 'Courier New', monospace;
                    font-size: 11px;
                    background: var(--bg-tertiary);
                    border: 1px solid var(--border-color);
                    border-radius: 8px;
                    resize: vertical;
                    color: var(--text-primary);
                "></textarea>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeImportPTModal()">Cancel</button>
                <button class="modal-save" onclick="processPastedImport()">Import</button>
            </div>
        </div>
    </div>

    <!-- Eyes-free pocket tap overlay -->
    <div class="pocket-overlay" id="pocket-overlay" onclick="handlePocketTap()" aria-live="assertive">
        <button class="pocket-close" onclick="togglePocketMode(false); event.stopPropagation();" aria-label="Exit Pocket Mode">‚úï</button>
        <div class="pocket-pad" role="button" aria-label="Pocket tap target">
            <div id="pocket-label">Tap to count</div>
            <div class="pocket-meta" id="pocket-meta">Reps left ¬∑ Sets left</div>
        </div>
    </div>

    <script src="pt_payload_utils.js"></script>
    <script>
        // Guard: show a warning if the module script fails to initialize.
        window.appBooted = false;
        window.addEventListener('load', () => {
            setTimeout(() => {
                if (!window.appBooted) {
                    const warning = document.getElementById('app-load-warning');
                    if (warning) warning.style.display = 'block';
                }
            }, 1500);
        });
    </script>
    <script type="module" src="firebase.js"></script>
    <script type="module">
        import { db } from './firebase.js';
        import {
            auth,
            signInWithEmailAndPassword,
            createUserWithEmailAndPassword,
            signOut,
            onAuthStateChanged,
            setPersistence,
            browserLocalPersistence,
            browserSessionPersistence
        } from './firebase.js';
        import { sendPasswordResetEmail } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";
        import { ulid } from "https://cdn.jsdelivr.net/npm/ulid@2.3.0/dist/index.esm.js";
        import {
            loadExerciseLibraryShared,
            loadExerciseRolesShared,
            loadExerciseVocabularyShared,
            loadExerciseFileSchemaShared,
            loadExerciseRolesSchemaShared,
            saveExerciseRolesShared,
            saveExerciseVocabularyShared,
            saveExerciseLibraryShared
        } from './shared/firestore_shared_data.js';
        import {
            addDoc,
            collection,
            deleteDoc,
            doc,
            getDoc,
            getDocs,
            onSnapshot,
            query,
            setDoc,
            updateDoc,
            where
        } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

        const STORAGE_KEY = 'pt_tracker_data';
        const LIBRARY_KEY = 'pt_exercise_library';
        const ROLES_DATA_KEY = 'pt_exercise_roles';
        const VOCABULARY_KEY = 'pt_exercise_vocabulary';
        const LAST_EXERCISE_KEY = 'pt_last_exercise_id';
        const FIRESTORE_QUEUE_KEY = 'pt_firestore_queue';
        const RECOVERY_STORAGE_KEY = 'pt_session_recovery';
        const PREFERENCES_STORAGE_KEY = 'pt_preferences';
        const RUNTIME_UPDATED_KEY = 'pt_runtime_updated_at';
        const LEGACY_HISTORY_MIGRATION_KEY = 'pt_tracker_history_migrated';
        const APP_VERSION = 'v1.5.9'; // Updated: 2025-12-27 - Equipment editing with dynamic library and add-new capability
        const PT_VERSION_KEY = 'pt_data_version';
        const PT_DATA_VERSION = '1';

        // Auth state
        let currentUser = null;
        let isAuthReady = false;

        // Auth UI functions
        function showAuthModal() {
            const modal = document.getElementById('auth-modal');
            modal.classList.add('active');
            document.getElementById('auth-email').focus();
        }

        function hideAuthModal() {
            const modal = document.getElementById('auth-modal');
            modal.classList.remove('active');
            document.getElementById('auth-error').style.display = 'none';
            document.getElementById('auth-email').value = '';
            document.getElementById('auth-password').value = '';
        }

        function showAuthError(message) {
            const errorDiv = document.getElementById('auth-error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function updateMenuAuthDisplay() {
            const signedInSection = document.getElementById('menu-auth-signed-in');
            const signedOutSection = document.getElementById('menu-auth-signed-out');
            const emailDisplay = document.getElementById('menu-auth-email');

            if (currentUser) {
                // Show signed in state
                signedInSection.style.display = 'block';
                signedOutSection.style.display = 'none';
                emailDisplay.textContent = currentUser.email;
            } else {
                // Show signed out state
                signedInSection.style.display = 'none';
                signedOutSection.style.display = 'block';
            }
        }

        async function handleMenuSignOut() {
            try {
                await signOut(auth);
                console.log('[Auth] Signed out successfully');
                // Close menu
                const toggleMenu = window.toggleHamburgerMenu;
                if (toggleMenu) toggleMenu();
            } catch (error) {
                console.error('[Auth] Sign out error:', error);
                alert('Failed to sign out. Please try again.');
            }
        }

        function handleMenuSignIn() {
            showAuthModal();
            // Close menu
            const toggleMenu = window.toggleHamburgerMenu;
            if (toggleMenu) toggleMenu();
        }

        async function handleSignIn() {
            const email = document.getElementById('auth-email').value.trim();
            const password = document.getElementById('auth-password').value;
            const rememberMe = document.getElementById('auth-remember').checked;

            if (!email || !password) {
                showAuthError('Please enter email and password');
                return;
            }

            try {
                // Set persistence based on remember me
                const persistence = rememberMe ? browserLocalPersistence : browserSessionPersistence;
                await setPersistence(auth, persistence);

                // Sign in
                await signInWithEmailAndPassword(auth, email, password);
                hideAuthModal();
                console.log('[Auth] Signed in successfully');
            } catch (error) {
                console.error('[Auth] Sign in error:', error);
                if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password') {
                    showAuthError('Invalid email or password');
                } else if (error.code === 'auth/invalid-email') {
                    showAuthError('Invalid email address');
                } else if (error.code === 'auth/too-many-requests') {
                    showAuthError('Too many attempts. Try again later');
                } else {
                    showAuthError('Sign in failed. Please try again');
                }
            }
        }

        async function handleSignUp() {
            const email = document.getElementById('auth-email').value.trim();
            const password = document.getElementById('auth-password').value;
            const rememberMe = document.getElementById('auth-remember').checked;

            if (!email || !password) {
                showAuthError('Please enter email and password');
                return;
            }

            if (password.length < 6) {
                showAuthError('Password must be at least 6 characters');
                return;
            }

            try {
                // Set persistence based on remember me
                const persistence = rememberMe ? browserLocalPersistence : browserSessionPersistence;
                await setPersistence(auth, persistence);

                // Create account
                await createUserWithEmailAndPassword(auth, email, password);
                hideAuthModal();
                console.log('[Auth] Account created successfully');
            } catch (error) {
                console.error('[Auth] Sign up error:', error);
                if (error.code === 'auth/email-already-in-use') {
                    showAuthError('Email already in use. Try signing in instead');
                } else if (error.code === 'auth/invalid-email') {
                    showAuthError('Invalid email address');
                } else if (error.code === 'auth/weak-password') {
                    showAuthError('Password is too weak');
                } else {
                    showAuthError('Sign up failed. Please try again');
                }
            }
        }

        async function handleForgotPassword(e) {
            e.preventDefault();
            const email = document.getElementById('auth-email').value.trim();

            if (!email) {
                showAuthError('Please enter your email address first');
                return;
            }

            try {
                await sendPasswordResetEmail(auth, email);
                showAuthError(''); // Clear error
                alert(`Password reset email sent to ${email}.\n\nCheck your inbox and spam folder.`);
            } catch (error) {
                console.error('[Auth] Password reset error:', error);
                if (error.code === 'auth/user-not-found') {
                    showAuthError('No account found with this email');
                } else if (error.code === 'auth/invalid-email') {
                    showAuthError('Invalid email address');
                } else {
                    showAuthError('Failed to send reset email. Try again');
                }
            }
        }

        // Auth state listener
        onAuthStateChanged(auth, (user) => {
            currentUser = user;
            isAuthReady = true;

            if (user) {
                console.log('[Auth] User signed in:', user.email);
                firestoreUserId = user.uid; // Set for runtime sync
                updateMenuAuthDisplay(); // Update menu

                // Flush queue when authenticated
                if (navigator.onLine) {
                    flushFirestoreQueue();
                }

                // Sync runtime if pending
                if (runtimeSyncPending) {
                    runtimeSyncPending = false;
                    syncRuntimeToFirestore();
                }
            } else {
                console.log('[Auth] No user signed in - app will work offline only');
                firestoreUserId = null;
                updateMenuAuthDisplay(); // Update menu
            }
        });

        /**
         * SESSION ID TRACKING
         * -------------------
         * Each history entry includes a sessionId to group exercises performed in the same workout session.
         *
         * Current strategy: Generate a ULID sessionId once per app load.
         * - All exercises completed before closing/refreshing the app share the same sessionId
         * - Different app launches = different sessionIds, even on the same day
         * - Format: 26-character ULID (Crockford Base32)
         *
         * Future: This enables session-based UI features like:
         * - "Today's Workout" view grouping exercises by session
         * - Session history browser
         * - Session planning (which exercises in what order)
         */
        function generateSessionId() {
            return ulid();
        }

        let currentSessionId = generateSessionId();

        // Session planning
        let sessionPlan = []; // Array of exercise IDs planned for today
        let sessionPlanCompleted = new Set(); // IDs of completed exercises

        // Runtime sync state
        let firestoreUserId = null;
        let runtimeSyncPending = false;
        let runtimeSyncInFlight = false;
        let runtimeSyncTimer = null;

        // Session history cache (Firestore-backed)
        let sessionHistoryCache = [];
        let sessionHistoryLoadedFromFirestore = false;
        let sessionHistoryUnsubscribe = null;
        let legacyHistoryMigrationAttempted = false;
        let firestoreHydrated = false;
        let legacyHistoryFetchAttempted = false;

        function stripSessionMetadata(session) {
            const { _firestoreId, ...rest } = session;
            return rest;
        }

        function serializeSessionHistory(sessions) {
            return sessions.map(stripSessionMetadata);
        }

        function getSessionFingerprint(session) {
            if (session.sessionId) {
                const exerciseKey = session.exerciseId || session.exerciseName || 'unknown';
                return `session:${session.sessionId}|exercise:${exerciseKey}`;
            }
            const exerciseId = session.exerciseId || 'unknown';
            const date = session.date || '';
            const name = session.exerciseName || '';
            return `fallback:${exerciseId}|${date}|${name}`;
        }

        function getSessionTimestamp(session) {
            if (session?.date) {
                const parsed = new Date(session.date);
                if (!isNaN(parsed.getTime())) return parsed.getTime();
            }
            return 0;
        }

        function dedupeSessions(sessions) {
            const map = new Map();
            sessions.forEach((session) => {
                const key = getSessionFingerprint(session);
                if (!key) return;
                const existing = map.get(key);
                if (!existing) {
                    map.set(key, session);
                    return;
                }
                const existingTimestamp = getSessionTimestamp(existing);
                const nextTimestamp = getSessionTimestamp(session);
                if (nextTimestamp > existingTimestamp) {
                    map.set(key, session);
                }
            });
            return Array.from(map.values());
        }

        function setSessionHistoryCache(newHistory, { source = 'unknown', syncLocalStorage = false } = {}) {
            const deduped = dedupeSessions(newHistory);
            deduped.sort((a, b) => new Date(a.date || 0) - new Date(b.date || 0));
            sessionHistoryCache = deduped;
            if (syncLocalStorage) {
                syncCacheToLocalStorage();
            }
            console.log(`[History] Cache updated (${deduped.length} sessions) from ${source}`);
        }

        function getSessionHistoryFromCache() {
            return sessionHistoryCache;
        }

        function syncCacheToLocalStorage() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(serializeSessionHistory(sessionHistoryCache)));
            } catch (error) {
                console.warn('[History] Failed to sync cache to localStorage:', error);
            }
        }

        function loadLegacyHistoryFromLocalStorage() {
            if (firestoreHydrated) {
                return [];
            }
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (!stored) return [];
                const parsed = JSON.parse(stored);
                return Array.isArray(parsed) ? parsed : [];
            } catch (error) {
                console.warn('[History] Failed to read legacy history from localStorage:', error);
                return [];
            }
        }

        function seedLegacyHistoryCache() {
            if (firestoreHydrated) return;
            if (sessionHistoryCache.length > 0) return;
            const legacySessions = loadLegacyHistoryFromLocalStorage();
            if (legacySessions.length > 0) {
                setSessionHistoryCache(legacySessions, { source: 'legacy-localStorage', syncLocalStorage: false });
            }
        }

        function buildRuntimeSnapshot() {
            try {
                const history = getSessionHistoryFromCache();
                const recovery = localStorage.getItem(RECOVERY_STORAGE_KEY);
                const preferences = localStorage.getItem(PREFERENCES_STORAGE_KEY);
                const offlineQueue = localStorage.getItem(FIRESTORE_QUEUE_KEY);
                const dataVersion = localStorage.getItem(PT_VERSION_KEY) || PT_DATA_VERSION;
                const updatedAt = new Date().toISOString();

                localStorage.setItem(RUNTIME_UPDATED_KEY, updatedAt);

                return {
                    updatedAt,
                    sessionHistory: serializeSessionHistory(history),
                    sessionRecovery: recovery ? JSON.parse(recovery) : null,
                    preferences: preferences ? JSON.parse(preferences) : null,
                    offlineQueue: offlineQueue ? JSON.parse(offlineQueue) : [],
                    // Firestore runtime snapshots back up the local working library (not the JSON source).
                    exerciseLibrary: loadExerciseLibrary(),
                    ptDataVersion: dataVersion
                };
            } catch (error) {
                console.error('Failed to build runtime snapshot:', error);
                return null;
            }
        }

        function scheduleRuntimeSync(reason = 'scheduled') {
            if (!firestoreUserId) {
                runtimeSyncPending = true;
                return;
            }
            if (runtimeSyncTimer) {
                clearTimeout(runtimeSyncTimer);
            }
            runtimeSyncTimer = setTimeout(() => {
                runtimeSyncTimer = null;
                void syncRuntimeToFirestore();
            }, 500);
        }

        async function syncRuntimeToFirestore() {
            if (!firestoreUserId) {
                runtimeSyncPending = true;
                return;
            }
            if (runtimeSyncInFlight) return;
            runtimeSyncInFlight = true;
            try {
                const snapshot = buildRuntimeSnapshot();
                if (!snapshot) return;
                const docRef = doc(db, 'users', firestoreUserId, 'pt_runtime', 'state');
                await setDoc(docRef, snapshot, { merge: true });
            } catch (error) {
                console.error('Failed to sync runtime data to Firestore:', error);
            } finally {
                runtimeSyncInFlight = false;
            }
        }

        async function loadRuntimeFromFirestore() {
            if (!firestoreUserId) {
                runtimeSyncPending = true;
                return;
            }
            try {
                const docRef = doc(db, 'users', firestoreUserId, 'pt_runtime', 'state');
                const snapshot = await getDoc(docRef);
                if (!snapshot.exists()) return;

                const data = snapshot.data();
                const remoteUpdatedAt = data?.updatedAt;
                const localUpdatedAt = localStorage.getItem(RUNTIME_UPDATED_KEY);
                if (!remoteUpdatedAt) return;

                if (!localUpdatedAt || new Date(remoteUpdatedAt) > new Date(localUpdatedAt)) {
                    if (Array.isArray(data.sessionHistory)) {
                        console.log('[Firestore] Runtime session history ignored (Firestore sessions collection is authoritative)');
                    }
                    if (data.sessionRecovery) {
                        localStorage.setItem(RECOVERY_STORAGE_KEY, JSON.stringify(data.sessionRecovery));
                    } else {
                        localStorage.removeItem(RECOVERY_STORAGE_KEY);
                    }
                    if (data.preferences) {
                        localStorage.setItem(PREFERENCES_STORAGE_KEY, JSON.stringify(data.preferences));
                    }
                    if (Array.isArray(data.offlineQueue)) {
                        localStorage.setItem(FIRESTORE_QUEUE_KEY, JSON.stringify(data.offlineQueue));
                    }
                    if (Array.isArray(data.exerciseLibrary) && data.exerciseLibrary.length > 0) {
                        const incomingLibraryJson = JSON.stringify(data.exerciseLibrary);
                        const existingLibraryJson = localStorage.getItem(LIBRARY_KEY);
                        if (incomingLibraryJson !== existingLibraryJson) {
                            localStorage.setItem(LIBRARY_KEY, incomingLibraryJson);
                            const version = data.ptDataVersion || PT_DATA_VERSION;
                            localStorage.setItem(PT_VERSION_KEY, version);
                            exerciseLibrary = loadExerciseLibrary();
                            renderExerciseList();
                            renderLibraryExercises();
                        }
                    }
                    localStorage.setItem(RUNTIME_UPDATED_KEY, remoteUpdatedAt);
                }
            } catch (error) {
                console.error('Failed to load runtime data from Firestore:', error);
            }
        }

        function getQueuedSessionFingerprint(session) {
            return getSessionFingerprint(session);
        }

        function removeQueuedSession(session) {
            const queue = loadFirestoreQueue();
            const target = getQueuedSessionFingerprint(session);
            const filtered = queue.filter((queued) => getQueuedSessionFingerprint(queued) !== target);
            if (filtered.length !== queue.length) {
                saveFirestoreQueue(filtered);
            }
        }

        async function resolveFirestoreDocId(session) {
            if (session._firestoreId) return session._firestoreId;
            if (!currentUser || !session.sessionId) return null;
            try {
                const sessionsRef = collection(db, `users/${currentUser.uid}/sessions`);
                const sessionQuery = query(sessionsRef, where('sessionId', '==', session.sessionId));
                const snapshot = await getDocs(sessionQuery);
                const docMatch = snapshot.docs[0];
                return docMatch ? docMatch.id : null;
            } catch (error) {
                console.warn('[Firestore] Failed to resolve session doc ID:', error);
                return null;
            }
        }

        function migrateLegacyHistoryToFirestore(firestoreSessions) {
            if (firestoreHydrated) return [];
            if (legacyHistoryMigrationAttempted) return [];
            legacyHistoryMigrationAttempted = true;

            const migrationFlag = localStorage.getItem(LEGACY_HISTORY_MIGRATION_KEY);
            if (migrationFlag === 'true') return [];

            const legacySessions = loadLegacyHistoryFromLocalStorage();
            if (legacySessions.length === 0) {
                localStorage.setItem(LEGACY_HISTORY_MIGRATION_KEY, 'true');
                return [];
            }

            const firestoreKeys = new Set(firestoreSessions.map(getSessionFingerprint));
            const missingSessions = legacySessions.filter(session => !firestoreKeys.has(getSessionFingerprint(session)));

            if (missingSessions.length > 0) {
                console.log(`[Migration] Queuing ${missingSessions.length} legacy sessions for Firestore sync`);
                missingSessions.forEach(session => enqueueFirestoreSession(session));
            }

            localStorage.setItem(LEGACY_HISTORY_MIGRATION_KEY, 'true');
            return missingSessions;
        }

        async function fetchFirestoreSessionsForLegacyMigration(user) {
            if (!user || firestoreHydrated || legacyHistoryFetchAttempted) return;
            legacyHistoryFetchAttempted = true;
            try {
                const sessionsRef = collection(db, `users/${user.uid}/sessions`);
                const snapshot = await getDocs(query(sessionsRef));
                const sessions = snapshot.docs.map(docSnap => ({
                    _firestoreId: docSnap.id,
                    ...docSnap.data()
                }));
                migrateLegacyHistoryToFirestore(sessions);
            } catch (error) {
                console.warn('[Migration] Failed to fetch Firestore sessions:', error);
            }
        }

        function isWorkoutSessionActive() {
            return Boolean(currentExercise);
        }

        function subscribeToFirestoreSessionHistory(user) {
            if (sessionHistoryUnsubscribe) {
                sessionHistoryUnsubscribe();
                sessionHistoryUnsubscribe = null;
            }

            if (!user) {
                sessionHistoryLoadedFromFirestore = false;
                if (!firestoreHydrated) {
                    seedLegacyHistoryCache();
                }
                return;
            }

            const sessionsRef = collection(db, `users/${user.uid}/sessions`);
            const sessionsQuery = query(sessionsRef);
            let initialLoad = true;

            sessionHistoryUnsubscribe = onSnapshot(sessionsQuery, (snapshot) => {
                const sessions = snapshot.docs.map(docSnap => ({
                    _firestoreId: docSnap.id,
                    ...docSnap.data()
                }));
                const activeSessionId = isWorkoutSessionActive() ? currentSessionId : null;
                const localSessions = getSessionHistoryFromCache();
                const filteredSessions = activeSessionId
                    ? sessions.filter(session => session.sessionId !== activeSessionId)
                    : sessions;
                const queued = loadFirestoreQueue();
                const merged = dedupeSessions([
                    ...filteredSessions,
                    ...localSessions,
                    ...queued
                ]);
                setSessionHistoryCache(merged, { source: 'firestore', syncLocalStorage: true });
                sessionHistoryLoadedFromFirestore = true;
                if (!firestoreHydrated) {
                    firestoreHydrated = true;
                }

                if (initialLoad) {
                    console.log('[Firestore] Session history loaded');
                    initialLoad = false;
                }

                renderHistory();
                updateStreakDisplay();
            }, (error) => {
                console.error('[Firestore] Session history listener error:', error);
                if (initialLoad) {
                    initialLoad = false;
                    sessionHistoryLoadedFromFirestore = true;
                }
            });

            void fetchFirestoreSessionsForLegacyMigration(user);
        }

        onAuthStateChanged(auth, user => {
            firestoreUserId = user ? user.uid : null;
            subscribeToFirestoreSessionHistory(user);
            if (user) {
                void loadRuntimeFromFirestore();
                if (runtimeSyncPending) {
                    runtimeSyncPending = false;
                    void syncRuntimeToFirestore();
                }
            }
        });

        seedLegacyHistoryCache();

        function loadFirestoreQueue() {
            const stored = localStorage.getItem(FIRESTORE_QUEUE_KEY);
            if (!stored) return [];
            try {
                const parsed = JSON.parse(stored);
                return Array.isArray(parsed) ? parsed : [];
            } catch (e) {
                console.warn('Failed to parse Firestore queue:', e);
                return [];
            }
        }

        function saveFirestoreQueue(queue) {
            localStorage.setItem(FIRESTORE_QUEUE_KEY, JSON.stringify(queue));
            void syncRuntimeToFirestore();
        }

        function sanitizeSessionForFirestore(session) {
            return stripSessionMetadata(session);
        }

        function enqueueFirestoreSession(session) {
            const queue = loadFirestoreQueue();
            queue.push(sanitizeSessionForFirestore(session));
            saveFirestoreQueue(queue);
            console.log('[Firestore] Session queued for sync:', session.sessionId || session.date);
        }

        async function flushFirestoreQueue() {
            // Only flush if authenticated
            if (!currentUser) {
                console.log('[Firestore] Skipping queue flush - not authenticated');
                return;
            }

            const queue = loadFirestoreQueue();
            if (queue.length === 0) return;

            console.log(`[Firestore] Flushing ${queue.length} queued sessions for user ${currentUser.uid}`);

            const remaining = [];
            for (const session of queue) {
                try {
                    // Write to user-scoped collection
                    await addDoc(collection(db, `users/${currentUser.uid}/sessions`), sanitizeSessionForFirestore(session));
                    console.log('[Firestore] Queued session synced:', session.sessionId);
                } catch (error) {
                    console.error("Firestore queued write failed:", error);
                    remaining.push(session);
                }
            }

            saveFirestoreQueue(remaining);
            if (remaining.length === 0) {
                console.log('[Firestore] Queue flush complete - all sessions synced');
            } else {
                console.log(`[Firestore] Queue flush complete - ${remaining.length} sessions remain queued`);
            }
        }

        window.addEventListener('online', () => {
            void flushFirestoreQueue();
        });

        if (navigator.onLine) {
            void flushFirestoreQueue();
        }

        function reloadApp() {
            try {
                window.location.reload();
            } catch (e) {
                console.warn('Reload failed, you can close and reopen the app manually.', e);
            }
        }

        // Exercise library loaded from localStorage or starts empty
        let exerciseLibrary = loadExerciseLibrary();

        async function reconcileSharedExerciseLibrary() {
            let sharedExerciseLibrary = [];
            let sharedLoaded = false;

            try {
                sharedExerciseLibrary = await loadExerciseLibraryShared({
                    fallbackUrl: 'exercise_library.json',
                    seedIfMissing: false
                });
                sharedLoaded = true;
            } catch (error) {
                console.warn('[Library] Shared exercise library unavailable; keeping local only.', error);
            }

            if (!sharedLoaded) {
                return;
            }

            const mergedLibrary = mergeExerciseLibraries(sharedExerciseLibrary, exerciseLibrary);
            if (mergedLibrary.length !== exerciseLibrary.length) {
                console.log(`[Library] Merged shared library into local (${exerciseLibrary.length} -> ${mergedLibrary.length}).`);
                exerciseLibrary = mergedLibrary;
                persistExerciseLibrary();
                renderExerciseList();
                renderLibraryExercises();
            }
        }

        function getInitialExercise() {
            // Only restore last used exercise if it exists
            const lastExerciseId = localStorage.getItem(LAST_EXERCISE_KEY);
            if (lastExerciseId) {
                const lastExercise = exerciseLibrary.find(ex => ex.id === lastExerciseId && !ex.archived);
                if (lastExercise) {
                    return toSessionExercise(lastExercise);
                }
            }

            // Don't auto-select any exercise - let user choose
            return null;
        }

        let currentExercise = null;  // Don't auto-open exercises (too easy to accidentally tap rep button)

        let timerInterval = null;
        let timerSecondsRemaining = currentExercise ? Math.max(currentExercise.secondsPerRep || 0, 1) : 0; // counts DOWN
        let timerRunning = false;
        let actionSheetCallback = null;
        let pocketMode = false;

        const TIMER_TYPES = ['timed', 'hold', 'duration'];
        const COUNTER_TYPES = ['reps', 'amrap', 'distance'];

        // Pattern helper functions - avoid hard-coded pattern checks
        function isSidedPattern(pattern) {
            return pattern === 'side';
        }

        function isBilateralPattern(pattern) {
            return pattern === 'both';
        }

        function getSideOptionsForPattern(pattern) {
            return isSidedPattern(pattern) ? ['left', 'right'] : [];
        }

        function getPatternBadge(pattern) {
            return isSidedPattern(pattern) ? 'üîÑ' : '‚úì';
        }

        function getPatternLabel(pattern) {
            return isSidedPattern(pattern) ? 'Sided' : 'Bilateral';
        }

        function getPatternColor(pattern) {
            return isSidedPattern(pattern) ? 'var(--ios-blue)' : 'var(--ios-green)';
        }

        function getPatternDescription(pattern) {
            return isSidedPattern(pattern)
                ? 'work left and right separately'
                : 'both sides together';
        }

        // Derive available tags from library
        function getAvailableTags() {
            const tags = new Set();
            exerciseLibrary.forEach(ex => {
                if (ex.tags && Array.isArray(ex.tags)) {
                    ex.tags.forEach(tag => tags.add(tag));
                }
            });
            return Array.from(tags).sort();
        }

        // Derive available equipment from library
        function getAvailableEquipment() {
            const equipment = new Set();
            exerciseLibrary.forEach(ex => {
                if (ex.equipment && Array.isArray(ex.equipment)) {
                    ex.equipment.forEach(item => equipment.add(item));
                }
                if (ex.equipmentOptional && Array.isArray(ex.equipmentOptional)) {
                    ex.equipmentOptional.forEach(item => equipment.add(item));
                }
            });
            return Array.from(equipment).sort();
        }

        // Get historical values for a form parameter from this exercise's session history
        function getHistoricalParamValues(exerciseId, paramName, side = null) {
            const sessions = loadHistory();
            const exerciseSessions = sessions.filter(s => s.exerciseId === exerciseId);
            const values = new Set();

            exerciseSessions.forEach(session => {
                (session.sets || []).forEach(set => {
                    // Match side if specified, otherwise any side
                    if (side && set.side !== side) return;

                    if (set.formParams && set.formParams[paramName]) {
                        values.add(set.formParams[paramName]);
                    }
                });
            });

            return Array.from(values).sort();
        }

        // Get the last used value for a parameter on this exercise
        function getLastUsedParamValue(exerciseId, paramName, side = null) {
            const sessions = loadHistory();
            const exerciseSessions = sessions.filter(s => s.exerciseId === exerciseId);

            // Sort by date descending (most recent first)
            exerciseSessions.sort((a, b) => new Date(b.date) - new Date(a.date));

            // Find the most recent value
            for (const session of exerciseSessions) {
                for (const set of (session.sets || [])) {
                    // Match side if specified, otherwise any side
                    if (side && set.side !== side) continue;

                    if (set.formParams && set.formParams[paramName]) {
                        return set.formParams[paramName];
                    }
                }
            }

            return null;
        }

        // Format date/time to human-readable EST/EDT
        function formatDateTime(isoDateString) {
            if (!isoDateString) return '';
            const date = new Date(isoDateString);
            return date.toLocaleString('en-US', {
                timeZone: 'America/New_York',
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            });
        }

        // Render a smart form parameter select that learns from history
        function renderSmartParamSelect(param, exerciseId, elementId) {
            const historicalValues = getHistoricalParamValues(exerciseId, param);
            const lastUsed = getLastUsedParamValue(exerciseId, param);
            const label = param.replace(/_/g, ' ');

            // Build options list
            let options = [];

            // Add last used first (if exists)
            if (lastUsed) {
                options.push(`<option value="${lastUsed}" selected>‚úì ${lastUsed} (last used)</option>`);
            }

            // Add other historical values (excluding last used)
            historicalValues.forEach(value => {
                if (value !== lastUsed) {
                    options.push(`<option value="${value}">${value}</option>`);
                }
            });

            // Add "Other..." option
            options.push(`<option value="__other__">Other...</option>`);

            // If no last used, add blank default
            if (!lastUsed) {
                options.unshift(`<option value="">Select ${label}...</option>`);
            }

            return `
                <label style="font-size: 13px; margin-bottom: 4px; display: block;">${label}</label>
                <select class="modal-select" id="${elementId}" style="margin-bottom: 12px;" data-param="${param}" onchange="handleParamSelectChange(this, '${param}')">
                    ${options.join('')}
                </select>
            `;
        }

        // Handle "Other..." selection in parameter dropdowns
        function handleParamSelectChange(selectElement, paramName) {
            if (selectElement.value === '__other__') {
                const newValue = prompt(`Enter custom value for ${paramName.replace(/_/g, ' ')}:`);
                if (newValue && newValue.trim()) {
                    const trimmed = newValue.trim();
                    // Add new option and select it
                    const newOption = document.createElement('option');
                    newOption.value = trimmed;
                    newOption.text = trimmed;
                    newOption.selected = true;
                    selectElement.insertBefore(newOption, selectElement.lastChild); // Before "Other..."
                } else {
                    // User cancelled, reset to blank
                    selectElement.value = '';
                }
            }
        }

        let editingExerciseId = null;
        let selectedTags = [];
        let filterTags = [];
        let selectedSideOptions = [];
        let selectedSupersedes = [];

        const SIDE_OPTIONS_AVAILABLE = ['left', 'right', 'both'];

        // Audio for timer
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Speech synthesis for voice announcements
        function speak(text) {
            if (!preferences.voiceEnabled) return;
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 1.0;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                speechSynthesis.speak(utterance);
            }
        }

        /**
         * FIRST-RUN DETECTION & DATA LOADING
         * -----------------------------------
         * TRUE FIRST RUN is detected when ALL of these are missing:
         *   - PT_VERSION_KEY
         *   - LIBRARY_KEY
         *   - STORAGE_KEY
         *
         * On true first run:
         *   - Seed default exercises into LIBRARY_KEY
         *   - Set PT_VERSION_KEY to prevent future reseeding
         *
         * Once PT_VERSION_KEY exists, we NEVER auto-reseed defaults.
         * This prevents data loss on PWA updates/reinstalls.
         *
         * Parse errors are handled gracefully:
         *   - Log warning to console
         *   - Return empty array (in memory only)
         *   - DO NOT overwrite stored data
         */
        function normalizeExerciseEntry(entry) {
            const normalized = { ...entry };
            const tagSource = normalized.tags;

            if (!normalized.id && normalized.exercise_id) {
                normalized.id = normalized.exercise_id;
                delete normalized.exercise_id;
            }

            if (!normalized.name) {
                normalized.name = normalized.canonical_name || normalized.exercise_name || normalized.title || '';
            }

            if (normalized.canonical_name === undefined && normalized.name) {
                normalized.canonical_name = normalized.name;
            }

            if (normalized.equipment && typeof normalized.equipment === 'object' && !Array.isArray(normalized.equipment)) {
                normalized.equipmentOptional = normalized.equipmentOptional || normalized.equipment.optional || [];
                normalized.equipment = normalized.equipment.required || [];
            }

            if (!normalized.equipment) normalized.equipment = [];
            if (!normalized.equipmentOptional) normalized.equipmentOptional = [];

            if (!Array.isArray(normalized.equipment)) {
                normalized.equipment = [normalized.equipment];
            }
            if (!Array.isArray(normalized.equipmentOptional)) {
                normalized.equipmentOptional = [normalized.equipmentOptional];
            }

            if (tagSource && !Array.isArray(tagSource) && Array.isArray(tagSource.functional)) {
                normalized.tags = tagSource.functional;
                if (!normalized.anatomicRegions && Array.isArray(tagSource.heatmap)) {
                    normalized.anatomicRegions = tagSource.heatmap.join(', ');
                }
            } else if (!normalized.tags) {
                normalized.tags = [];
            }

            if (!normalized.anatomicRegions && Array.isArray(normalized.heatmapTags)) {
                normalized.anatomicRegions = normalized.heatmapTags.join(', ');
            }

            return normalized;
        }

        function loadExerciseLibrary() {
            const version = localStorage.getItem(PT_VERSION_KEY);
            const storedLibrary = localStorage.getItem(LIBRARY_KEY);
            // Load existing library or start empty
            if (storedLibrary) {
                try {
                    const parsed = JSON.parse(storedLibrary);
                    const exercises = Array.isArray(parsed)
                        ? parsed
                        : Array.isArray(parsed?.exercises)
                            ? parsed.exercises
                            : null;
                    if (exercises) {
                        return exercises.map(normalizeExerciseEntry);
                    }
                } catch (e) {
                    console.error('Failed to parse exercise library:', e);
                    console.warn('Returning empty library - stored data preserved');
                    return [];
                }
            }

            // No stored library - start empty
            // User can browse library to import exercises
            return [];
        }

        function persistExerciseLibrary() {
            localStorage.setItem(LIBRARY_KEY, JSON.stringify(exerciseLibrary));
            scheduleRuntimeSync('exercise-library');
        }

        function getTodayDateString() {
            return new Date().toISOString().split('T')[0];
        }

        function updateExerciseLifecycle(entry, { archived }) {
            const lifecycle = entry.lifecycle || {
                status: 'active',
                effective_start_date: null,
                effective_end_date: null
            };

            if (archived) {
                lifecycle.status = 'archived';
                lifecycle.effective_end_date = getTodayDateString();
            } else {
                lifecycle.status = 'active';
                lifecycle.effective_end_date = null;
            }

            entry.lifecycle = lifecycle;
        }

        async function syncExerciseLibraryToFirestore(reason) {
            try {
                const schemaFormattedLibrary = buildExerciseLibrarySchemaData(exerciseLibrary);
                await saveExerciseLibraryShared(schemaFormattedLibrary);
                console.log(`[Library] Shared library synced after ${reason}.`);
            } catch (error) {
                console.warn(`[Library] Shared library sync failed after ${reason}:`, error);
            }
        }

        // Synchronous load/save for roles data
        function loadRolesDataSync() {
            const stored = localStorage.getItem(ROLES_DATA_KEY);
            if (stored) {
                try {
                    return JSON.parse(stored);
                } catch (e) {
                    console.error('[Roles] Failed to parse stored roles:', e);
                }
            }
            // Return default structure if not found
            return { exercise_roles: {} };
        }

        function saveRolesDataSync(rolesData) {
            localStorage.setItem(ROLES_DATA_KEY, JSON.stringify(rolesData));
            void syncRolesToFirestore(rolesData);
        }

        // Synchronous load/save for vocabulary
        function loadVocabularySync() {
            const stored = localStorage.getItem(VOCABULARY_KEY);
            if (stored) {
                try {
                    return JSON.parse(stored);
                } catch (e) {
                    console.error('[Vocabulary] Failed to parse stored vocabulary:', e);
                }
            }
            // Return default structure if not found
            return {};
        }

        function saveVocabularySync(vocabulary) {
            localStorage.setItem(VOCABULARY_KEY, JSON.stringify(vocabulary));
            void syncVocabularyToFirestore(vocabulary);
        }

        // Safe history loading with error handling and backward compatibility
        function loadHistory() {
            const sessions = getSessionHistoryFromCache();
            if (!Array.isArray(sessions)) return [];

            sessions.forEach(session => {
                // Ensure sessionId exists (added in later versions)
                if (!session.sessionId) {
                    session.sessionId = session.date || new Date().toISOString();
                }

                // Ensure exerciseId exists (try to find by name if missing)
                if (!session.exerciseId && session.exerciseName) {
                    const matchingExercise = exerciseLibrary.find(ex => ex.name === session.exerciseName);
                    if (matchingExercise) {
                        session.exerciseId = matchingExercise.id;
                    }
                }

                // Ensure sets array exists
                if (!session.sets) {
                    session.sets = [];
                }

                // Migrate old weight/resistance fields to formParams if needed
                session.sets = session.sets.map(set => {
                    if ((set.weight || set.resistance) && !set.formParams) {
                        set.formParams = {};
                        if (set.weight) {
                            set.formParams.weight = set.weight;
                            set.formParams.weight_unit = set.weightUnit || 'lbs';
                        }
                        if (set.resistance) {
                            set.formParams.band_resistance = set.resistance;
                        }
                    }
                    return set;
                });

            });

            return sessions;
        }

        function addSessionToCache(session) {
            const updated = [...getSessionHistoryFromCache(), session];
            setSessionHistoryCache(updated, { source: 'local-add', syncLocalStorage: true });
        }

        function queueSessionsForFirestore(sessions, source = 'import') {
            if (!Array.isArray(sessions) || sessions.length === 0) return;
            const pendingSessions = sessions.filter(session => !session._firestoreId);
            if (pendingSessions.length === 0) return;
            console.log(`[Firestore] Queueing ${pendingSessions.length} sessions from ${source}`);
            pendingSessions.forEach(session => enqueueFirestoreSession(session));
            if (currentUser && navigator.onLine) {
                void flushFirestoreQueue();
            }
        }

        // Load roles data from JSON file (cached by service worker)
        function loadRolesData() {
            const fallbackData = loadRolesDataSync();
            return loadExerciseRolesShared({
                fallbackUrl: 'exercise_roles.json',
                fallbackData,
                seedIfMissing: true
            }).then((data) => {
                if (data) {
                    saveRolesDataSync(data);
                }
                return data;
            }).catch(err => {
                console.error('Failed to load roles data:', err);
                return { exercise_roles: {} };
            });
        }

        // Load schema from JSON file (cached by service worker)
        function loadSchema() {
            return loadExerciseFileSchemaShared({
                fallbackUrl: 'schema/exercise_file.schema.json',
                seedIfMissing: true
            }).catch(err => {
                console.error('Failed to load schema:', err);
                return {};
            });
        }

        // Load vocabulary from JSON file (cached by service worker)
        function loadVocabulary() {
            const fallbackData = loadVocabularySync();
            return loadExerciseVocabularyShared({
                fallbackUrl: 'exercise_roles_vocabulary.json',
                fallbackData,
                seedIfMissing: true
            }).then((data) => {
                if (data) {
                    saveVocabularySync(data);
                }
                return data;
            }).catch(err => {
                console.error('Failed to load vocabulary:', err);
                return {};
            });
        }

        /**
         * DATA LOSS PREVENTION - TEST CHECKLIST
         * --------------------------------------
         * To verify the version guard prevents data loss:
         *
         * ‚úì TEST 1: True first run
         *   - Clear all localStorage (DevTools ‚Üí Application ‚Üí Clear Site Data)
         *   - Reload app
         *   - EXPECT: Default exercises seeded, PT_VERSION_KEY set to "1"
         *   - VERIFY: localStorage has pt_data_version="1", pt_exercise_library with defaults
         *
         * ‚úì TEST 2: Update with existing data
         *   - Add custom exercises, complete some workouts
         *   - Note your custom data
         *   - Reload app (simulates PWA update)
         *   - EXPECT: All custom exercises and history preserved
         *   - VERIFY: No re-seeding, PT_VERSION_KEY still "1"
         *
         * ‚úì TEST 3: Corrupted JSON
         *   - In DevTools ‚Üí Application ‚Üí localStorage, manually corrupt pt_exercise_library
         *     (e.g., change JSON to invalid syntax like `[{broken`)
         *   - Reload app
         *   - EXPECT: Console shows error "Failed to parse exercise library"
         *   - EXPECT: Console shows warning "Returning empty library - stored data preserved"
         *   - EXPECT: App shows blank exercise list (safe in-memory fallback)
         *   - VERIFY: Corrupted data still in localStorage (not overwritten)
         *   - FIX: Restore valid JSON or clear localStorage to reset
         */

        /**
         * EXERCISE OBJECT STRUCTURE
         * -------------------------
         * This app represents exercises in two forms:
         *
         * 1. Library Entry (persisted in localStorage):
         *    - id: unique identifier
         *    - name: exercise name
         *    - pattern: 'side' | 'both' (determines if sides tracked separately)
         *    - current: { type, sets, repsPerSet, secondsPerRep }
         *    - sideOptions: ['left', 'right'] (for sided exercises)
         *    - tags: body parts (knee, hip, etc.)
         *    - equipment: array of equipment types
         *    - guidance: { external_cues, motor_cues, compensation_warnings, safety_flags }
         *    - history: array of revisions tracking dosage changes
         *    - details: { description, executionTips, shouldFeel, shouldNotFeel, etc. }
         *    - favorite, archived: boolean flags
         *
         * 2. Session Exercise (runtime state):
         *    Converted from library entry by toSessionExercise()
         *    - All library fields PLUS:
         *    - currentSet, currentRep: live progress tracking
         *    - sessionData: array of logged sets [{set, reps, timestamp, side?, weight?, resistance?}]
         *
         * TODO: Define what a "session" is (one workout? one day? when does it end?)
         * TODO: Add program-layer integration (how exercises fit into rehab programs)
         * TODO: Schema-driven fields (lifecycle, progression parameters, etc.)
         */
        function toSessionExercise(entry) {
            const spec = entry?.current || {};
            const isBilateral = isBilateralPattern(entry.pattern);
            const sideOptions = entry.sideOptions || [];

            // For sided exercises, multiply sets by number of sides
            // E.g., 3 sets with ['left', 'right'] = 6 total sets (3 per side)
            const baseSets = spec.sets || 3;
            const effectiveSides = (!isBilateral && sideOptions.length > 0) ? sideOptions.length : 1;
            const totalSets = baseSets * effectiveSides;

            return {
                id: entry.id,
                name: entry.name,
                type: spec.type || 'reps',
                sets: totalSets,
                baseSets: baseSets, // Original sets per side
                sideOptions: sideOptions,
                bilateral: isBilateral,
                repsPerSet: spec.repsPerSet || 10,
                secondsPerRep: spec.secondsPerRep ?? 10,
                currentSet: 1,
                currentRep: 0,
                sessionData: [] // Populated during execution
            };
        }

        function getLibraryEntryById(id) {
            return exerciseLibrary.find(ex => ex.id === id) || exerciseLibrary[0];
        }

        function recordRevision(entry, nextSpec, reason = 'Updated dosage') {
            const previous = { ...(entry.current || {}) };
            const changes = [];

            if ((previous.sets ?? null) !== nextSpec.sets) changes.push(`sets ${previous.sets ?? '‚Äî'} ‚Üí ${nextSpec.sets}`);
            if ((previous.repsPerSet ?? null) !== nextSpec.repsPerSet) changes.push(`reps ${previous.repsPerSet ?? '‚Äî'} ‚Üí ${nextSpec.repsPerSet}`);
            if ((previous.secondsPerRep ?? null) !== nextSpec.secondsPerRep) changes.push(`seconds ${previous.secondsPerRep ?? '‚Äî'} ‚Üí ${nextSpec.secondsPerRep}`);
            if ((previous.type ?? '') !== nextSpec.type) changes.push(`type ${previous.type || 'reps'} ‚Üí ${nextSpec.type}`);

            entry.history = entry.history || [];
            entry.history.push({
                timestamp: new Date().toISOString(),
                summary: changes.length ? changes.join(', ') : reason,
                previous,
                next: nextSpec,
                supersedes: entry.supersedes || []
            });

            entry.current = nextSpec;
            persistExerciseLibrary();
        }

        function populateExerciseSelect() {
            const select = document.getElementById('exercise-select');
            const selectedValue = currentExercise?.id;
            select.innerHTML = '';

            exerciseLibrary.forEach(entry => {
                const opt = document.createElement('option');
                opt.value = entry.id;
                opt.textContent = entry.name;
                if (entry.id === selectedValue) {
                    opt.selected = true;
                }
                select.appendChild(opt);
            });
        }

        function applyLibraryEntryToForm(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            const spec = entry.current || {};

            document.getElementById('exercise-type').value = spec.type || 'reps';
            document.getElementById('sets-input').value = spec.sets || 3;
            document.getElementById('reps-input').value = spec.repsPerSet || 10;
            document.getElementById('target-input').value = spec.secondsPerRep ?? 10;
            updateTargetLabel();
        }

        function playBeep(frequency = 800, duration = 200) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = 'square'; // More noticeable than sine

            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime); // Louder
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration / 1000);
        }

        function playCompletionSound() {
            // Triple beep for completion
            playBeep(1000, 150);
            setTimeout(() => playBeep(1200, 150), 200);
            setTimeout(() => playBeep(1400, 200), 400);
        }

        // Haptic feedback helper (stronger vibrations for better feedback)
        function haptic(style = 'light') {
            if (!preferences.hapticEnabled) return;
            if ('vibrate' in navigator) {
                switch(style) {
                    case 'light':
                        navigator.vibrate(30);
                        break;
                    case 'medium':
                        navigator.vibrate(50);
                        break;
                    case 'heavy':
                        navigator.vibrate(80);
                        break;
                    case 'success':
                        navigator.vibrate([30, 50, 30]);
                        break;
                    case 'error':
                        navigator.vibrate([50, 100, 50]);
                        break;
                }
            }
        }

        const isTimerType = (type) => TIMER_TYPES.includes(type);

        /**
         * POCKET MODE BEHAVIOR
         * --------------------
         * Eyes-free fullscreen overlay for use when phone is in pocket/armband.
         *
         * HOW IT WORKS:
         *
         * For REP-BASED exercises (reps, amrap, distance):
         *   - Large tap area displays current rep count
         *   - Each tap increments the counter
         *   - Audio and haptic feedback confirm each tap
         *   - When target reps reached, set auto-completes
         *
         * For TIME-BASED exercises (timed, hold, duration):
         *   - Large tap area displays countdown timer
         *   - First tap starts the timer
         *   - Second tap pauses the timer
         *   - Timer auto-advances to next rep when complete
         *   - Can log partial reps (if paused) via "Log This Time" button (not in Pocket mode)
         *
         * INTERACTION:
         *   - Tap anywhere on white pad to count/start-pause
         *   - Small X button in top-left to exit (positioned away from tap area)
         *   - All existing audio/haptic cues preserved
         *
         * TODO: Add Pocket mode support for "Log This Rep" when timer paused
         * TODO: Consider voice-only interaction mode (no screen needed)
         */
        // Pocket Mode long-press detection for timer logging
        let pocketPressTimer = null;
        let pocketLongPressTriggered = false;

        function togglePocketMode(enabled) {
            pocketMode = enabled;
            const overlay = document.getElementById('pocket-overlay');
            if (enabled) {
                overlay.classList.add('active');
                haptic('medium');
                setupPocketLongPress();
            } else {
                overlay.classList.remove('active');
                haptic('medium');
                cleanupPocketLongPress();
            }
            updatePocketOverlay();
        }

        function setupPocketLongPress() {
            const overlay = document.getElementById('pocket-overlay');
            overlay.addEventListener('touchstart', handlePocketPressStart, { passive: true });
            overlay.addEventListener('touchend', handlePocketPressEnd, { passive: true });
            overlay.addEventListener('touchcancel', handlePocketPressCancel, { passive: true });
        }

        function cleanupPocketLongPress() {
            const overlay = document.getElementById('pocket-overlay');
            overlay.removeEventListener('touchstart', handlePocketPressStart);
            overlay.removeEventListener('touchend', handlePocketPressEnd);
            overlay.removeEventListener('touchcancel', handlePocketPressCancel);
            if (pocketPressTimer) {
                clearTimeout(pocketPressTimer);
                pocketPressTimer = null;
            }
        }

        function handlePocketPressStart(e) {
            // Ignore if tapping the X button
            if (e.target.closest('.pocket-close')) return;

            pocketLongPressTriggered = false;

            // Only enable long-press for timer exercises
            if (!isTimerType(currentExercise.type)) return;

            // Start long-press timer (700ms for deliberate action)
            pocketPressTimer = setTimeout(() => {
                pocketLongPressTriggered = true;
                handlePocketLongPress();
            }, 700);
        }

        function handlePocketPressEnd(e) {
            if (pocketPressTimer) {
                clearTimeout(pocketPressTimer);
                pocketPressTimer = null;
            }
        }

        function handlePocketPressCancel(e) {
            if (pocketPressTimer) {
                clearTimeout(pocketPressTimer);
                pocketPressTimer = null;
            }
            pocketLongPressTriggered = false;
        }

        function handlePocketLongPress() {
            // Log timer and advance to next rep
            if (isTimerType(currentExercise.type) && timerRunning) {
                logPartialTimerRep();
                updatePocketOverlay();
            }
        }

        function handlePocketTap() {
            if (!pocketMode) return;

            // If long-press was triggered, don't also handle tap
            if (pocketLongPressTriggered) {
                pocketLongPressTriggered = false;
                return;
            }

            if (COUNTER_TYPES.includes(currentExercise.type)) {
                incrementCounter();
            } else if (isTimerType(currentExercise.type)) {
                if (!timerRunning) {
                    startTimer();
                } else {
                    stopTimer();
                }
            }
            updatePocketOverlay();
        }

        function updatePocketOverlay() {
            const overlay = document.getElementById('pocket-overlay');
            if (!overlay.classList.contains('active')) return;

            const setsLeft = Math.max(currentExercise.sets - currentExercise.currentSet, 0);
            const repsLeft = Math.max((currentExercise.repsPerSet || 0) - currentExercise.currentRep, 0);
            const label = COUNTER_TYPES.includes(currentExercise.type)
                ? `${currentExercise.currentRep}`
                : `${formatSeconds(timerSecondsRemaining)}`;

            document.getElementById('pocket-label').textContent = label;

            const metaPieces = [
                `Sets left: ${setsLeft}`
            ];

            if (COUNTER_TYPES.includes(currentExercise.type) && currentExercise.type !== 'amrap' && currentExercise.repsPerSet) {
                metaPieces.push(`Reps left: ${repsLeft}`);
            }

            if (currentExercise.type === 'amrap' && currentExercise.secondsPerRep) {
                metaPieces.push(`AMRAP ${currentExercise.secondsPerRep}s window`);
            }

            if (currentExercise.type === 'distance') {
                metaPieces.push(`Distance goal: ${currentExercise.repsPerSet}`);
            }

            if (isTimerType(currentExercise.type)) {
                metaPieces.push(timerRunning ? 'Timer running' : 'Timer paused');
            }

            document.getElementById('pocket-meta').textContent = metaPieces.join(' ¬∑ ');
        }

        // iOS-style Action Sheet
        function showActionSheet(message, onConfirm) {
            document.getElementById('action-sheet-message').textContent = message;
            actionSheetCallback = onConfirm;

            const backdrop = document.getElementById('action-sheet-backdrop');
            const sheet = document.getElementById('action-sheet');

            backdrop.classList.add('active');
            setTimeout(() => {
                sheet.classList.add('active');
            }, 10);

            haptic('medium');
        }

        function hideActionSheet() {
            const backdrop = document.getElementById('action-sheet-backdrop');
            const sheet = document.getElementById('action-sheet');

            sheet.classList.remove('active');
            setTimeout(() => {
                backdrop.classList.remove('active');
            }, 300);

            actionSheetCallback = null;
            haptic('medium');
        }

        function confirmActionSheet() {
            if (actionSheetCallback) {
                actionSheetCallback();
            }
            hideActionSheet();
            haptic('medium');
        }

        // Counter Functions
        function incrementCounter() {
            if (!COUNTER_TYPES.includes(currentExercise.type)) return;

            currentExercise.currentRep++;
            haptic('medium');

            const repsLeft = currentExercise.repsPerSet - currentExercise.currentRep;

            // Voice announcements at milestones
            if (currentExercise.repsPerSet && currentExercise.type !== 'amrap') {
                if (repsLeft === 5) speak('5 reps left');
                else if (repsLeft === 3) speak('3 reps left');
                else if (repsLeft === 1) speak('Last rep');
                else if (repsLeft === 0) {
                    playCompletionSound();
                    haptic('success');
                    speak('Set complete');
                }
            }

            updateDisplay();
        }

        function formatSeconds(totalSeconds = 0) {
            const minutes = Math.floor(Math.max(totalSeconds, 0) / 60);
            const seconds = Math.max(totalSeconds % 60, 0);
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function updateDisplay() {
            // Handle no exercise selected
            if (!currentExercise) {
                document.getElementById('exercise-name').textContent = 'No Exercise Selected';
                document.getElementById('set-info').textContent = 'Tap "Exercises" below to choose';
                document.getElementById('remaining-info').textContent = '';
                document.getElementById('counter-mode').classList.add('hidden');
                document.getElementById('timer-mode').classList.add('hidden');
                document.getElementById('main-controls').classList.add('hidden');
                return;
            }

            // Show exercise name with pattern badge
            const entry = getLibraryEntryById(currentExercise.id);
            let exerciseNameDisplay = currentExercise.name;
            if (entry) {
                const patternBadge = ' ' + getPatternBadge(entry.pattern);
                exerciseNameDisplay += patternBadge;
            }
            document.getElementById('exercise-name').textContent = exerciseNameDisplay;

            // For sided exercises, show per-side progress
            const hasSides = currentExercise.sideOptions && currentExercise.sideOptions.length > 0 && !currentExercise.bilateral;
            let setInfoText = `Set ${currentExercise.currentSet} of ${currentExercise.sets}`;

            if (hasSides && currentExercise.baseSets) {
                setInfoText += ` (${currentExercise.baseSets} per side)`;
            }
            document.getElementById('set-info').textContent = setInfoText;

            const setsLeft = Math.max(currentExercise.sets - currentExercise.currentSet, 0);
            const repsLeft = Math.max((currentExercise.repsPerSet || 0) - currentExercise.currentRep, 0);

            let remainingLabel = `Sets left: ${setsLeft}`;

            // For sided exercises, show per-side breakdown
            if (hasSides && currentExercise.sideOptions) {
                const sideProgress = {};
                currentExercise.sideOptions.forEach(side => sideProgress[side] = 0);

                // Count completed sets per side
                currentExercise.sessionData.forEach(set => {
                    if (set.side && sideProgress[set.side] !== undefined) {
                        sideProgress[set.side]++;
                    }
                });

                const sideLabels = currentExercise.sideOptions.map(side =>
                    `${side}: ${sideProgress[side]}/${currentExercise.baseSets}`
                ).join(' ¬∑ ');

                // Show alternating indicator if applicable
                const entry = getLibraryEntryById(currentExercise.id);
                const hasAlternating = entry && (entry.pattern_modifiers || []).includes('alternating');
                remainingLabel = `${sideLabels}`;
                if (hasAlternating) {
                    remainingLabel += ' ‚ö° Alternating';
                }
            }

            if (COUNTER_TYPES.includes(currentExercise.type) && currentExercise.type !== 'amrap' && currentExercise.repsPerSet) {
                remainingLabel += ` ¬∑ Reps left: ${repsLeft}`;
            }
            if (currentExercise.type === 'amrap' && currentExercise.secondsPerRep) {
                remainingLabel += ` ¬∑ ${currentExercise.secondsPerRep}s AMRAP window`;
            }
            if (isTimerType(currentExercise.type)) {
                remainingLabel += ` ¬∑ Time: ${formatSeconds(timerSecondsRemaining)}`;
            }
            document.getElementById('remaining-info').textContent = remainingLabel;

            if (COUNTER_TYPES.includes(currentExercise.type)) {
                document.getElementById('counter-mode').classList.remove('hidden');
                document.getElementById('timer-mode').classList.add('hidden');
                document.getElementById('main-controls').classList.remove('hidden');

                document.getElementById('counter-display').textContent = currentExercise.currentRep;

                let targetText = 'Target: ';
                if (currentExercise.type === 'amrap') {
                    targetText += currentExercise.secondsPerRep ? `${currentExercise.secondsPerRep}s AMRAP window` : 'AMRAP';
                } else if (currentExercise.type === 'distance') {
                    targetText += `${currentExercise.repsPerSet || 0} distance units`;
                } else {
                    targetText += `${currentExercise.repsPerSet} reps`;
                }
                document.getElementById('target-info').textContent = targetText;

                const progress = currentExercise.repsPerSet
                    ? Math.min((currentExercise.currentRep / currentExercise.repsPerSet) * 100, 100)
                    : Math.min((currentExercise.currentSet / currentExercise.sets) * 100, 100);
                document.getElementById('progress-bar').style.width = progress + '%';
            } else {
                document.getElementById('counter-mode').classList.add('hidden');
                document.getElementById('timer-mode').classList.remove('hidden');
                document.getElementById('main-controls').classList.remove('hidden');

                const repLabel = currentExercise.type === 'hold' || currentExercise.type === 'duration'
                    ? `Set ${currentExercise.currentSet} timer`
                    : `Rep ${currentExercise.currentRep + 1} of ${currentExercise.repsPerSet}`;
                document.getElementById('timer-rep-info').textContent = repLabel;

                const display = formatSeconds(timerSecondsRemaining);
                document.getElementById('timer-display').textContent = display;

                const timerLabel = currentExercise.type === 'duration'
                    ? `Target: ${currentExercise.secondsPerRep || 0}s total`
                    : `Target: ${currentExercise.secondsPerRep || 0} seconds`;
                document.getElementById('timer-target').textContent = timerLabel;

                const progress = currentExercise.secondsPerRep
                    ? Math.max(0, (timerSecondsRemaining / currentExercise.secondsPerRep) * 100)
                    : 0;
                document.getElementById('timer-progress-bar').style.width = progress + '%';

                const timerDisplay = document.getElementById('timer-display');
                timerDisplay.classList.remove('warning', 'danger');
                if (timerSecondsRemaining <= 5 && timerSecondsRemaining > 0) {
                    timerDisplay.classList.add('danger');
                } else if (timerSecondsRemaining <= 10 && timerSecondsRemaining > 5) {
                    timerDisplay.classList.add('warning');
                }

                const logControls = document.getElementById('timer-log-controls');
                if (timerRunning) {
                    document.getElementById('timer-start-btn').classList.add('hidden');
                    document.getElementById('timer-stop-btn').classList.remove('hidden');
                    document.getElementById('timer-reset-btn').classList.add('hidden');
                    logControls.style.display = 'none';
                } else if (timerSecondsRemaining === 0 || timerSecondsRemaining === currentExercise.secondsPerRep) {
                    document.getElementById('timer-start-btn').classList.remove('hidden');
                    document.getElementById('timer-stop-btn').classList.add('hidden');
                    document.getElementById('timer-reset-btn').classList.add('hidden');
                    logControls.style.display = 'none';
                } else {
                    // Timer is paused mid-rep
                    document.getElementById('timer-start-btn').classList.remove('hidden');
                    document.getElementById('timer-stop-btn').classList.add('hidden');
                    document.getElementById('timer-reset-btn').classList.remove('hidden');
                    // Show "Log This Time & Next Rep" button when paused
                    logControls.style.display = 'flex';
                }
            }

            // Update side selector for unilateral exercises
            updateCurrentSideSelector();

            updatePocketOverlay();
        }

        function startTimer() {
            if (timerInterval || !isTimerType(currentExercise.type)) return;

            const targetSeconds = Math.max(currentExercise.secondsPerRep || 0, 1);

            // Initialize timer if starting fresh
            if (timerSecondsRemaining === 0) {
                timerSecondsRemaining = targetSeconds;
            }

            timerRunning = true;
            playBeep(400, 100); // Audio feedback for resume
            haptic('heavy'); // Stronger haptic for resume

            timerInterval = setInterval(() => {
                timerSecondsRemaining--;
                updateDisplay();

                // Countdown beeps
                if (timerSecondsRemaining <= 3 && timerSecondsRemaining > 0) {
                    playBeep(600, 100);
                    haptic('medium');
                }

                // Timer complete
                if (timerSecondsRemaining <= 0) {
                    stopTimer();
                    playCompletionSound();
                    haptic('success');

                    currentExercise.currentRep++;

                    const repsLeft = currentExercise.repsPerSet - currentExercise.currentRep;
                    if (repsLeft === 0) speak('Set complete');
                    else if (repsLeft === 1) speak('Last rep');
                    else speak(`${repsLeft} reps left`);

                    // Auto-complete holds/durations when rep target is reached
                    if (currentExercise.type !== 'timed' && currentExercise.repsPerSet && currentExercise.currentRep >= currentExercise.repsPerSet) {
                        updateDisplay();
                        return;
                    }

                    // Reset timer for next rep
                    timerSecondsRemaining = targetSeconds;
                    updateDisplay();
                }
            }, 1000);

            updateDisplay();
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            timerRunning = false;
            playBeep(300, 100); // Audio feedback for pause
            haptic('heavy'); // Stronger haptic for pause
            updateDisplay();
        }

        function seedTimerSeconds() {
            timerSecondsRemaining = isTimerType(currentExercise.type)
                ? Math.max(currentExercise.secondsPerRep || 0, 1)
                : 0;
        }

        function resetTimer() {
            stopTimer();
            seedTimerSeconds();
            haptic('heavy');
            updateDisplay();
        }

        // Log the current partial timer value and advance to next rep
        function logPartialTimerRep() {
            const achievedSeconds = Math.max(currentExercise.secondsPerRep || 0, 1) - timerSecondsRemaining;

            // Record this rep with the actual time achieved (not target)
            const setData = {
                set: currentExercise.currentSet,
                reps: 1,
                secondsAchieved: achievedSeconds,
                secondsTarget: currentExercise.secondsPerRep || 0,
                type: currentExercise.type,
                timestamp: new Date().toISOString(),
                partialRep: true
            };

            // Add side information for unilateral exercises (but not alternating)
            if (currentWorkingSide !== 'both' && currentWorkingSide !== 'alternating') {
                setData.side = currentWorkingSide;
            }

            currentExercise.sessionData.push(setData);

            playBeep(500, 150);
            haptic('success');
            speak(`Logged ${achievedSeconds} seconds`);

            currentExercise.currentRep++;

            const repsLeft = currentExercise.repsPerSet - currentExercise.currentRep;
            if (repsLeft === 0) {
                speak('Set complete');
                seedTimerSeconds();
                updateDisplay();
            } else {
                if (repsLeft === 1) speak('Last rep');
                else speak(`${repsLeft} reps left`);

                // Reset timer for next rep
                seedTimerSeconds();
                updateDisplay();
            }
        }

        function completeSet() {
            const reps = currentExercise.currentRep;

            if (reps === 0) {
                showActionSheet('‚ö†Ô∏è Complete set with 0 reps?\n\nThis will log an empty set and move to the next set.\n\nTip: Use "Log Set" to manually enter reps.', () => {
                    finishSet();
                });
                return;
            }

            const setData = {
                set: currentExercise.currentSet,
                reps: reps,
                type: currentExercise.type,
                timestamp: new Date().toISOString()
            };

            // Add side information for unilateral exercises (but not alternating)
            if (currentWorkingSide !== 'both' && currentWorkingSide !== 'alternating') {
                setData.side = currentWorkingSide;
            }

            currentExercise.sessionData.push(setData);

            haptic('success');
            speak(`Set ${currentExercise.currentSet} complete`);

            // Check for progress
            detectProgress(currentExercise.currentSet, reps);

            if (currentExercise.currentSet < currentExercise.sets) {
                currentExercise.currentSet++;
                currentExercise.currentRep = 0;
                seedTimerSeconds();
                stopTimer();
                updateDisplay();

                // Show rest timer if rest time is recommended
                const entry = getLibraryEntryById(currentExercise.id);
                const restSeconds = entry.details?.restSeconds;
                if (restSeconds && restSeconds > 0) {
                    showRestTimer(restSeconds);
                }
            } else {
                speak('All sets complete');
                // Check if form parameters need to be logged
                const entry = getLibraryEntryById(currentExercise.id);
                const formParams = entry?.form_parameters_required || [];
                if (formParams.length > 0) {
                    showFormParamsModal();
                } else {
                    showSessionNotesModal();
                }
            }
        }

        /**
         * EXERCISE EXECUTION DATA TRACKING
         * ---------------------------------
         * When performing an exercise, this app currently tracks:
         *
         * currentExercise.sessionData[] contains:
         *   - set: which set number (1-based)
         *   - reps: how many reps completed
         *   - type: exercise type (reps, timed, hold, etc.)
         *   - timestamp: ISO datetime of completion
         *   - side: (optional) which side for unilateral exercises ('left', 'right', 'both')
         *   - weight: (optional) weight used in lbs/kg
         *   - weightUnit: (optional) 'lbs' or 'kg'
         *   - resistance: (optional) resistance band level ('light', 'medium', 'heavy')
         *   - secondsAchieved: (optional) actual time held (for partial timer reps)
         *   - secondsTarget: (optional) target time (for partial timer reps)
         *   - partialRep: (optional) true if logged early via "Log This Time"
         *   - manualLog: (optional) true if logged via "Log Set" modal
         *
         * At session completion (all sets done):
         *   - sessionData is saved to the in-memory cache and queued to Firestore
         *   - Includes: exerciseId, exerciseName, date, sets[], notes
         *
         * TODO: Define "session" concept - when does it start/end? How to group exercises?
         * TODO: Add session planning (which exercises in what order for today)
         * TODO: Track adherence to program-level dosage prescriptions
         * TODO: Progressive overload tracking (weight/resistance over time)
         */
        function finishSet() {
            const setData = {
                set: currentExercise.currentSet,
                reps: currentExercise.currentRep,
                type: currentExercise.type,
                timestamp: new Date().toISOString()
            };

            // Add side information for unilateral exercises (but not alternating)
            if (currentWorkingSide !== 'both' && currentWorkingSide !== 'alternating') {
                setData.side = currentWorkingSide;
            }

            currentExercise.sessionData.push(setData);

            if (currentExercise.currentSet < currentExercise.sets) {
                currentExercise.currentSet++;
                currentExercise.currentRep = 0;
                seedTimerSeconds();
                stopTimer();
                updateDisplay();
            } else {
                // Check if form parameters need to be logged
                const entry = getLibraryEntryById(currentExercise.id);
                const formParams = entry?.form_parameters_required || [];
                if (formParams.length > 0) {
                    showFormParamsModal();
                } else {
                    showSessionNotesModal();
                }
            }
        }

        let logSetSide = 'both'; // Track which side for unilateral exercises
        let currentWorkingSide = 'both'; // Track which side for current set during rep/timer

        function updateCurrentSideSelector() {
            const entry = getLibraryEntryById(currentExercise?.id);
            if (!entry) return;

            const sideOptions = entry.sideOptions || [];
            const isBilateral = isBilateralPattern(entry.pattern);
            const hasAlternating = entry && (entry.pattern_modifiers || []).includes('alternating');
            const selectorContainer = document.getElementById('current-side-selector');
            const buttonsContainer = document.getElementById('current-side-buttons');

            // For alternating exercises, show indicator instead of selector
            if (hasAlternating && sideOptions.length > 0 && !isBilateral) {
                buttonsContainer.innerHTML = `
                    <div style="
                        flex: 1;
                        padding: 14px 10px;
                        border-radius: 12px;
                        border: 3px solid var(--ios-orange);
                        background: rgba(255,149,0,0.1);
                        text-align: center;
                    ">
                        <div style="font-size: 20px; margin-bottom: 2px;">‚ö°</div>
                        <div style="font-size: 15px; font-weight: 700; text-transform: uppercase; color: var(--text-primary); margin-bottom: 4px;">
                            ALTERNATING
                        </div>
                        <div style="font-size: 12px; font-weight: 600; color: var(--ios-gray);">
                            Switch sides each rep
                        </div>
                    </div>
                `;
                selectorContainer.style.display = 'block';
                currentWorkingSide = 'alternating'; // Special marker
                return;
            }

            // Show selector only for non-alternating unilateral exercises
            if (sideOptions.length > 0 && !isBilateral) {
                // Count completed sets per side
                const sideProgress = {};
                sideOptions.forEach(side => sideProgress[side] = 0);
                currentExercise.sessionData.forEach(set => {
                    if (set.side && sideProgress[set.side] !== undefined) {
                        // Set with specific side (left or right)
                        sideProgress[set.side]++;
                    } else if (!set.side) {
                        // Set without side = alternating set, counts for ALL sides
                        sideOptions.forEach(side => sideProgress[side]++);
                    }
                });

                const targetSets = currentExercise.baseSets || 0;

                // Auto-select side that needs more work if currentWorkingSide is 'both'
                if (currentWorkingSide === 'both' || !sideOptions.includes(currentWorkingSide)) {
                    // Find which side needs more sets
                    for (const side of sideOptions) {
                        if (sideProgress[side] < targetSets) {
                            currentWorkingSide = side;
                            break;
                        }
                    }
                    // If both complete or equal, default to first option
                    if (currentWorkingSide === 'both') {
                        currentWorkingSide = sideOptions[0];
                    }
                }

                // Render side buttons
                buttonsContainer.innerHTML = sideOptions.map(side => {
                    const completed = sideProgress[side];
                    const isSelected = currentWorkingSide === side;
                    const isComplete = completed >= targetSets;
                    const emoji = side === 'left' ? 'üëà' : side === 'right' ? 'üëâ' : '';

                    return `
                        <div onclick="selectCurrentSide('${side}')" style="
                            flex: 1;
                            cursor: pointer;
                            padding: 14px 10px;
                            border-radius: 12px;
                            border: 3px solid ${isSelected ? 'var(--ios-blue)' : isComplete ? 'var(--ios-green)' : 'var(--border-color)'};
                            background: ${isSelected ? 'var(--ios-blue)' : isComplete ? 'rgba(52,199,89,0.1)' : 'var(--bg-secondary)'};
                            text-align: center;
                            transition: all 0.2s;
                            ${isSelected ? 'transform: scale(1.05); box-shadow: 0 4px 12px rgba(0,122,255,0.3);' : ''}
                        ">
                            <div style="font-size: 20px; margin-bottom: 2px;">${emoji}</div>
                            <div style="font-size: 15px; font-weight: 700; text-transform: uppercase; color: ${isSelected ? 'white' : 'var(--text-primary)'}; margin-bottom: 4px;">
                                ${side}
                            </div>
                            <div style="font-size: 12px; font-weight: 600; color: ${isSelected ? 'rgba(255,255,255,0.9)' : isComplete ? 'var(--ios-green)' : 'var(--ios-gray)'};">
                                ${completed}/${targetSets} ${isComplete ? '‚úì' : ''}
                            </div>
                        </div>
                    `;
                }).join('');

                selectorContainer.style.display = 'block';
            } else {
                selectorContainer.style.display = 'none';
                currentWorkingSide = 'both';
            }
        }

        function selectCurrentSide(side) {
            currentWorkingSide = side;
            updateCurrentSideSelector();
            haptic('light');
            speak(`Working ${side} side`);
        }

        function showLogSetModal() {
            const targetReps = currentExercise.repsPerSet || 0;
            document.getElementById('log-set-title').textContent = `Log Set ${currentExercise.currentSet}`;

            // Show side selector for unilateral exercises
            const entry = getLibraryEntryById(currentExercise.id);
            const isBilateral = isBilateralPattern(entry.pattern);
            const sideOptions = entry.sideOptions || [];
            const modifiers = entry.pattern_modifiers || [];
            const hasDistance = modifiers.includes('distance_feet');
            const spec = entry.current || {};
            const targetDistance = spec.distanceFeet || 0;

            // Show/hide reps vs distance fields
            const repsField = document.getElementById('log-set-reps');
            const distanceField = document.getElementById('log-set-distance');
            if (hasDistance) {
                repsField.style.display = 'none';
                distanceField.style.display = 'block';
                distanceField.value = targetDistance;
            } else {
                repsField.style.display = 'block';
                distanceField.style.display = 'none';
                repsField.value = targetReps;
            }

            // For sided exercises, show which sides need more sets
            const hasAlternating = entry && (entry.pattern_modifiers || []).includes('alternating');
            let subtitleText = hasDistance
                ? `Target: ${targetDistance}ft ¬∑ Enter actual distance covered`
                : `Target: ${targetReps} reps ¬∑ Enter actual reps performed`;
            if (sideOptions.length > 0 && !isBilateral && currentExercise.baseSets) {
                // Count completed sets per side
                const sideProgress = {};
                sideOptions.forEach(side => sideProgress[side] = 0);
                currentExercise.sessionData.forEach(set => {
                    if (set.side && sideProgress[set.side] !== undefined) {
                        // Set with specific side (left or right)
                        sideProgress[set.side]++;
                    } else if (!set.side) {
                        // Set without side = alternating set, counts for ALL sides
                        sideOptions.forEach(side => sideProgress[side]++);
                    }
                });

                // Find which side needs more sets (for smart default selection)
                let suggestedSide = sideOptions[0];
                for (const side of sideOptions) {
                    if (sideProgress[side] < currentExercise.baseSets) {
                        suggestedSide = side;
                        break;
                    }
                }

                const progressText = sideOptions.map(side =>
                    `${side}: ${sideProgress[side]}/${currentExercise.baseSets}`
                ).join(', ');
                const fieldType = hasDistance ? 'distance' : 'reps';
                subtitleText = `${progressText} ¬∑ Enter ${fieldType} for selected side`;
                if (hasAlternating) {
                    subtitleText += ' ¬∑ ‚ö° ALTERNATE sides each rep';
                }
                logSetSide = suggestedSide;
            } else {
                logSetSide = sideOptions[0] || 'both';
            }

            document.getElementById('log-set-subtitle').textContent = subtitleText;

            // Dynamic form parameters
            const formParams = entry.form_parameters_required || [];
            const formParamsContainer = document.getElementById('log-set-form-params');
            const formParamsFields = document.getElementById('log-set-form-params-fields');

            if (formParams.length > 0) {
                formParamsFields.innerHTML = formParams.map(param => {
                    if (param === 'weight') {
                        return `
                            <label style="font-size: 13px; margin-bottom: 4px; display: block;">${param.replace('_', ' ')}</label>
                            <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                                <input type="number" class="modal-input" id="log-param-${param}" placeholder="Weight" min="0" step="0.5" style="flex: 1; margin: 0;" data-param="${param}">
                                <select class="modal-select" id="log-param-${param}-unit" style="flex: 0 0 auto; width: 80px; margin: 0;">
                                    <option value="lbs">lbs</option>
                                    <option value="kg">kg</option>
                                </select>
                            </div>
                        `;
                    } else if (param === 'distance') {
                        return `
                            <label style="font-size: 13px; margin-bottom: 4px; display: block;">${param} (variable, e.g. step height)</label>
                            <input type="number" class="modal-input" id="log-param-${param}" placeholder="Distance in inches" min="0" style="margin-bottom: 12px;" data-param="${param}">
                        `;
                    } else if (param === 'alternating') {
                        // Skip alternating (pattern modifier, not form param)
                        return '';
                    } else {
                        // Use smart select for all other parameters (band_resistance, eyes, surface, etc.)
                        return renderSmartParamSelect(param, currentExercise.id, `log-param-${param}`);
                    }
                }).join('');
                formParamsContainer.style.display = 'block';
            } else {
                formParamsContainer.style.display = 'none';
            }

            const sideContainer = document.getElementById('log-set-side-selector');
            if (sideOptions.length > 0 && !isBilateral) {
                // Count completed sets per side for progress display
                const sideProgress = {};
                sideOptions.forEach(side => sideProgress[side] = 0);
                currentExercise.sessionData.forEach(set => {
                    if (set.side && sideProgress[set.side] !== undefined) {
                        sideProgress[set.side]++;
                    }
                });

                const targetSets = currentExercise.baseSets || 0;

                sideContainer.innerHTML = '<div style="font-size: 15px; font-weight: 700; margin-bottom: 12px; text-align: center; color: var(--text-primary);">üìç SELECT SIDE FOR THIS SET:</div>' +
                    '<div style="display: flex; gap: 12px;">' +
                    sideOptions.map(side => {
                        const completed = sideProgress[side];
                        const isSelected = logSetSide === side;
                        const isComplete = completed >= targetSets;
                        const emoji = side === 'left' ? 'üëà' : side === 'right' ? 'üëâ' : '';

                        return `
                            <div onclick="selectLogSetSide('${side}')" style="
                                flex: 1;
                                cursor: pointer;
                                padding: 16px 12px;
                                border-radius: 12px;
                                border: 3px solid ${isSelected ? 'var(--ios-blue)' : isComplete ? 'var(--ios-green)' : 'var(--border-color)'};
                                background: ${isSelected ? 'var(--ios-blue)' : isComplete ? 'rgba(52,199,89,0.1)' : 'var(--bg-secondary)'};
                                text-align: center;
                                transition: all 0.2s;
                                ${isSelected ? 'transform: scale(1.05); box-shadow: 0 4px 12px rgba(0,122,255,0.3);' : ''}
                            ">
                                <div style="font-size: 24px; margin-bottom: 4px;">${emoji}</div>
                                <div style="font-size: 16px; font-weight: 700; text-transform: uppercase; color: ${isSelected ? 'white' : 'var(--text-primary)'}; margin-bottom: 6px;">
                                    ${side}
                                </div>
                                <div style="font-size: 13px; font-weight: 600; color: ${isSelected ? 'rgba(255,255,255,0.9)' : isComplete ? 'var(--ios-green)' : 'var(--ios-gray)'};">
                                    ${completed}/${targetSets} sets ${isComplete ? '‚úì' : ''}
                                </div>
                            </div>
                        `;
                    }).join('') +
                    '</div>';
            } else {
                sideContainer.innerHTML = '';
                logSetSide = 'both';
            }

            document.getElementById('log-set-modal').classList.add('active');
            haptic('medium');

            // Auto-focus the correct input field
            setTimeout(() => {
                const fieldToFocus = hasDistance ? distanceField : repsField;
                fieldToFocus.focus();
                fieldToFocus.select();
            }, 300);
        }

        function selectLogSetSide(side) {
            logSetSide = side;
            const entry = getLibraryEntryById(currentExercise.id);
            const sideOptions = entry.sideOptions || [];

            // Count completed sets per side for progress display
            const sideProgress = {};
            sideOptions.forEach(s => sideProgress[s] = 0);
            currentExercise.sessionData.forEach(set => {
                if (set.side && sideProgress[set.side] !== undefined) {
                    sideProgress[set.side]++;
                }
            });

            const targetSets = currentExercise.baseSets || 0;
            const sideContainer = document.getElementById('log-set-side-selector');

            sideContainer.innerHTML = '<div style="font-size: 15px; font-weight: 700; margin-bottom: 12px; text-align: center; color: var(--text-primary);">üìç SELECT SIDE FOR THIS SET:</div>' +
                '<div style="display: flex; gap: 12px;">' +
                sideOptions.map(s => {
                    const completed = sideProgress[s];
                    const isSelected = logSetSide === s;
                    const isComplete = completed >= targetSets;
                    const emoji = s === 'left' ? 'üëà' : s === 'right' ? 'üëâ' : '';

                    return `
                        <div onclick="selectLogSetSide('${s}')" style="
                            flex: 1;
                            cursor: pointer;
                            padding: 16px 12px;
                            border-radius: 12px;
                            border: 3px solid ${isSelected ? 'var(--ios-blue)' : isComplete ? 'var(--ios-green)' : 'var(--border-color)'};
                            background: ${isSelected ? 'var(--ios-blue)' : isComplete ? 'rgba(52,199,89,0.1)' : 'var(--bg-secondary)'};
                            text-align: center;
                            transition: all 0.2s;
                            ${isSelected ? 'transform: scale(1.05); box-shadow: 0 4px 12px rgba(0,122,255,0.3);' : ''}
                        ">
                            <div style="font-size: 24px; margin-bottom: 4px;">${emoji}</div>
                            <div style="font-size: 16px; font-weight: 700; text-transform: uppercase; color: ${isSelected ? 'white' : 'var(--text-primary)'}; margin-bottom: 6px;">
                                ${s}
                            </div>
                            <div style="font-size: 13px; font-weight: 600; color: ${isSelected ? 'rgba(255,255,255,0.9)' : isComplete ? 'var(--ios-green)' : 'var(--ios-gray)'};">
                                ${completed}/${targetSets} sets ${isComplete ? '‚úì' : ''}
                            </div>
                        </div>
                    `;
                }).join('') +
                '</div>';

            haptic('light');
        }

        function closeLogSetModal() {
            document.getElementById('log-set-modal').classList.remove('active');
            haptic('medium');
        }

        function saveLoggedSet() {
            const entry = getLibraryEntryById(currentExercise.id);
            const modifiers = entry.pattern_modifiers || [];
            const hasDistance = modifiers.includes('distance_feet');

            let reps, distance, logMessage;

            if (hasDistance) {
                distance = parseInt(document.getElementById('log-set-distance').value);
                if (isNaN(distance) || distance < 0) {
                    alert('Please enter a valid distance (0 or more feet).');
                    return;
                }
                reps = 1; // Set to 1 for data structure, but not used
                logMessage = `Set ${currentExercise.currentSet} logged: ${distance}ft`;
            } else {
                reps = parseInt(document.getElementById('log-set-reps').value);
                if (isNaN(reps) || reps < 0) {
                    alert('Please enter a valid number of reps (0 or more).');
                    return;
                }
                logMessage = `Set ${currentExercise.currentSet} logged: ${reps} reps`;
            }

            const setData = {
                set: currentExercise.currentSet,
                reps: reps,
                type: currentExercise.type,
                timestamp: new Date().toISOString(),
                manualLog: true
            };

            // Add distance if applicable
            if (hasDistance && distance > 0) {
                setData.distanceFeet = distance;
            }

            // Add side if applicable
            if (logSetSide && logSetSide !== 'both') {
                setData.side = logSetSide;
            }

            // Add dynamic form parameters
            const formParams = entry.form_parameters_required || [];
            const formParamsData = {};
            formParams.forEach(param => {
                if (param === 'alternating') return; // Skip alternating (will be in pattern_modifiers)

                const inputElement = document.getElementById(`log-param-${param}`);
                if (!inputElement) return;

                let value = inputElement.value;
                if (param === 'weight' && value) {
                    const weightValue = parseFloat(value);
                    if (!isNaN(weightValue) && weightValue > 0) {
                        const unitElement = document.getElementById(`log-param-${param}-unit`);
                        formParamsData[param] = weightValue;
                        formParamsData[`${param}_unit`] = unitElement ? unitElement.value : 'lbs';
                    }
                } else if (param === 'distance' && value) {
                    const distValue = parseFloat(value);
                    if (!isNaN(distValue) && distValue > 0) {
                        formParamsData[param] = distValue;
                    }
                } else if (value && value !== '') {
                    formParamsData[param] = value;
                }
            });

            if (Object.keys(formParamsData).length > 0) {
                setData.formParams = formParamsData;
            }

            currentExercise.sessionData.push(setData);

            closeLogSetModal();
            haptic('success');
            speak(logMessage);

            // Check for progress
            detectProgress(currentExercise.currentSet, hasDistance ? distance : reps);

            if (currentExercise.currentSet < currentExercise.sets) {
                currentExercise.currentSet++;
                currentExercise.currentRep = 0;
                seedTimerSeconds();
                stopTimer();
                updateDisplay();
            } else {
                speak('All sets complete');
                showSessionNotesModal();
            }
        }

        // Smart Progress Detection
        function detectProgress(setNumber, reps) {
            const sessions = loadHistory();
            const previousSessions = sessions.filter(s => s.exerciseId === currentExercise.id);

            if (previousSessions.length === 0) return; // First time doing this exercise

            const lastSession = previousSessions[previousSessions.length - 1];
            const lastSetReps = lastSession.sets && lastSession.sets[setNumber - 1]?.reps;

            if (!lastSetReps) return; // No comparison data

            const diff = reps - lastSetReps;

            if (diff > 0) {
                setTimeout(() => {
                    speak(`${diff} more rep${diff > 1 ? 's' : ''} than last time!`);
                    haptic('success');
                }, 1500);
            } else if (diff < 0 && Math.abs(diff) > 2) {
                // Only mention if significantly fewer (more than 2 reps)
                setTimeout(() => {
                    speak(`${Math.abs(diff)} fewer reps than last time`);
                }, 1500);
            }
        }

        function previousSet() {
            if (currentExercise.currentSet > 1) {
                currentExercise.currentSet--;
                currentExercise.currentRep = 0;
                seedTimerSeconds();
                stopTimer();
                haptic('medium');
                updateDisplay();
            }
        }

        // Form Parameters Modal (shown after completing all sets)
        let sessionFormParams = {}; // Store form parameters for the session

        // Parse value and unit from strings like "10 lbs", "45 degrees", "5.5 kg"
        function parseValueAndUnit(str) {
            if (!str) return { value: '', unit: '' };
            const match = String(str).match(/^([\d.]+)\s*(.*)$/);
            if (match) {
                return { value: match[1], unit: match[2].trim() };
            }
            return { value: '', unit: str };
        }

        // Detect if parameter values are numeric based on historical data
        function isNumericParameter(exerciseId, paramName, side = null) {
            const historicalValues = getHistoricalParamValues(exerciseId, paramName, side);
            if (historicalValues.length === 0) return false;

            // Check if most values parse as numbers
            const numericCount = historicalValues.filter(val => {
                const { value } = parseValueAndUnit(val);
                return !isNaN(parseFloat(value));
            }).length;

            return numericCount > 0;
        }

        // Get available units from historical data
        function getHistoricalUnits(exerciseId, paramName, side = null) {
            const historicalValues = getHistoricalParamValues(exerciseId, paramName, side);
            const units = new Set();

            historicalValues.forEach(val => {
                const { unit } = parseValueAndUnit(val);
                if (unit) units.add(unit);
            });

            return Array.from(units);
        }

        function showFormParamsModal() {
            const entry = getLibraryEntryById(currentExercise.id);
            const formParams = entry?.form_parameters_required || [];
            const fieldsContainer = document.getElementById('form-params-fields');

            // Common units offered for any numeric parameter
            const commonUnits = ['lbs', 'kg', 'in', 'ft', 'cm', 'm', 'degrees', '%'];

            // Detect which sides were used in this session
            const sidesUsed = [...new Set(currentExercise.sessionData.map(s => s.side).filter(Boolean))];
            const isSided = sidesUsed.length > 0;

            // Build form fields dynamically
            if (isSided) {
                // For sided exercises, prompt parameters for each side
                fieldsContainer.innerHTML = sidesUsed.map(side => {
                    const sideLabel = side.charAt(0).toUpperCase() + side.slice(1);
                    const sideFields = formParams.map(param => {
                        const historicalValues = getHistoricalParamValues(currentExercise.id, param, side);
                        const lastUsed = getLastUsedParamValue(currentExercise.id, param, side);
                        const isNumeric = isNumericParameter(currentExercise.id, param, side);
                        const label = param.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

                        // For numeric parameters, use input + unit selector
                        if (isNumeric) {
                            const historicalUnits = getHistoricalUnits(currentExercise.id, param, side);
                            const allUnits = [...new Set([...historicalUnits, ...commonUnits])];
                            const { value: defaultValue, unit: defaultUnit } = parseValueAndUnit(lastUsed);
                            const selectedUnit = defaultUnit || allUnits[0] || '';

                            return `
                                <label style="font-size: 13px; font-weight: 500; margin-bottom: 4px; display: block; color: var(--text-secondary);">${label}</label>
                                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                                    <input type="number" class="modal-input" id="session-param-${side}-${param}" placeholder="${label}" min="0" step="0.5" value="${defaultValue}" style="flex: 1; margin: 0;" data-param="${param}" data-side="${side}">
                                    <select class="modal-select" id="session-param-${side}-${param}-unit" style="flex: 0 0 auto; width: 90px; margin: 0;">
                                        ${allUnits.map(unit => `<option value="${unit}" ${unit === selectedUnit ? 'selected' : ''}>${unit}</option>`).join('')}
                                    </select>
                                </div>
                            `;
                        } else {
                            return `
                                <label style="font-size: 13px; font-weight: 500; margin-bottom: 4px; display: block; color: var(--text-secondary);">${label}</label>
                                <input type="text" class="modal-input" id="session-param-${side}-${param}" placeholder="Enter ${label.toLowerCase()}" value="${lastUsed || ''}" list="datalist-${side}-${param}" style="margin-bottom: 12px;" data-param="${param}" data-side="${side}">
                                <datalist id="datalist-${side}-${param}">
                                    ${historicalValues.map(val => `<option value="${val}"></option>`).join('')}
                                </datalist>
                            `;
                        }
                    }).join('');

                    return `
                        <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 8px; margin-bottom: 12px;">
                            <div style="font-size: 15px; font-weight: 700; margin-bottom: 12px; color: var(--ios-blue);">${sideLabel} Side</div>
                            ${sideFields}
                        </div>
                    `;
                }).join('');
            } else {
                // For bilateral/non-sided exercises, use single set of fields
                fieldsContainer.innerHTML = formParams.map(param => {
                    const historicalValues = getHistoricalParamValues(currentExercise.id, param);
                    const lastUsed = getLastUsedParamValue(currentExercise.id, param);
                    const isNumeric = isNumericParameter(currentExercise.id, param);
                    const label = param.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

                    // For numeric parameters, use input + unit selector
                    if (isNumeric) {
                        const historicalUnits = getHistoricalUnits(currentExercise.id, param);
                        const allUnits = [...new Set([...historicalUnits, ...commonUnits])];
                        const { value: defaultValue, unit: defaultUnit } = parseValueAndUnit(lastUsed);
                        const selectedUnit = defaultUnit || allUnits[0] || '';

                        return `
                            <label style="font-size: 14px; font-weight: 600; margin-bottom: 6px; display: block;">${label}</label>
                            <div style="display: flex; gap: 8px; margin-bottom: 16px;">
                                <input type="number" class="modal-input" id="session-param-${param}" placeholder="${label}" min="0" step="0.5" value="${defaultValue}" style="flex: 1; margin: 0;" data-param="${param}">
                                <select class="modal-select" id="session-param-${param}-unit" style="flex: 0 0 auto; width: 90px; margin: 0;">
                                    ${allUnits.map(unit => `<option value="${unit}" ${unit === selectedUnit ? 'selected' : ''}>${unit}</option>`).join('')}
                                </select>
                            </div>
                            <datalist id="datalist-${param}">
                                ${historicalValues.map(val => `<option value="${val}"></option>`).join('')}
                            </datalist>
                        `;
                    } else {
                        // For non-numeric parameters, use datalist input
                        return `
                            <label style="font-size: 14px; font-weight: 600; margin-bottom: 6px; display: block;">${label}</label>
                            <input type="text" class="modal-input" id="session-param-${param}" placeholder="Enter ${label.toLowerCase()}" value="${lastUsed || ''}" list="datalist-${param}" style="margin-bottom: 16px;" data-param="${param}">
                            <datalist id="datalist-${param}">
                                ${historicalValues.map(val => `<option value="${val}"></option>`).join('')}
                            </datalist>
                        `;
                    }
                }).join('');
            }

            document.getElementById('form-params-modal').classList.add('active');
            haptic('medium');
        }

        function closeFormParamsModal() {
            document.getElementById('form-params-modal').classList.remove('active');
            haptic('medium');
        }

        function skipFormParams() {
            sessionFormParams = {};
            closeFormParamsModal();
            showSessionNotesModal();
        }

        function saveFormParams() {
            const entry = getLibraryEntryById(currentExercise.id);
            const formParams = entry?.form_parameters_required || [];

            // Collect all input elements with data-param attribute
            const paramInputs = document.querySelectorAll('[data-param]');
            const paramsBySide = {}; // { side: { param: value } } or { null: { param: value } }

            paramInputs.forEach(inputElement => {
                const param = inputElement.getAttribute('data-param');
                const side = inputElement.getAttribute('data-side'); // null for bilateral
                const value = inputElement.value.trim();
                if (!value || value === '') return;

                // Check if there's a unit selector for this parameter
                const elementId = inputElement.id;
                const unitElement = document.getElementById(`${elementId}-unit`);
                const finalValue = unitElement ? `${value} ${unitElement.value}` : value;

                // Group by side
                const sideKey = side || 'bilateral';
                if (!paramsBySide[sideKey]) {
                    paramsBySide[sideKey] = {};
                }
                paramsBySide[sideKey][param] = finalValue;
            });

            // Apply form parameters to sets based on their side
            currentExercise.sessionData.forEach(set => {
                const setSide = set.side || 'bilateral';
                if (paramsBySide[setSide]) {
                    set.formParams = { ...paramsBySide[setSide] };
                }
            });

            closeFormParamsModal();
            showSessionNotesModal();
        }

        function showSessionNotesModal() {
            document.getElementById('session-notes').value = '';
            document.getElementById('session-notes-modal').classList.add('active');
            haptic('medium');
        }

        function closeSessionNotesModal() {
            document.getElementById('session-notes-modal').classList.remove('active');
            haptic('medium');
        }

        function confirmSkipNotes() {
            const setsLogged = currentExercise.sessionData.length;
            const message = `‚úì Save exercise without notes?\n\n${setsLogged} set${setsLogged !== 1 ? 's' : ''} will be saved to your history.\n\nYou can add notes later if needed.`;

            showActionSheet(message, () => {
                saveSessionWithNotes('');
            });
        }

        function saveSessionWithNotes(notes) {
            const finalizedSession = {
                sessionId: currentSessionId,
                exerciseId: currentExercise.id,
                exerciseName: currentExercise.name,
                exerciseType: currentExercise.type,
                date: new Date().toISOString(),
                notes: notes.trim(),
                exerciseSpec: {
                    sets: currentExercise.sets,
                    repsPerSet: currentExercise.repsPerSet,
                    secondsPerRep: currentExercise.secondsPerRep,
                    type: currentExercise.type
                },
                sets: currentExercise.sessionData
            };
            addSessionToCache(finalizedSession);
            enqueueFirestoreSession(finalizedSession);
            void syncRuntimeToFirestore();

            // Write finalized session to Firestore (user-scoped)
            try {
                if (currentUser) {
                    // User is authenticated - attempt direct write
                    addDoc(collection(db, `users/${currentUser.uid}/sessions`), sanitizeSessionForFirestore(finalizedSession))
                        .then(() => {
                            console.log('[Firestore] Session synced immediately:', finalizedSession.sessionId);
                            removeQueuedSession(finalizedSession);
                        })
                        .catch((error) => {
                            console.error('[Firestore] Write failed, queueing session:', error);
                        });
                } else {
                    // Not authenticated - queue for later
                    console.log('[Firestore] Not authenticated, queueing session');
                }
            } catch (error) {
                console.error('[Firestore] Error preparing write:', error);
                // Do not throw - allow localStorage flow to continue
            }

            haptic('success');
            closeSessionNotesModal();

            // Mark exercise as completed in session plan
            if (sessionPlan.includes(currentExercise.id)) {
                sessionPlanCompleted.add(currentExercise.id);
                updateSessionPlanDisplay();

                // Auto-advance to next exercise in plan
                const nextExercise = getNextPlannedExercise();
                if (nextExercise) {
                    currentExercise = toSessionExercise(nextExercise);
                    localStorage.setItem(LAST_EXERCISE_KEY, nextExercise.id);
                    seedTimerSeconds();
                    updateDisplay();
                    speak(`Next: ${nextExercise.name}`);
                    return;
                }
            }

            // Reset for new session
            currentExercise.currentSet = 1;
            currentExercise.currentRep = 0;
            currentExercise.sessionData = [];
            seedTimerSeconds();
            stopTimer();
            updateDisplay();
            updateStreakDisplay(); // Refresh streak after completing session
            // updateQuickStartShortcuts(); // REMOVED: Quick Start section removed
        }

        function updateQuickStartShortcuts() {
            const sessions = loadHistory();
            const container = document.getElementById('quick-start-container');
            const exercisesContainer = document.getElementById('quick-start-exercises');

            if (sessions.length === 0 || exerciseLibrary.length === 0) {
                container.style.display = 'none';
                return;
            }

            // Count exercise usage in last 30 days
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

            const usageCount = {};
            sessions.forEach(session => {
                const sessionDate = new Date(session.date);
                if (sessionDate >= thirtyDaysAgo) {
                    usageCount[session.exerciseId] = (usageCount[session.exerciseId] || 0) + 1;
                }
            });

            // Sort by usage and get top 5
            const sortedExercises = Object.entries(usageCount)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([id]) => id);

            if (sortedExercises.length === 0) {
                container.style.display = 'none';
                return;
            }

            // Render shortcuts
            exercisesContainer.innerHTML = sortedExercises.map(id => {
                const entry = getLibraryEntryById(id);
                if (!entry || entry.archived) return '';
                return `<button class="pill" style="cursor: pointer; padding: 8px 14px; background: var(--ios-blue); color: white; font-weight: 500; white-space: normal; word-wrap: break-word; text-align: left; line-height: 1.4;" onclick="quickStartExercise('${id}')">${entry.name}</button>`;
            }).filter(Boolean).join('');

            container.style.display = exercisesContainer.innerHTML ? 'block' : 'none';
        }

        function quickStartExercise(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            if (!entry) return;

            currentExercise = toSessionExercise(entry);
            localStorage.setItem(LAST_EXERCISE_KEY, exerciseId);
            seedTimerSeconds();
            updateDisplay();
            haptic('medium');
            speak(`Starting ${entry.name}`);
        }

        // Session Planning Functions
        function showPlanSessionModal() {
            closeExerciseList();
            renderPlanSessionList();
            document.getElementById('plan-session-modal').classList.add('active');
            haptic('medium');
        }

        function closePlanSessionModal() {
            document.getElementById('plan-session-modal').classList.remove('active');
            haptic('medium');
        }

        function renderPlanSessionList() {
            const container = document.getElementById('plan-session-list');
            const activeExercises = exerciseLibrary.filter(ex => !ex.archived);

            if (activeExercises.length === 0) {
                container.innerHTML = '<div class="history-item">No exercises available. Add some first!</div>';
                return;
            }

            container.innerHTML = activeExercises.map(ex => {
                const spec = ex.current || {};
                const isSelected = sessionPlan.includes(ex.id);
                return `
                    <div class="history-item" onclick="toggleExerciseInPlan('${ex.id}')" style="cursor: pointer; background: ${isSelected ? 'rgba(0,122,255,0.1)' : 'transparent'}; border: 2px solid ${isSelected ? 'var(--ios-blue)' : 'transparent'};">
                        <div style="display: flex; align-items: center; justify-content: space-between;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600;">${ex.name}</div>
                                <div class="history-meta">${describeSpec(spec)}</div>
                            </div>
                            <div style="font-size: 20px; margin-left: 12px;">${isSelected ? '‚úì' : ''}</div>
                        </div>
                    </div>
                `;
            }).join('');

            // Update button state
            const btn = document.getElementById('start-session-btn');
            btn.disabled = sessionPlan.length === 0;
            btn.style.opacity = sessionPlan.length === 0 ? '0.5' : '1';
        }

        function toggleExerciseInPlan(exerciseId) {
            const index = sessionPlan.indexOf(exerciseId);
            if (index > -1) {
                sessionPlan.splice(index, 1);
            } else {
                sessionPlan.push(exerciseId);
            }
            renderPlanSessionList();
            haptic('light');
        }

        function startPlannedSession() {
            if (sessionPlan.length === 0) return;

            sessionPlanCompleted.clear();
            closePlanSessionModal();

            // Start with first exercise in plan
            const firstExercise = getLibraryEntryById(sessionPlan[0]);
            if (firstExercise) {
                currentExercise = toSessionExercise(firstExercise);
                localStorage.setItem(LAST_EXERCISE_KEY, firstExercise.id);
                seedTimerSeconds();
                updateDisplay();
                updateSessionPlanDisplay();
                speak(`Starting session: ${firstExercise.name}`);
                haptic('success');
            }
        }

        function updateSessionPlanDisplay() {
            const container = document.getElementById('session-plan-container');
            const listContainer = document.getElementById('session-plan-list');

            if (sessionPlan.length === 0) {
                container.style.display = 'none';
                return;
            }

            const planItems = sessionPlan.map(id => {
                const entry = getLibraryEntryById(id);
                if (!entry) return '';

                const isCompleted = sessionPlanCompleted.has(id);
                const isCurrent = currentExercise && currentExercise.id === id;

                return `
                    <div onclick="switchToPlannedExercise('${id}')" style="padding: 8px 12px; border-radius: 8px; background: ${isCurrent ? 'var(--ios-blue)' : isCompleted ? 'var(--ios-green)' : 'var(--bg-primary)'}; color: ${isCurrent || isCompleted ? 'white' : 'var(--text-primary)'}; cursor: pointer; display: flex; align-items: center; gap: 8px; ${isCompleted ? 'opacity: 0.7;' : ''}">
                        <div style="font-size: 16px;">${isCompleted ? '‚úì' : isCurrent ? '‚ñ∂' : '‚óã'}</div>
                        <div style="flex: 1; font-size: 14px; font-weight: ${isCurrent ? '600' : '500'};">${entry.name}</div>
                    </div>
                `;
            }).filter(Boolean).join('');

            listContainer.innerHTML = planItems;
            container.style.display = 'block';
        }

        function switchToPlannedExercise(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            if (!entry) return;

            // Save current progress if switching mid-exercise
            if (currentExercise && currentExercise.sessionData.length > 0) {
                if (!confirm('Switch exercises? Current progress will be lost.')) {
                    return;
                }
            }

            currentExercise = toSessionExercise(entry);
            localStorage.setItem(LAST_EXERCISE_KEY, exerciseId);
            seedTimerSeconds();
            updateDisplay();
            updateSessionPlanDisplay();
            haptic('medium');
            speak(`Switched to ${entry.name}`);
        }

        function getNextPlannedExercise() {
            const remaining = sessionPlan.filter(id => !sessionPlanCompleted.has(id));
            if (remaining.length === 0) return null;
            return getLibraryEntryById(remaining[0]);
        }

        function endSessionEarly() {
            const completed = sessionPlanCompleted.size;
            const total = sessionPlan.length;
            const message = `End session early?\n\nCompleted: ${completed}/${total} exercises\n\nSession plan will be cleared.`;

            showActionSheet(message, () => {
                sessionPlan = [];
                sessionPlanCompleted.clear();
                updateSessionPlanDisplay();
                haptic('medium');
                speak('Session ended');
            });
        }

        // All Sessions Functions
        function showAllSessions() {
            closeWeeklyStats();
            const sessions = loadHistory();

            console.log('[All Sessions] Total sessions loaded:', sessions.length);

            // Group by sessionId
            const sessionGroups = {};
            sessions.forEach(session => {
                const sid = session.sessionId || 'unknown';
                if (!sessionGroups[sid]) {
                    sessionGroups[sid] = [];
                }
                sessionGroups[sid].push(session);
            });

            console.log('[All Sessions] Unique workout sessions:', Object.keys(sessionGroups).length);

            // Sort session groups by date (most recent first)
            const sortedGroups = Object.entries(sessionGroups).sort((a, b) => {
                const aDate = new Date(a[1][0].date);
                const bDate = new Date(b[1][0].date);
                return bDate - aDate;
            });

            const container = document.getElementById('all-sessions-list');

            if (sortedGroups.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">No sessions recorded yet.</div>';
            } else {
                container.innerHTML = sortedGroups.map(([sessionId, exercises]) => {
                    const sessionDate = new Date(exercises[0].date);
                    const totalExercises = exercises.length;
                    const totalSets = exercises.reduce((sum, ex) => sum + (ex.sets?.length || 0), 0);
                    const totalReps = exercises.reduce((sum, ex) => sum + ex.sets.reduce((rs, set) => rs + (set.reps || 0), 0), 0);

                    // Check if this is today's session
                    const isToday = sessionDate.toDateString() === new Date().toDateString();

                    return `
                        <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 12px; ${isToday ? 'border: 2px solid var(--ios-blue);' : ''}">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <div>
                                    <div style="font-weight: 600; font-size: 15px;">
                                        ${sessionDate.toLocaleDateString()}
                                        ${isToday ? '<span style="color: var(--ios-blue); margin-left: 8px;">‚Ä¢ Today</span>' : ''}
                                    </div>
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-top: 2px;">
                                        ${sessionDate.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}
                                    </div>
                                </div>
                                <div style="text-align: right; font-size: 12px; color: var(--text-secondary);">
                                    <div>${totalExercises} exercise${totalExercises !== 1 ? 's' : ''}</div>
                                    <div>${totalSets} sets ¬∑ ${totalReps} reps</div>
                                </div>
                            </div>
                            <div style="border-top: 1px solid var(--border-color); padding-top: 8px;">
                                ${exercises.map(ex => {
                                    const exTotalReps = ex.sets.reduce((sum, set) => sum + (set.reps || 0), 0);
                                    const avgReps = (exTotalReps / ex.sets.length).toFixed(1);
                                    return `
                                        <div style="padding: 6px 0; border-bottom: 1px solid rgba(0,0,0,0.05); cursor: pointer;" onclick="showExerciseProgress('${ex.exerciseId}')">
                                            <div style="font-weight: 600; font-size: 13px; margin-bottom: 2px;">${ex.exerciseName}</div>
                                            <div style="font-size: 11px; color: var(--text-secondary);">
                                                ${ex.sets.length} sets √ó ${avgReps} avg = ${exTotalReps} total reps
                                            </div>
                                            ${ex.notes ? `<div style="font-size: 11px; color: var(--ios-gray); margin-top: 2px; font-style: italic;">"${ex.notes}"</div>` : ''}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }).join('');
            }

            document.getElementById('all-sessions-modal').classList.add('active');
            haptic('medium');
        }

        function closeAllSessions() {
            document.getElementById('all-sessions-modal').classList.remove('active');
            haptic('medium');
        }

        // Weekly Stats Functions (Rolling 7-Day Window)
        function showWeeklyStats() {
            const sessions = loadHistory();
            const now = new Date();
            const sevenDaysAgo = new Date(now - (7 * 24 * 60 * 60 * 1000));
            sevenDaysAgo.setHours(0, 0, 0, 0);

            const weekSessions = sessions.filter(s => new Date(s.date) >= sevenDaysAgo);

            // Debug logging
            console.log('[Weekly Stats] Total sessions in history:', sessions.length);
            console.log('[Weekly Stats] Rolling 7 days starts:', sevenDaysAgo.toLocaleString());
            console.log('[Weekly Stats] Sessions in last 7 days:', weekSessions.length);
            if (weekSessions.length > 0) {
                console.log('[Weekly Stats] Session dates:', weekSessions.map(s => new Date(s.date).toLocaleString()));
            }

            renderWeeklyOverview(weekSessions, sevenDaysAgo);
            renderWeeklyVolumeChart(sessions);
            renderWeeklyExercises(weekSessions);
            renderWeeklyAdherence(sessions);

            document.getElementById('weekly-stats-modal').classList.add('active');
            haptic('medium');
        }

        function closeWeeklyStats() {
            document.getElementById('weekly-stats-modal').classList.remove('active');
            haptic('medium');
        }

        function renderWeeklyOverview(weekSessions, startOfWeek) {
            const container = document.getElementById('weekly-overview');

            const totalSessions = weekSessions.length;
            const uniqueExercises = new Set(weekSessions.map(s => s.exerciseId)).size;
            const totalSets = weekSessions.reduce((sum, s) => sum + (s.sets?.length || 0), 0);
            const totalReps = weekSessions.reduce((sum, s) => sum + s.sets.reduce((rs, set) => rs + (set.reps || 0), 0), 0);

            // Days trained in rolling 7-day window
            const daysWithSessions = new Set(weekSessions.map(s => new Date(s.date).toDateString())).size;

            const today = new Date();

            container.innerHTML = `
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="font-weight: 600; font-size: 15px; margin-bottom: 4px; color: var(--ios-blue);">
                        Last 7 Days (Rolling)
                    </div>
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 12px;">
                        ${startOfWeek.toLocaleDateString()} - ${today.toLocaleDateString()}
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; font-size: 13px;">
                        <div>
                            <div style="color: var(--text-secondary); font-size: 11px;">Sessions</div>
                            <div style="font-size: 24px; font-weight: 700;">${totalSessions}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 11px;">Days Trained</div>
                            <div style="font-size: 24px; font-weight: 700;">${daysWithSessions}<span style="font-size: 14px;">/7</span></div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 11px;">Total Volume</div>
                            <div style="font-size: 24px; font-weight: 700;">${totalReps}<span style="font-size: 14px;"> reps</span></div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 11px;">Exercises</div>
                            <div style="font-size: 24px; font-weight: 700;">${uniqueExercises}</div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderWeeklyVolumeChart(allSessions) {
            const container = document.getElementById('weekly-volume-chart');

            // Calculate volume for past 8 weeks
            const weeks = [];
            for (let i = 7; i >= 0; i--) {
                const weekStart = new Date();
                weekStart.setDate(weekStart.getDate() - weekStart.getDay() - (i * 7));
                weekStart.setHours(0, 0, 0, 0);

                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekStart.getDate() + 7);

                const weekSessions = allSessions.filter(s => {
                    const sessionDate = new Date(s.date);
                    return sessionDate >= weekStart && sessionDate < weekEnd;
                });

                const totalReps = weekSessions.reduce((sum, s) => sum + s.sets.reduce((rs, set) => rs + (set.reps || 0), 0), 0);
                const totalSets = weekSessions.reduce((sum, s) => sum + s.sets.length, 0);

                weeks.push({
                    label: i === 0 ? 'This week' : `${i}w ago`,
                    date: weekStart.toLocaleDateString([], {month: 'short', day: 'numeric'}),
                    reps: totalReps,
                    sets: totalSets,
                    sessions: weekSessions.length
                });
            }

            const maxReps = Math.max(...weeks.map(w => w.reps), 1);

            container.innerHTML = `
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px; color: var(--ios-blue);">Volume Trend (8 Weeks)</div>
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        ${weeks.map(week => {
                            const barWidth = (week.reps / maxReps * 100).toFixed(1);
                            const color = week.reps > 0 ? 'var(--ios-blue)' : 'var(--ios-gray)';
                            return `
                                <div style="display: flex; align-items: center; gap: 8px; font-size: 12px;">
                                    <div style="width: 60px; color: var(--text-secondary); flex-shrink: 0; font-size: 11px;">${week.date}</div>
                                    <div style="flex: 1; background: rgba(0,122,255,0.1); border-radius: 4px; height: 28px; position: relative;">
                                        <div style="background: ${color}; border-radius: 4px; height: 100%; width: ${barWidth}%; transition: width 0.3s;"></div>
                                        <div style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); font-weight: 600; color: var(--text-primary); font-size: 11px;">
                                            ${week.reps > 0 ? `${week.reps} reps` : '‚Äî'}
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); font-size: 11px; color: var(--text-secondary); text-align: center;">
                        Total weekly volume helps PTs monitor training load progression
                    </div>
                </div>
            `;
        }

        function renderWeeklyExercises(weekSessions) {
            const container = document.getElementById('weekly-exercises');

            if (weekSessions.length === 0) {
                container.innerHTML = `
                    <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 16px; text-align: center; color: var(--text-secondary);">
                        No sessions in the last 7 days. Start training!
                    </div>
                `;
                return;
            }

            // Group by exercise
            const exerciseGroups = {};
            weekSessions.forEach(session => {
                const exId = session.exerciseId;
                if (!exerciseGroups[exId]) {
                    exerciseGroups[exId] = {
                        name: session.exerciseName,
                        sessions: [],
                        totalReps: 0,
                        totalSets: 0
                    };
                }
                exerciseGroups[exId].sessions.push(session);
                exerciseGroups[exId].totalSets += session.sets.length;
                exerciseGroups[exId].totalReps += session.sets.reduce((sum, set) => sum + (set.reps || 0), 0);
            });

            const sortedExercises = Object.entries(exerciseGroups).sort((a, b) => b[1].sessions.length - a[1].sessions.length);

            container.innerHTML = `
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px; color: var(--ios-blue);">Exercises (Last 7 Days)</div>
                    ${sortedExercises.map(([exId, group]) => `
                        <div style="padding: 8px; border-bottom: 1px solid var(--border-color); cursor: pointer;" onclick="showExerciseProgress('${exId}')">
                            <div style="font-weight: 600; font-size: 14px; margin-bottom: 4px;">${group.name}</div>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                ${group.sessions.length}√ó sessions ¬∑ ${group.totalSets} sets ¬∑ ${group.totalReps} reps
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function renderWeeklyAdherence(allSessions) {
            const container = document.getElementById('weekly-adherence');

            // Last 4 weeks
            const weeks = [];
            for (let i = 0; i < 4; i++) {
                const weekStart = new Date();
                weekStart.setDate(weekStart.getDate() - weekStart.getDay() - (i * 7));
                weekStart.setHours(0, 0, 0, 0);

                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekStart.getDate() + 7);

                const weekSessions = allSessions.filter(s => {
                    const sessionDate = new Date(s.date);
                    return sessionDate >= weekStart && sessionDate < weekEnd;
                });

                const daysWithSessions = new Set(weekSessions.map(s => new Date(s.date).toDateString())).size;

                weeks.push({
                    label: i === 0 ? 'This week' : `${i} week${i > 1 ? 's' : ''} ago`,
                    sessions: weekSessions.length,
                    days: daysWithSessions
                });
            }

            weeks.reverse();

            container.innerHTML = `
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px;">
                    <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px; color: var(--ios-blue);">Adherence Trend</div>
                    ${weeks.map(week => {
                        const barWidth = (week.days / 7 * 100).toFixed(1);
                        const color = week.days >= 3 ? 'var(--ios-green)' : week.days >= 1 ? 'var(--ios-orange)' : 'var(--ios-gray)';
                        return `
                            <div style="margin-bottom: 12px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; font-size: 12px;">
                                    <div style="color: var(--text-secondary);">${week.label}</div>
                                    <div style="font-weight: 600;">${week.days} day${week.days !== 1 ? 's' : ''} ¬∑ ${week.sessions} sessions</div>
                                </div>
                                <div style="background: rgba(0,122,255,0.1); border-radius: 4px; height: 20px; position: relative;">
                                    <div style="background: ${color}; border-radius: 4px; height: 100%; width: ${barWidth}%; transition: width 0.3s;"></div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                    <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--border-color); font-size: 12px; color: var(--text-secondary); text-align: center;">
                        Aim for 3-5 training days per week for best results
                    </div>
                </div>
            `;
        }

        // Exercise Progress Tracking Functions
        function showExerciseProgress(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            if (!entry) return;

            const sessions = loadHistory();
            const exerciseSessions = sessions.filter(s => s.exerciseId === exerciseId || s.exerciseName === entry.name);

            if (exerciseSessions.length === 0) {
                alert('No sessions recorded yet for this exercise.');
                return;
            }

            document.getElementById('progress-modal-title').textContent = `${entry.name} - Progress`;
            renderProgressSummary(entry, exerciseSessions);
            renderProgressChart(exerciseSessions);
            renderProgressSessions(exerciseSessions);

            document.getElementById('exercise-progress-modal').classList.add('active');
            haptic('medium');
        }

        function closeExerciseProgress() {
            document.getElementById('exercise-progress-modal').classList.remove('active');
            haptic('medium');
        }

        function renderProgressSummary(entry, sessions) {
            const container = document.getElementById('progress-summary');

            const totalSessions = sessions.length;
            const allSets = sessions.flatMap(s => s.sets);
            const totalSets = allSets.length;

            // Check if this is a distance-based exercise
            const hasDistance = allSets.some(set => set.distanceFeet);
            let volumeMetric, avgMetric;

            if (hasDistance) {
                const totalDistance = allSets.reduce((sum, set) => sum + (set.distanceFeet || 0), 0);
                const avgDistance = (totalDistance / totalSets).toFixed(1);
                volumeMetric = `${totalDistance} ft`;
                avgMetric = `${avgDistance} ft`;
            } else {
                const totalReps = allSets.reduce((sum, set) => sum + (set.reps || 0), 0);
                const avgReps = (totalReps / totalSets).toFixed(1);
                volumeMetric = `${totalReps} reps`;
                avgMetric = `${avgReps} reps`;
            }

            // First vs last comparison
            const firstSession = sessions[0];
            const lastSession = sessions[sessions.length - 1];
            const firstAvgReps = firstSession.sets.reduce((sum, set) => sum + (set.reps || 0), 0) / firstSession.sets.length;
            const lastAvgReps = lastSession.sets.reduce((sum, set) => sum + (set.reps || 0), 0) / lastSession.sets.length;
            const improvement = ((lastAvgReps - firstAvgReps) / firstAvgReps * 100).toFixed(1);
            const improvementColor = improvement >= 0 ? 'var(--ios-green)' : 'var(--ios-red)';

            // Frequency
            const firstDate = new Date(firstSession.date);
            const lastDate = new Date(lastSession.date);
            const daySpan = Math.ceil((lastDate - firstDate) / (1000 * 60 * 60 * 24)) || 1;
            const sessionsPerWeek = ((totalSessions / daySpan) * 7).toFixed(1);

            container.innerHTML = `
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px;">
                    <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px; color: var(--ios-blue);">Summary</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 13px;">
                        <div>
                            <div style="color: var(--text-secondary); font-size: 11px;">Total Sessions</div>
                            <div style="font-size: 20px; font-weight: 700;">${totalSessions}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 11px;">Frequency</div>
                            <div style="font-size: 20px; font-weight: 700;">${sessionsPerWeek}√ó<span style="font-size: 14px;">/week</span></div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 11px;">Total Volume</div>
                            <div style="font-size: 20px; font-weight: 700;">${volumeMetric}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 11px;">Avg per Set</div>
                            <div style="font-size: 20px; font-weight: 700;">${avgMetric}</div>
                        </div>
                    </div>
                    ${totalSessions > 1 ? `
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color);">
                            <div style="color: var(--text-secondary); font-size: 11px; margin-bottom: 4px;">Progress (first ‚Üí most recent)</div>
                            <div style="font-size: 18px; font-weight: 700; color: ${improvementColor};">
                                ${firstAvgReps.toFixed(1)} ‚Üí ${lastAvgReps.toFixed(1)} reps
                                <span style="font-size: 14px; margin-left: 8px;">(${improvement > 0 ? '+' : ''}${improvement}%)</span>
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderProgressChart(sessions) {
            const container = document.getElementById('progress-chart');

            // Simple text-based chart showing trend
            const last10 = sessions.slice(-10);
            const maxReps = Math.max(...last10.map(s => s.sets.reduce((sum, set) => sum + (set.reps || 0), 0) / s.sets.length));

            const chartHtml = `
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px;">
                    <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px; color: var(--ios-blue);">Recent Trend (Last ${last10.length} Sessions)</div>
                    <div style="display: flex; flex-direction: column; gap: 4px;">
                        ${last10.map((session, idx) => {
                            const avgReps = session.sets.reduce((sum, set) => sum + (set.reps || 0), 0) / session.sets.length;
                            const barWidth = (avgReps / maxReps * 100).toFixed(1);
                            const date = new Date(session.date).toLocaleDateString();
                            return `
                                <div style="display: flex; align-items: center; gap: 8px; font-size: 12px;">
                                    <div style="width: 70px; color: var(--text-secondary); flex-shrink: 0;">${date}</div>
                                    <div style="flex: 1; background: rgba(0,122,255,0.1); border-radius: 4px; height: 24px; position: relative;">
                                        <div style="background: var(--ios-blue); border-radius: 4px; height: 100%; width: ${barWidth}%; transition: width 0.3s;"></div>
                                        <div style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); font-weight: 600; color: var(--text-primary);">${avgReps.toFixed(1)}</div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;

            container.innerHTML = chartHtml;
        }

        function renderProgressSessions(sessions) {
            const container = document.getElementById('progress-sessions');

            const sessionsHtml = `
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px;">
                    <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px; color: var(--ios-blue);">Session History</div>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${sessions.slice().reverse().map((session, idx) => {
                            const date = new Date(session.date);
                            const hasDistance = session.sets.some(set => set.distanceFeet);

                            let volumeDisplay;
                            if (hasDistance) {
                                const totalDistance = session.sets.reduce((sum, set) => sum + (set.distanceFeet || 0), 0);
                                const avgDistance = (totalDistance / session.sets.length).toFixed(1);
                                volumeDisplay = `${session.sets.length} sets √ó ${avgDistance}ft avg = ${totalDistance}ft total`;
                            } else {
                                const totalReps = session.sets.reduce((sum, set) => sum + (set.reps || 0), 0);
                                const avgReps = (totalReps / session.sets.length).toFixed(1);
                                volumeDisplay = `${session.sets.length} sets √ó ${avgReps} avg reps = ${totalReps} total reps`;
                            }

                            return `
                                <div style="padding: 8px; border-bottom: 1px solid var(--border-color); ${idx === 0 ? 'background: rgba(0,122,255,0.05);' : ''}">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                        <div style="font-weight: 600; font-size: 13px;">${date.toLocaleDateString()}</div>
                                        <div style="font-size: 12px; color: var(--text-secondary);">${date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}</div>
                                    </div>
                                    <div style="font-size: 12px; color: var(--text-secondary);">
                                        ${volumeDisplay}
                                    </div>
                                    ${session.notes ? `<div style="font-size: 11px; color: var(--ios-gray); margin-top: 4px; font-style: italic;">"${session.notes}"</div>` : ''}
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;

            container.innerHTML = sessionsHtml;
        }

        // Modal Functions
        function showExerciseModal() {
            populateExerciseSelect();
            applyLibraryEntryToForm(currentExercise.id);
            document.getElementById('exercise-modal').classList.add('active');
            haptic('medium');
        }

        function closeExerciseModal() {
            document.getElementById('exercise-modal').classList.remove('active');
            haptic('medium');
        }

        function updateTargetLabel() {
            const type = document.getElementById('exercise-type').value;
            const targetInput = document.getElementById('target-input');

            const placeholders = {
                timed: 'Seconds per rep (timed reps)',
                hold: 'Seconds to hold',
                duration: 'Seconds per set (duration)',
                amrap: 'AMRAP window (seconds, optional)',
                distance: 'Distance goal (steps/meters)',
                reps: 'Target (seconds optional)'
            };

            targetInput.placeholder = placeholders[type] || 'Target (seconds or distance)';
            targetInput.disabled = type === 'reps';
        }

        function updateExerciseType() {
            const select = document.getElementById('exercise-select');
            applyLibraryEntryToForm(select.value);
        }

        function saveExercise() {
            const select = document.getElementById('exercise-select');
            const exerciseName = select.options[select.selectedIndex].text;
            const exerciseId = select.value;
            const type = document.getElementById('exercise-type').value;
            const sets = parseInt(document.getElementById('sets-input').value);
            const reps = parseInt(document.getElementById('reps-input').value);
            const seconds = parseInt(document.getElementById('target-input').value);

            if (!sets) {
                alert('Please enter a valid number for sets.');
                return;
            }

            if (COUNTER_TYPES.includes(type) && type !== 'amrap' && (!reps && reps !== 0)) {
                alert('Please enter a valid number for reps/distance.');
                return;
            }

            if (type === 'distance' && (!reps || reps <= 0)) {
                alert('Please enter a distance goal.');
                return;
            }

            if (isTimerType(type) && (!seconds || seconds <= 0)) {
                alert('Please enter seconds for the timer-based exercise.');
                return;
            }

            const entry = getLibraryEntryById(exerciseId);
            const nextSpec = {
                type: type,
                sets: sets,
                repsPerSet: reps,
                secondsPerRep: (isTimerType(type) || type === 'amrap') ? (seconds || 0) : 0
            };

            const prevSpec = entry.current || {};
            if (
                prevSpec.type !== nextSpec.type ||
                prevSpec.sets !== nextSpec.sets ||
                prevSpec.repsPerSet !== nextSpec.repsPerSet ||
                (prevSpec.secondsPerRep ?? null) !== (nextSpec.secondsPerRep ?? null)
            ) {
                recordRevision(entry, nextSpec, 'Manual exercise update');
            } else {
                entry.current = nextSpec;
                persistExerciseLibrary();
            }

            exerciseLibrary = loadExerciseLibrary();
            currentExercise = toSessionExercise({ ...entry, name: exerciseName, id: exerciseId });

            // Remember this exercise for next session
            localStorage.setItem(LAST_EXERCISE_KEY, exerciseId);

            seedTimerSeconds();
            stopTimer();

            haptic('success');
            updateDisplay();
            closeExerciseModal();
        }

        function showHistory() {
            // No longer require an exercise to be selected - can view full history anytime
            renderHistory();
            document.getElementById('history-modal').classList.add('active');
            haptic('medium');
        }

        function closeHistoryModal() {
            document.getElementById('history-modal').classList.remove('active');
            haptic('medium');
        }

        function describeSpec(spec) {
            if (!spec) return 'No spec available';
            const parts = [`${spec.sets || 0} sets`];

            // Show distance if present (replaces reps)
            if (spec.distanceFeet && spec.distanceFeet > 0) {
                parts.push(`${spec.distanceFeet}ft`);
            }
            // Show duration if type is duration or timed (replaces reps)
            else if (spec.type === 'duration') {
                parts.push(`${spec.secondsPerRep || 0}s`);
            }
            // Show reps with optional hold time
            else {
                const repsText = `${spec.repsPerSet || 0} reps`;
                if (spec.type === 'hold' && spec.secondsPerRep > 0) {
                    parts.push(`${repsText} √ó ${spec.secondsPerRep}s hold`);
                } else if (spec.type === 'timed' && spec.secondsPerRep > 0) {
                    parts.push(`${repsText} √ó ${spec.secondsPerRep}s`);
                } else {
                    parts.push(repsText);
                }
            }

            return parts.join(' ¬∑ ');
        }

        // Standardized session summary formatting
        function formatSessionSummary(session, options = {}) {
            const {
                includeDate = true,
                includeExerciseName = false,
                includeSets = true,
                includeFormParams = true
            } = options;

            const parts = [];

            // Date
            if (includeDate) {
                parts.push(formatDateTime(session.date));
            }

            // Exercise name (if requested)
            if (includeExerciseName && session.exerciseName) {
                parts.push(session.exerciseName);
            }

            // Sets summary
            if (includeSets && session.sets && session.sets.length > 0) {
                const totalSets = session.sets.length;
                const hasDistance = session.sets.some(s => s.distanceFeet);

                if (hasDistance) {
                    const totalDistance = session.sets.reduce((sum, s) => sum + (s.distanceFeet || 0), 0);
                    parts.push(`${totalSets} sets ¬∑ ${totalDistance}ft total`);
                } else {
                    const totalReps = session.sets.reduce((sum, s) => sum + (s.reps || 0), 0);
                    parts.push(`${totalSets} sets ¬∑ ${totalReps} reps total`);
                }
            }

            // Form params (if requested and present)
            if (includeFormParams && session.sets && session.sets.length > 0) {
                const firstSet = session.sets[0];
                if (firstSet.formParams) {
                    const params = [];
                    if (firstSet.formParams.weight) params.push(`${firstSet.formParams.weight}${firstSet.formParams.weight_unit || 'lbs'}`);
                    if (firstSet.formParams.band_resistance) params.push(`[${firstSet.formParams.band_resistance}]`);
                    if (params.length > 0) {
                        parts.push(params.join(', '));
                    }
                }
            }

            return parts.join(' ¬∑ ');
        }

        function renderHistory() {
            const sessions = loadHistory();
            const exerciseHistoryList = document.getElementById('exercise-history-list');
            const sessionHistoryList = document.getElementById('session-history-list');

            // Exercise revisions - only show if an exercise is selected
            if (!currentExercise) {
                exerciseHistoryList.innerHTML = '<div class="history-item">Select an exercise to view its revision history.</div>';
            } else {
                const exerciseEntry = getLibraryEntryById(currentExercise.id);
                if (!exerciseEntry.history || exerciseEntry.history.length === 0) {
                    exerciseHistoryList.innerHTML = '<div class="history-item">No revisions logged yet.</div>';
                } else {
                    exerciseHistoryList.innerHTML = exerciseEntry.history
                        .slice()
                        .reverse()
                        .map(revision => {
                            const supersedesLabel = revision.supersedes && revision.supersedes.length
                                ? `<span class="pill">Supersedes ${revision.supersedes.join(', ')}</span>`
                                : '';
                            return `
                                <div class="history-item">
                                    <div>${revision.summary}</div>
                                    ${supersedesLabel}
                                    <div class="history-meta">${formatDateTime(revision.timestamp)} ¬∑ ${describeSpec(revision.next)}</div>
                                </div>
                            `;
                        })
                        .join('');
                }
            }

            // Session history - show all or filtered by current exercise
            const relevantSessions = currentExercise
                ? sessions.filter(s => (s.exerciseId && s.exerciseId === currentExercise.id) || s.exerciseName === currentExercise.name)
                : sessions;

            const reversedSessions = relevantSessions.slice().reverse();

            if (relevantSessions.length === 0) {
                sessionHistoryList.innerHTML = '<div class="history-item">No sessions tracked yet.</div>';
            } else {
                sessionHistoryList.innerHTML = reversedSessions
                    .slice(0, 10)
                    .map(session => {
                        const sessionSummary = formatSessionSummary(session, { includeDate: true, includeSets: true, includeFormParams: false });

                        // Show side info for unilateral exercises and form parameters
                        const setDetails = (session.sets || []).map((set, idx) => {
                            const sideLabel = set.side ? ` (${set.side})` : '';
                            const manualLabel = set.manualLog ? ' üìù' : '';
                            const distanceLabel = set.distanceFeet ? `${set.distanceFeet}ft` : `${set.reps} reps`;

                            // Build form parameters label
                            let formParamsLabel = '';
                            if (set.formParams) {
                                const params = [];
                                if (set.formParams.weight) {
                                    params.push(`${set.formParams.weight}${set.formParams.weight_unit || 'lbs'}`);
                                }
                                if (set.formParams.band_resistance) {
                                    params.push(`[${set.formParams.band_resistance}]`);
                                }
                                if (set.formParams.band_position) {
                                    params.push(`@${set.formParams.band_position.replace('_', ' ')}`);
                                }
                                if (set.formParams.surface) {
                                    params.push(`on ${set.formParams.surface}`);
                                }
                                if (set.formParams.eyes) {
                                    params.push(`eyes ${set.formParams.eyes}`);
                                }
                                if (set.formParams.slope) {
                                    params.push(set.formParams.slope);
                                }
                                if (set.formParams.distance) {
                                    params.push(`${set.formParams.distance}in`);
                                }
                                if (params.length > 0) {
                                    formParamsLabel = ' ' + params.join(' ');
                                }
                            }

                            // Legacy support for old weight/resistance fields
                            if (!formParamsLabel) {
                                const weightLabel = set.weight ? ` ${set.weight}${set.weightUnit || 'lbs'}` : '';
                                const resistanceLabel = set.resistance ? ` [${set.resistance}]` : '';
                                formParamsLabel = weightLabel + resistanceLabel;
                            }

                            return `Set ${idx + 1}: ${distanceLabel}${sideLabel}${formParamsLabel}${manualLabel}`;
                        }).join(' ¬∑ ');

                        const notesHtml = session.notes ? `<div style="margin-top: 6px; font-style: italic; color: var(--text-secondary);">"${session.notes}"</div>` : '';
                        const sessionIndex = sessions.indexOf(session);
                        return `
                            <div class="history-item" style="position: relative;">
                                <div style="display: flex; justify-content: space-between; align-items: start;">
                                    <div style="flex: 1;">
                                        <div>${session.exerciseName}</div>
                                        <div class="history-meta">${sessionSummary}</div>
                                        <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">${setDetails}</div>
                                        ${notesHtml}
                                    </div>
                                    <button onclick="editSession(${sessionIndex}); event.stopPropagation();" style="background: rgba(0,122,255,0.1); color: var(--ios-blue); border: none; padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer; white-space: nowrap;">Edit</button>
                                </div>
                            </div>
                        `;
                    })
                    .join('');
            }
        }

        // Session Editing
        let editingSessionIndex = null;

        function editSession(sessionIndex) {
            const sessions = loadHistory();
            const session = sessions[sessionIndex];
            if (!session) {
                alert('Session not found');
                return;
            }

            editingSessionIndex = sessionIndex;

            // Populate date
            const date = new Date(session.date);
            const dateString = date.toISOString().slice(0, 16); // Format for datetime-local
            document.getElementById('edit-session-date').value = dateString;

            // Populate exercise info
            document.getElementById('edit-session-exercise-name').textContent = session.exerciseName;
            const exerciseEntry = getLibraryEntryById(session.exerciseId) || {};
            const patternInfo = exerciseEntry.pattern ? `${getPatternBadge(exerciseEntry.pattern)} ${getPatternLabel(exerciseEntry.pattern)}` : '';
            document.getElementById('edit-session-exercise-pattern').textContent = patternInfo;

            // Populate sets
            renderEditSessionSets(session.sets || [], exerciseEntry);

            // Populate notes
            document.getElementById('edit-session-notes').value = session.notes || '';

            // Show modal
            document.getElementById('edit-session-modal').classList.add('active');
            haptic('medium');
        }

        function closeEditSession() {
            document.getElementById('edit-session-modal').classList.remove('active');
            editingSessionIndex = null;
            haptic('medium');
        }

        function renderEditSessionSets(sets, exerciseEntry) {
            const container = document.getElementById('edit-session-sets-container');
            const isSided = exerciseEntry.pattern && isSidedPattern(exerciseEntry.pattern);
            const hasDistance = sets.length > 0 && sets[0].distanceFeet !== undefined;

            container.innerHTML = sets.map((set, idx) => {
                const sideSelect = isSided ? `
                    <select class="modal-input" data-set-index="${idx}" data-field="side" onchange="updateEditSessionSet(this)" style="flex: 1;">
                        <option value="">No side</option>
                        <option value="left" ${set.side === 'left' ? 'selected' : ''}>Left</option>
                        <option value="right" ${set.side === 'right' ? 'selected' : ''}>Right</option>
                    </select>
                ` : '';

                const valueField = hasDistance ? `
                    <div style="flex: 1;">
                        <label style="font-size: 12px; color: var(--ios-gray);">Distance (ft)</label>
                        <input type="number" class="modal-input" value="${set.distanceFeet || 0}" data-set-index="${idx}" data-field="distanceFeet" onchange="updateEditSessionSet(this)">
                    </div>
                ` : `
                    <div style="flex: 1;">
                        <label style="font-size: 12px; color: var(--ios-gray);">Reps</label>
                        <input type="number" class="modal-input" value="${set.reps || 0}" data-set-index="${idx}" data-field="reps" onchange="updateEditSessionSet(this)">
                    </div>
                `;

                // Form parameters summary
                let formParamsSummary = '';
                if (set.formParams) {
                    const params = [];
                    if (set.formParams.weight) params.push(`${set.formParams.weight}${set.formParams.weight_unit || 'lbs'}`);
                    if (set.formParams.band_resistance) params.push(`[${set.formParams.band_resistance}]`);
                    if (set.formParams.band_position) params.push(`@${set.formParams.band_position}`);
                    if (set.formParams.surface) params.push(set.formParams.surface);
                    if (set.formParams.eyes) params.push(`eyes ${set.formParams.eyes}`);
                    if (set.formParams.slope) params.push(set.formParams.slope);
                    if (set.formParams.distance) params.push(`${set.formParams.distance}in`);
                    if (params.length > 0) {
                        formParamsSummary = `<div style="font-size: 11px; color: var(--ios-gray); margin-top: 4px;">${params.join(' ¬∑ ')}</div>`;
                    }
                }

                return `
                    <div style="padding: 12px; background: rgba(0,0,0,0.02); border-radius: 8px; margin-bottom: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-weight: 600;">Set ${idx + 1}</span>
                            <button onclick="deleteEditSessionSet(${idx})" style="background: rgba(255,59,48,0.1); color: var(--ios-red); border: none; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;">Delete</button>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            ${valueField}
                            ${sideSelect}
                        </div>
                        ${formParamsSummary}
                    </div>
                `;
            }).join('');
        }

        function updateEditSessionSet(input) {
            const sessions = loadHistory();
            const session = sessions[editingSessionIndex];
            const setIndex = parseInt(input.dataset.setIndex);
            const field = input.dataset.field;
            const value = input.value;

            if (field === 'reps' || field === 'distanceFeet') {
                session.sets[setIndex][field] = parseInt(value) || 0;
            } else {
                session.sets[setIndex][field] = value;
            }

            haptic('light');
        }

        function deleteEditSessionSet(setIndex) {
            if (!confirm('Delete this set?')) return;

            const sessions = loadHistory();
            const session = sessions[editingSessionIndex];
            const exerciseEntry = getLibraryEntryById(session.exerciseId) || {};

            session.sets.splice(setIndex, 1);
            renderEditSessionSets(session.sets, exerciseEntry);
            haptic('medium');
        }

        function addSetToEditSession() {
            const sessions = loadHistory();
            const session = sessions[editingSessionIndex];
            const exerciseEntry = getLibraryEntryById(session.exerciseId) || {};

            // Determine if distance-based
            const hasDistance = session.sets.length > 0 && session.sets[0].distanceFeet !== undefined;

            const newSet = hasDistance ? { distanceFeet: 0 } : { reps: 0 };
            session.sets.push(newSet);
            renderEditSessionSets(session.sets, exerciseEntry);
            haptic('light');
        }

        function deleteSession() {
            if (!confirm('Are you sure you want to delete this session?\n\nThis cannot be undone.')) return;

            const sessions = loadHistory();
            const sessionToDelete = sessions[editingSessionIndex];
            sessions.splice(editingSessionIndex, 1);
            setSessionHistoryCache(sessions, { source: 'local-delete', syncLocalStorage: true });
            void syncRuntimeToFirestore();

            if (currentUser && sessionToDelete) {
                resolveFirestoreDocId(sessionToDelete)
                    .then((docId) => {
                        if (!docId) {
                            console.warn('[Firestore] Unable to delete session: missing doc ID');
                            return;
                        }
                        return deleteDoc(doc(db, `users/${currentUser.uid}/sessions`, docId));
                    })
                    .then(() => {
                        console.log('[Firestore] Session deleted:', sessionToDelete.sessionId);
                    })
                    .catch((error) => {
                        console.error('[Firestore] Failed to delete session:', error);
                    });
            }

            closeEditSession();
            renderHistory(); // Refresh the history display
            haptic('success');
            alert('Session deleted');
        }

        function saveEditedSession() {
            const sessions = loadHistory();
            const session = sessions[editingSessionIndex];

            // Update date
            const newDate = document.getElementById('edit-session-date').value;
            if (newDate) {
                session.date = new Date(newDate).toISOString();
            }

            // Update notes
            session.notes = document.getElementById('edit-session-notes').value;

            setSessionHistoryCache(sessions, { source: 'local-edit', syncLocalStorage: true });
            void syncRuntimeToFirestore();

            if (currentUser) {
                resolveFirestoreDocId(session)
                    .then((docId) => {
                        if (!docId) {
                            console.warn('[Firestore] Unable to update session: missing doc ID');
                            return;
                        }
                        return updateDoc(doc(db, `users/${currentUser.uid}/sessions`, docId), sanitizeSessionForFirestore(session));
                    })
                    .then(() => {
                        console.log('[Firestore] Session updated:', session.sessionId);
                    })
                    .catch((error) => {
                        console.error('[Firestore] Failed to update session:', error);
                    });
            }

            closeEditSession();
            renderHistory(); // Refresh the history display
            haptic('success');
        }

        // Exercise List Management
        function showExerciseList() {
            renderRecentExercises();
            renderExerciseList();
            renderTagFilters();

            document.getElementById('exercise-list-modal').classList.add('active');
            haptic('medium');
        }

        function renderRecentExercises() {
            const sessions = loadHistory();
            if (sessions.length === 0) {
                document.getElementById('recent-exercises-container').innerHTML = '';
                return;
            }

            // Get unique exercises from most recent sessions
            const recentExerciseIds = new Set();
            const recentExercises = [];

            sessions.slice().reverse().forEach(session => {
                if (session.exerciseId && !recentExerciseIds.has(session.exerciseId) && recentExercises.length < 5) {
                    recentExerciseIds.add(session.exerciseId);
                    const entry = getLibraryEntryById(session.exerciseId);
                    if (entry) {
                        recentExercises.push(entry);
                    }
                }
            });

            if (recentExercises.length === 0) {
                document.getElementById('recent-exercises-container').innerHTML = '';
                return;
            }

            const container = document.getElementById('recent-exercises-container');
            container.innerHTML = `
                <div style="font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px;">‚ö° Recent Exercises</div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 8px;">
                    ${recentExercises.map(ex =>
                        `<button class="pill" style="cursor: pointer; padding: 6px 12px; background: var(--ios-blue); color: white;" onclick="selectExerciseFromList('${ex.id}'); event.stopPropagation();">${ex.name}</button>`
                    ).join('')}
                </div>
            `;
        }

        function closeExerciseList() {
            document.getElementById('exercise-list-modal').classList.remove('active');
            document.getElementById('exercise-search').value = '';
            filterTags = [];
            haptic('medium');
        }

        // DATA EXPORT FUNCTIONS
        function showDataBackup() {
            document.getElementById('data-backup-modal').classList.add('active');
            haptic('medium');
        }

        function closeDataBackup() {
            document.getElementById('data-backup-modal').classList.remove('active');
            haptic('medium');
        }

        // SETTINGS FUNCTIONS
        const PREFERENCES_KEY = 'pt_preferences';
        let preferences = {
            hapticEnabled: true,
            voiceEnabled: true
        };

        function loadPreferences() {
            try {
                const stored = localStorage.getItem(PREFERENCES_KEY);
                if (stored) {
                    preferences = JSON.parse(stored);
                }
            } catch (e) {
                console.error('Failed to load preferences:', e);
            }
            // Update UI toggles
            document.getElementById('haptic-toggle').checked = preferences.hapticEnabled;
            document.getElementById('voice-toggle').checked = preferences.voiceEnabled;
        }

        function savePreferences() {
            localStorage.setItem(PREFERENCES_KEY, JSON.stringify(preferences));
            void syncRuntimeToFirestore();
        }

        function showSettings() {
            loadPreferences();
            document.getElementById('app-version-display').textContent = APP_VERSION;
            document.getElementById('settings-modal').classList.add('active');
            haptic('medium');
        }

        function closeSettings() {
            document.getElementById('settings-modal').classList.remove('active');
            haptic('medium');
        }

        function toggleHamburgerMenu() {
            const overlay = document.getElementById('hamburger-overlay');
            const menu = document.getElementById('hamburger-menu');
            const isVisible = overlay.style.display !== 'none';

            if (isVisible) {
                overlay.style.display = 'none';
                menu.style.display = 'none';
            } else {
                overlay.style.display = 'block';
                menu.style.display = 'block';
            }
            haptic('medium');
        }

        // Debug helper: summarize library samples so we can compare counts across sources.
        function formatExercisePreview(exercises, label) {
            const formatEntry = (exercise) => {
                const name = exercise.canonical_name || exercise.name || exercise.title || 'Unnamed';
                const id = exercise.id || exercise.exercise_id || 'no-id';
                return `${name} (${id})`;
            };

            if (!exercises || exercises.length === 0) {
                return `${label}: 0\n  (no exercises loaded)\n`;
            }

            const firstThree = exercises.slice(0, 3).map(formatEntry);
            const lastThree = exercises.slice(-3).map(formatEntry);

            return `${label}: ${exercises.length}\n` +
                `  First 3:\n    - ${firstThree.join('\n    - ')}\n` +
                `  Last 3:\n    - ${lastThree.join('\n    - ')}\n`;
        }

        // Debug helper: mirror the rehab coverage localStorage key summary.
        function formatLocalStorageSummary() {
            const lines = [];
            lines.push(`localStorage keys: ${localStorage.length}`);
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                const value = localStorage.getItem(key) || '';
                lines.push(`  - ${key}: ${value.length} chars`);
            }
            return lines.join('\n');
        }

        // Debug modal: compare local storage vs shared library sources in one snapshot.
        async function showLibraryDiagnostics() {
            const modal = document.getElementById('library-debug-modal');
            const output = document.getElementById('library-debug-output');
            modal.classList.add('active');
            output.textContent = 'Loading debug snapshot...';
            haptic('medium');

            // Inspect raw localStorage payload to detect schema vs legacy arrays.
            const localStored = localStorage.getItem(LIBRARY_KEY);
            let localStoredType = 'missing';
            let localStoredCount = 0;
            if (localStored) {
                try {
                    const parsed = JSON.parse(localStored);
                    if (Array.isArray(parsed)) {
                        localStoredType = 'array';
                        localStoredCount = parsed.length;
                    } else if (Array.isArray(parsed?.exercises)) {
                        localStoredType = 'schema';
                        localStoredCount = parsed.exercises.length;
                    } else {
                        localStoredType = typeof parsed;
                    }
                } catch (error) {
                    localStoredType = 'invalid JSON';
                }
            }

            // Normalize local library for the tracker view.
            const localExercises = loadExerciseLibrary();
            // Load shared library (Firestore + fallback) for cross-page parity checks.
            let sharedExercises = [];
            let sharedError = null;
            try {
                sharedExercises = await loadExerciseLibraryShared({
                    fallbackUrl: 'exercise_library.json',
                    seedIfMissing: false
                });
            } catch (error) {
                sharedError = error;
            }

            const lines = [];
            lines.push('PT Tracker Library Debug');
            lines.push(`Timestamp: ${new Date().toLocaleString()}`);
            lines.push('');
            lines.push(`Local storage payload (pt_exercise_library):`);
            lines.push(`  - type: ${localStoredType}`);
            lines.push(`  - count (raw): ${localStoredCount}`);
            lines.push(`  - count (normalized): ${localExercises.length}`);
            lines.push('');
            lines.push(formatExercisePreview(localExercises, 'Local library (normalized)'));

            if (sharedError) {
                lines.push(`Shared library: ERROR`);
                lines.push(`  - ${sharedError.message}`);
            } else {
                lines.push(formatExercisePreview(sharedExercises, 'Shared library (Firestore + fallback)'));
            }

            lines.push('');
            lines.push(formatLocalStorageSummary());

            output.textContent = lines.join('\n');
        }

        function closeLibraryDiagnostics() {
            document.getElementById('library-debug-modal').classList.remove('active');
            haptic('medium');
        }

        function toggleHaptic() {
            preferences.hapticEnabled = document.getElementById('haptic-toggle').checked;
            savePreferences();
            haptic('light');
        }

        function toggleVoice() {
            preferences.voiceEnabled = document.getElementById('voice-toggle').checked;
            savePreferences();
            haptic('light');
        }

        // DOSAGE PROMPT FUNCTIONS
        let pendingExerciseImport = null;

        function showDosagePrompt(exercise) {
            pendingExerciseImport = exercise;

            document.getElementById('dosage-exercise-name').textContent = exercise.canonical_name;
            document.getElementById('dosage-sets').value = '';
            document.getElementById('dosage-reps').value = '';
            document.getElementById('dosage-seconds').value = '';
            document.getElementById('dosage-distance').value = '';

            // Dynamically show/hide fields based on pattern_modifiers
            const modifiers = exercise.pattern_modifiers || [];
            const repsContainer = document.getElementById('dosage-reps-container');
            const secondsContainer = document.getElementById('dosage-seconds-container');
            const secondsLabel = document.getElementById('dosage-seconds-label');
            const distanceContainer = document.getElementById('dosage-distance-container');

            // duration_seconds or distance_feet REPLACE reps entirely
            const replacesReps = modifiers.includes('duration_seconds') || modifiers.includes('distance_feet');

            if (replacesReps) {
                repsContainer.style.display = 'none';
            } else {
                repsContainer.style.display = 'block';
            }

            // hold_seconds MODIFIES reps (shown alongside)
            // duration_seconds REPLACES reps
            if (modifiers.includes('hold_seconds')) {
                secondsContainer.style.display = 'block';
                secondsLabel.textContent = 'Hold Seconds (per rep)';
            } else if (modifiers.includes('duration_seconds')) {
                secondsContainer.style.display = 'block';
                secondsLabel.textContent = 'Duration (seconds per set)';
            } else {
                secondsContainer.style.display = 'none';
            }

            if (modifiers.includes('distance_feet')) {
                distanceContainer.style.display = 'block';
            } else {
                distanceContainer.style.display = 'none';
            }

            document.getElementById('dosage-prompt-modal').classList.add('active');
            haptic('medium');
        }

        function closeDosagePrompt() {
            document.getElementById('dosage-prompt-modal').classList.remove('active');
            pendingExerciseImport = null;
            haptic('medium');
        }

        function confirmDosage() {
            const sets = parseInt(document.getElementById('dosage-sets').value);
            let reps = parseInt(document.getElementById('dosage-reps').value);
            const seconds = parseInt(document.getElementById('dosage-seconds').value) || 0;
            const distance = parseInt(document.getElementById('dosage-distance').value) || 0;

            if (!sets || sets < 1) {
                alert('Please enter valid sets');
                return;
            }

            if (!pendingExerciseImport) return;

            const ex = pendingExerciseImport;
            const modifiers = ex.pattern_modifiers || [];

            // duration_seconds or distance_feet REPLACE reps
            const replacesReps = modifiers.includes('duration_seconds') || modifiers.includes('distance_feet');

            if (replacesReps) {
                // Set reps to 1 (not used, but required for data structure)
                reps = 1;
            } else {
                // Normal reps-based exercise
                if (!reps || reps < 1) {
                    alert('Please enter valid reps');
                    return;
                }
            }

            // Validate required fields based on modifiers
            if (modifiers.includes('hold_seconds') && (!seconds || seconds < 1)) {
                alert('Please enter valid seconds for this hold exercise');
                return;
            }
            if (modifiers.includes('duration_seconds') && (!seconds || seconds < 1)) {
                alert('Please enter valid duration in seconds');
                return;
            }
            if (modifiers.includes('distance_feet') && (!distance || distance < 1)) {
                alert('Please enter valid distance in feet');
                return;
            }

            // Build dosage spec from user input
            const dosageSpec = {
                type: modifiers.includes('hold_seconds') ? 'hold' : modifiers.includes('duration_seconds') ? 'duration' : 'reps',
                sets: sets,
                repsPerSet: reps,
                secondsPerRep: seconds
            };

            // Add distance if applicable
            if (modifiers.includes('distance_feet') && distance > 0) {
                dosageSpec.distanceFeet = distance;
            }

            // Import using helper
            importExerciseWithDosage(ex, dosageSpec, 'Imported from exercise library');
            const dosageSummary = buildDosageSummary(dosageSpec, modifiers);

            closeDosagePrompt();
            closeExerciseDetail();

            // Check if we're in bulk import mode
            if (bulkImportQueue && bulkImportQueue.length > 0) {
                // More exercises to import, continue to next
                processNextBulkImport();
            } else {
                // Single import or last in bulk - show success message
                closeLibraryBrowser();
                const hasAlternating = (ex.pattern_modifiers || []).includes('alternating');
                let patternMsg = isSidedPattern(ex.pattern)
                    ? 'üîÑ Side tracking enabled: Will log left and right separately'
                    : '‚úì Bilateral exercise: Both sides work together';
                if (hasAlternating && isSidedPattern(ex.pattern)) {
                    patternMsg += '\n‚ö° ALTERNATING: Switch sides on each rep within the set';
                }
                alert(`"${ex.canonical_name}" added to your program!\n\n${dosageSummary}\n\n${patternMsg}`);
                haptic('success');
            }
        }

        // EDIT DOSAGE FUNCTIONS
        let editingDosageExerciseId = null;

        function showEditDosageModal(exerciseId) {
            const ex = exerciseLibrary.find(e => e.id === exerciseId);
            if (!ex) return;

            editingDosageExerciseId = exerciseId;
            const spec = ex.current || {};
            const modifiers = ex.pattern_modifiers || [];

            document.getElementById('edit-dosage-exercise-name').textContent = ex.name;
            document.getElementById('edit-dosage-sets').value = spec.sets || '';
            document.getElementById('edit-dosage-reps').value = spec.repsPerSet || '';
            document.getElementById('edit-dosage-seconds').value = spec.secondsPerRep || '';
            document.getElementById('edit-dosage-distance').value = spec.distanceFeet || '';

            // Show/hide fields based on modifiers
            const repsContainer = document.getElementById('edit-dosage-reps-container');
            const secondsContainer = document.getElementById('edit-dosage-seconds-container');
            const secondsLabel = document.getElementById('edit-dosage-seconds-label');
            const distanceContainer = document.getElementById('edit-dosage-distance-container');

            const hasHold = modifiers.includes('hold_seconds');
            const hasDuration = modifiers.includes('duration_seconds');
            const hasDistance = modifiers.includes('distance_feet');

            if (hasDuration || hasDistance) {
                repsContainer.style.display = 'none';
            } else {
                repsContainer.style.display = 'block';
            }

            if (hasHold || hasDuration) {
                secondsContainer.style.display = 'block';
                secondsLabel.textContent = hasHold ? 'Hold Seconds (per rep)' : 'Duration (seconds)';
            } else {
                secondsContainer.style.display = 'none';
            }

            distanceContainer.style.display = hasDistance ? 'block' : 'none';

            document.getElementById('edit-dosage-modal').classList.add('active');
            haptic('medium');
        }

        function closeEditDosage() {
            document.getElementById('edit-dosage-modal').classList.remove('active');
            editingDosageExerciseId = null;
            haptic('medium');
        }

        function saveEditedDosage() {
            if (!editingDosageExerciseId) return;

            const sets = parseInt(document.getElementById('edit-dosage-sets').value);
            let reps = parseInt(document.getElementById('edit-dosage-reps').value);
            const seconds = parseInt(document.getElementById('edit-dosage-seconds').value) || 0;
            const distance = parseInt(document.getElementById('edit-dosage-distance').value) || 0;

            if (!sets || sets < 1) {
                alert('Please enter valid sets');
                return;
            }

            const ex = exerciseLibrary.find(e => e.id === editingDosageExerciseId);
            if (!ex) return;

            const modifiers = ex.pattern_modifiers || [];
            const replacesReps = modifiers.includes('duration_seconds') || modifiers.includes('distance_feet');

            if (replacesReps) {
                reps = 1;
            } else {
                if (!reps || reps < 1) {
                    alert('Please enter valid reps');
                    return;
                }
            }

            // Validate required fields
            if (modifiers.includes('hold_seconds') && (!seconds || seconds < 1)) {
                alert('Please enter valid seconds for this hold exercise');
                return;
            }
            if (modifiers.includes('duration_seconds') && (!seconds || seconds < 1)) {
                alert('Please enter valid duration in seconds');
                return;
            }
            if (modifiers.includes('distance_feet') && (!distance || distance < 1)) {
                alert('Please enter valid distance in feet');
                return;
            }

            const previousSpec = ex.current || {};
            const newSpec = {
                type: modifiers.includes('hold_seconds') ? 'hold' : modifiers.includes('duration_seconds') ? 'duration' : 'reps',
                sets: sets,
                repsPerSet: reps,
                secondsPerRep: seconds
            };

            if (modifiers.includes('distance_feet') && distance > 0) {
                newSpec.distanceFeet = distance;
            }

            // Build dosage summary
            let dosageSummary = `${sets} sets`;
            if (!replacesReps) dosageSummary += ` √ó ${reps} reps`;
            if (seconds > 0) dosageSummary += ` √ó ${seconds}s`;
            if (distance > 0) dosageSummary += ` √ó ${distance}ft`;

            // Update current spec
            ex.current = newSpec;

            // Add to history
            if (!ex.history) ex.history = [];
            ex.history.push({
                timestamp: new Date().toISOString(),
                summary: `Dosage updated to ${dosageSummary}`,
                previous: previousSpec,
                next: newSpec,
                supersedes: []
            });

            persistExerciseLibrary();
            closeEditDosage();
            renderExerciseList();

            alert(`Dosage updated!\n\n${dosageSummary}`);
            haptic('success');
        }

        function buildExerciseLibrarySchemaData(internalLibrary) {
            // Convert from internal format to schema format
            const exercises = internalLibrary.map(ex => {
                // Parse anatomicRegions back to array
                const heatmapTags = ex.anatomicRegions
                    ? ex.anatomicRegions.split(',').map(s => s.trim()).filter(Boolean)
                    : [];

                return {
                    id: ex.id,
                    canonical_name: ex.name,
                    description: ex.description || '',
                    pt_category: ex.pt_category || 'other',
                    primary_muscles: ex.primary_muscles || [],
                    secondary_muscles: ex.secondary_muscles || [],
                    pattern: ex.pattern || 'both',
                    pattern_modifiers: ex.pattern_modifiers || [],
                    equipment: {
                        required: ex.equipment || [],
                        optional: ex.equipmentOptional || []
                    },
                    form_parameters_required: ex.form_parameters_required || [],
                    tags: {
                        functional: ex.tags || [],
                        format: [], // Not tracked in internal format
                        heatmap: heatmapTags
                    },
                    guidance: ex.guidance || {
                        external_cues: [],
                        motor_cues: [],
                        compensation_warnings: [],
                        safety_flags: []
                    },
                    lifecycle: {
                        status: ex.lifecycle?.status || (ex.archived ? 'archived' : 'active'),
                        effective_start_date: ex.lifecycle?.effective_start_date || null,
                        effective_end_date: ex.lifecycle?.effective_end_date
                            || (ex.archived && ex.superseded_date
                                ? ex.superseded_date.split('T')[0]
                                : null)
                    },
                    added_date: null,
                    updated_date: ex.history && ex.history.length > 0
                        ? ex.history[ex.history.length - 1].timestamp.split('T')[0]
                        : null,
                    // Supersedes metadata (CRITICAL for maintenance workflow)
                    supersedes: ex.supersedes || [],
                    superseded_by: ex.superseded_by || null,
                    superseded_date: ex.superseded_date || null
                };
            });

            return {
                exercises: exercises
            };
        }

        function exportExerciseLibrary() {
            const stored = localStorage.getItem(LIBRARY_KEY);
            if (!stored) {
                alert('No exercise library data found.');
                return;
            }

            try {
                const internalLibrary = JSON.parse(stored);
                const schemaData = buildExerciseLibrarySchemaData(internalLibrary);
                const dateStamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                const filename = `pt_exercise_library-${dateStamp}.json`;
                downloadJSON(schemaData, filename);
                haptic('success');

                const archivedCount = internalLibrary.filter(ex => ex.lifecycle && ex.lifecycle.status === 'archived').length;
                const supersedesCount = internalLibrary.filter(ex => ex.supersedes && ex.supersedes.length > 0).length;
                alert(`‚úì Exported ${internalLibrary.length} exercises\n\n${archivedCount} archived\n${supersedesCount} with supersedes relationships\n\nReady for library maintenance!`);
            } catch (e) {
                console.error('Failed to export exercise library:', e);
                alert('Unable to export exercise library. Data may be corrupt.');
            }
        }

        function exportExerciseHistory() {
            const sessions = getSessionHistoryFromCache();
            if (!sessions || sessions.length === 0) {
                alert('No exercise history data found.');
                return;
            }

            try {
                const serializedSessions = serializeSessionHistory(sessions);

                // Calculate summary statistics
                const uniqueExercises = new Set(serializedSessions.map(s => s.exerciseId)).size;
                const totalSets = serializedSessions.reduce((sum, s) => sum + (s.sets?.length || 0), 0);
                const dateRange = serializedSessions.length > 0 ? {
                    first: serializedSessions[0].date,
                    last: serializedSessions[serializedSessions.length - 1].date
                } : null;

                // Build export with metadata
                const exportData = {
                    export_date: new Date().toISOString(),
                    export_type: 'pt_exercise_history',
                    data_version: localStorage.getItem(PT_VERSION_KEY) || PT_DATA_VERSION,
                    stats: {
                        total_sessions: serializedSessions.length,
                        unique_exercises: uniqueExercises,
                        total_sets: totalSets,
                        date_range: dateRange
                    },
                    sessions: serializedSessions
                };

                const dateStamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                const filename = `pt_exercise_history-${dateStamp}.json`;
                downloadJSON(exportData, filename);

                console.log(`[Export] History exported: ${serializedSessions.length} sessions, ${uniqueExercises} exercises`);
                haptic('success');
            } catch (e) {
                console.error('Failed to export exercise history:', e);
                alert('Unable to export exercise history. Data may be corrupt.');
            }
        }

        function exportAllData() {
            const library = localStorage.getItem(LIBRARY_KEY);
            const history = serializeSessionHistory(getSessionHistoryFromCache());
            const version = localStorage.getItem(PT_VERSION_KEY);

            if (!library && history.length === 0) {
                alert('No data found to export.');
                return;
            }

            try {
                const allData = {
                    pt_data_version: version || PT_DATA_VERSION,
                    pt_exercise_library: library ? JSON.parse(library) : [],
                    pt_tracker_data: history,
                    exported_at: new Date().toISOString()
                };

                const dateStamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                const zipFiles = [];
                zipFiles.push({
                    name: `pt_all_data-${dateStamp}.json`,
                    content: JSON.stringify(allData, null, 2)
                });

                if (library) {
                    const libraryData = buildExerciseLibrarySchemaData(JSON.parse(library));
                    zipFiles.push({
                        name: `pt_exercise_library-${dateStamp}.json`,
                        content: JSON.stringify(libraryData, null, 2)
                    });
                }

                if (history.length > 0) {
                    zipFiles.push({
                        name: `pt_exercise_history-${dateStamp}.json`,
                        content: JSON.stringify(history, null, 2)
                    });
                }

                const zipBlob = createZip(zipFiles);
                const zipName = `pt_all_data-${dateStamp}.zip`;
                downloadBlob(zipName, zipBlob);
                haptic('success');
            } catch (e) {
                console.error('Failed to export all data:', e);
                alert('Unable to export data. One or more data sources may be corrupt.');
            }
        }

        // Mobile Safari compatible download helper
        function downloadJSON(data, filename) {
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            downloadBlob(filename, blob);
        }

        async function downloadBlob(filename, blob) {
            try {
                const file = new File([blob], filename, { type: blob.type || 'application/octet-stream' });
                if (navigator.canShare && navigator.canShare({ files: [file] })) {
                    await navigator.share({ files: [file] });
                    return;
                }
            } catch (err) {
                console.warn('Share failed, falling back to download.', err);
            }

            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.rel = 'noopener';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        }

        function createZip(files) {
            const encoder = new TextEncoder();
            const localChunks = [];
            const centralChunks = [];
            let offset = 0;

            for (const file of files) {
                const nameBytes = encoder.encode(file.name);
                const dataBytes = encoder.encode(file.content);
                const crc = crc32(dataBytes);
                const localHeader = new Uint8Array(30 + nameBytes.length);
                const view = new DataView(localHeader.buffer);
                view.setUint32(0, 0x04034b50, true);
                view.setUint16(4, 20, true);
                view.setUint16(6, 0, true);
                view.setUint16(8, 0, true);
                view.setUint16(10, 0, true);
                view.setUint16(12, 0, true);
                view.setUint32(14, crc, true);
                view.setUint32(18, dataBytes.length, true);
                view.setUint32(22, dataBytes.length, true);
                view.setUint16(26, nameBytes.length, true);
                view.setUint16(28, 0, true);
                localHeader.set(nameBytes, 30);

                localChunks.push(localHeader, dataBytes);

                const centralHeader = new Uint8Array(46 + nameBytes.length);
                const centralView = new DataView(centralHeader.buffer);
                centralView.setUint32(0, 0x02014b50, true);
                centralView.setUint16(4, 20, true);
                centralView.setUint16(6, 20, true);
                centralView.setUint16(8, 0, true);
                centralView.setUint16(10, 0, true);
                centralView.setUint16(12, 0, true);
                centralView.setUint16(14, 0, true);
                centralView.setUint32(16, crc, true);
                centralView.setUint32(20, dataBytes.length, true);
                centralView.setUint32(24, dataBytes.length, true);
                centralView.setUint16(28, nameBytes.length, true);
                centralView.setUint16(30, 0, true);
                centralView.setUint16(32, 0, true);
                centralView.setUint16(34, 0, true);
                centralView.setUint16(36, 0, true);
                centralView.setUint32(38, 0, true);
                centralView.setUint32(42, offset, true);
                centralHeader.set(nameBytes, 46);
                centralChunks.push(centralHeader);

                offset += localHeader.length + dataBytes.length;
            }

            const centralSize = centralChunks.reduce((sum, chunk) => sum + chunk.length, 0);
            const endRecord = new Uint8Array(22);
            const endView = new DataView(endRecord.buffer);
            endView.setUint32(0, 0x06054b50, true);
            endView.setUint16(4, 0, true);
            endView.setUint16(6, 0, true);
            endView.setUint16(8, files.length, true);
            endView.setUint16(10, files.length, true);
            endView.setUint32(12, centralSize, true);
            endView.setUint32(16, offset, true);
            endView.setUint16(20, 0, true);

            const allChunks = [...localChunks, ...centralChunks, endRecord];
            return new Blob(allChunks, { type: 'application/zip' });
        }

        function crc32(data) {
            let crc = 0xFFFFFFFF;
            for (let i = 0; i < data.length; i += 1) {
                crc ^= data[i];
                for (let j = 0; j < 8; j += 1) {
                    const mask = -(crc & 1);
                    crc = (crc >>> 1) ^ (0xEDB88320 & mask);
                }
            }
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }

        function handleImportFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Detect file type and import accordingly
                    if (data.pt_data_version !== undefined && data.pt_exercise_library !== undefined) {
                        // All-data export format
                        importAllData(data);
                    } else if (data.export_type === 'pt_exercise_history' && data.sessions) {
                        // New enhanced history format with metadata
                        importHistory(data.sessions, data.stats);
                    } else if (Array.isArray(data)) {
                        // Legacy individual export format (library or history)
                        // Try to detect which one based on structure
                        if (data.length > 0 && data[0].exerciseId !== undefined) {
                            // History format (legacy)
                            importHistory(data);
                        } else {
                            // Library format
                            importLibrary(data);
                        }
                    } else {
                        alert('Unrecognized file format. Please use a valid PT Tracker export file.');
                    }
                } catch (e) {
                    console.error('Failed to import file:', e);
                    alert('Unable to read file. Make sure it\'s a valid JSON export.');
                }

                // Reset file input
                event.target.value = '';
            };
            reader.readAsText(file);
        }

        function importAllData(data) {
            const message = `Import all data?\n\nThis will REPLACE:\n‚Ä¢ Exercise library (${data.pt_exercise_library?.length || 0} exercises)\n‚Ä¢ Exercise history (${data.pt_tracker_data?.length || 0} sessions)\n\nCurrent data will be overwritten. Continue?`;

            showActionSheet(message, () => {
                if (data.pt_exercise_library) {
                    localStorage.setItem(LIBRARY_KEY, JSON.stringify(data.pt_exercise_library));
                }
                if (data.pt_tracker_data) {
                    setSessionHistoryCache(data.pt_tracker_data, { source: 'import-all', syncLocalStorage: true });
                    queueSessionsForFirestore(data.pt_tracker_data, 'import-all');
                    void syncRuntimeToFirestore();
                }
                if (data.pt_data_version) {
                    localStorage.setItem(PT_VERSION_KEY, data.pt_data_version);
                }

                // Reload library and update display
                exerciseLibrary = loadExerciseLibrary();
                closeDataBackup();
                alert('Data imported successfully! Reload the page to see all changes.');
                haptic('success');
            });
        }

        function importLibrary(data) {
            const message = `Import exercise library?\n\nThis will REPLACE your current library with ${data.length} exercises.\n\nCurrent library will be overwritten. Continue?`;

            showActionSheet(message, () => {
                localStorage.setItem(LIBRARY_KEY, JSON.stringify(data));
                exerciseLibrary = loadExerciseLibrary();
                closeDataBackup();
                alert('Exercise library imported successfully!');
                haptic('success');
            });
        }

        function importHistory(importedSessions, stats) {
            const currentSessions = loadHistory();
            const statsInfo = stats ? ` (${stats.total_sessions} sessions, ${stats.unique_exercises} exercises)` : '';

            // Build action sheet with merge and replace options
            const message = `Import ${importedSessions.length} sessions${statsInfo}?\n\nCurrent history: ${currentSessions.length} sessions\n\nChoose import method:`;

            const actions = [
                {
                    label: 'üîÄ Merge (keep both, remove duplicates)',
                    style: 'primary',
                    callback: () => mergeHistory(currentSessions, importedSessions)
                },
                {
                    label: '‚ö†Ô∏è Replace (delete current history)',
                    style: 'destructive',
                    callback: () => replaceHistory(importedSessions)
                }
            ];

            showActionSheetWithOptions(message, actions);
        }

        function mergeHistory(currentSessions, importedSessions) {
            // Create map of existing sessions by sessionId for fast lookup
            const sessionMap = new Map();
            currentSessions.forEach(s => {
                if (s.sessionId) {
                    sessionMap.set(s.sessionId, s);
                }
            });

            // Add imported sessions, deduplicating by sessionId
            let added = 0;
            let duplicates = 0;

            importedSessions.forEach(session => {
                if (session.sessionId && sessionMap.has(session.sessionId)) {
                    // Duplicate - keep newer one
                    const existing = sessionMap.get(session.sessionId);
                    if (new Date(session.date) > new Date(existing.date)) {
                        sessionMap.set(session.sessionId, session);
                        console.log(`[Import] Updated duplicate session: ${session.sessionId}`);
                    }
                    duplicates++;
                } else {
                    // New session
                    sessionMap.set(session.sessionId || `import-${Date.now()}-${added}`, session);
                    added++;
                }
            });

            // Convert map back to array and sort by date
            const mergedSessions = Array.from(sessionMap.values())
                .sort((a, b) => new Date(a.date) - new Date(b.date));

            // Save merged history
            setSessionHistoryCache(mergedSessions, { source: 'import-merge', syncLocalStorage: true });
            queueSessionsForFirestore(mergedSessions, 'import-merge');
            void syncRuntimeToFirestore();

            closeDataBackup();
            const message = `History merged successfully!\n\n‚Ä¢ Added: ${added} new sessions\n‚Ä¢ Duplicates skipped: ${duplicates}\n‚Ä¢ Total sessions: ${mergedSessions.length}`;
            alert(message);
            console.log(`[Import] Merge complete - Added: ${added}, Skipped: ${duplicates}, Total: ${mergedSessions.length}`);
            haptic('success');
        }

        function replaceHistory(importedSessions) {
            const confirmMsg = `‚ö†Ô∏è Are you sure?\n\nThis will permanently delete your current ${loadHistory().length} sessions and replace with ${importedSessions.length} imported sessions.\n\nThis cannot be undone!`;

            showActionSheet(confirmMsg, () => {
                setSessionHistoryCache(importedSessions, { source: 'import-replace', syncLocalStorage: true });
                queueSessionsForFirestore(importedSessions, 'import-replace');
                void syncRuntimeToFirestore();
                closeDataBackup();
                alert(`History replaced!\n\n${importedSessions.length} sessions imported.`);
                console.log(`[Import] History replaced with ${importedSessions.length} sessions`);
                haptic('success');
            });
        }

        function showActionSheetWithOptions(message, actions) {
            const sheet = document.createElement('div');
            sheet.className = 'action-sheet active';
            sheet.innerHTML = `
                <div class="action-sheet-content">
                    <div class="action-sheet-message">${message}</div>
                    ${actions.map(action => `
                        <button class="action-sheet-button ${action.style === 'destructive' ? 'destructive' : action.style === 'primary' ? 'primary' : ''}">${action.label}</button>
                    `).join('')}
                    <button class="action-sheet-button cancel">Cancel</button>
                </div>
            `;

            document.body.appendChild(sheet);

            const buttons = sheet.querySelectorAll('.action-sheet-button');
            buttons.forEach((btn, idx) => {
                btn.onclick = () => {
                    if (idx < actions.length) {
                        actions[idx].callback();
                    }
                    document.body.removeChild(sheet);
                };
            });

            sheet.onclick = (e) => {
                if (e.target === sheet) {
                    document.body.removeChild(sheet);
                }
            };
        }

        function renderTagFilters() {
            const container = document.getElementById('tag-filter-container');
            const availableTags = getAvailableTags();
            container.innerHTML = availableTags.map(tag => {
                const active = filterTags.includes(tag);
                return `<span class="pill" style="cursor: pointer; background: ${active ? 'var(--ios-blue)' : 'rgba(0,122,255,0.1)'}; color: ${active ? 'white' : 'var(--ios-blue)'};" onclick="toggleFilterTag('${tag}')">${tag}</span>`;
            }).join(' ');
        }

        function toggleFilterTag(tag) {
            if (filterTags.includes(tag)) {
                filterTags = filterTags.filter(t => t !== tag);
            } else {
                filterTags.push(tag);
            }
            renderTagFilters();
            filterExercises();
        }

        function filterExercises() {
            const searchTerm = document.getElementById('exercise-search').value.toLowerCase();
            const filtered = exerciseLibrary.filter(ex => {
                const matchesSearch = !searchTerm || ex.name.toLowerCase().includes(searchTerm);
                const matchesTags = filterTags.length === 0 || (ex.tags && filterTags.some(tag => ex.tags.includes(tag)));
                const notArchived = !ex.archived;
                return matchesSearch && matchesTags && notArchived;
            });
            renderExerciseList(filtered);
        }

        function toggleFavorite(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            entry.favorite = !entry.favorite;
            persistExerciseLibrary();
            exerciseLibrary = loadExerciseLibrary();
            renderExerciseList();
            haptic('medium');
        }

        function archiveExercise(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            showActionSheet(`Archive "${entry.name}"? You can restore it later from archived exercises.`, () => {
                entry.archived = true;
                updateExerciseLifecycle(entry, { archived: true });
                persistExerciseLibrary();
                exerciseLibrary = loadExerciseLibrary();
                renderExerciseList();
                haptic('success');
                void syncExerciseLibraryToFirestore('archive');
            });
        }

        let viewingArchived = false;

        function showArchivedExercises() {
            viewingArchived = !viewingArchived;
            const btn = document.getElementById('archived-btn');

            if (viewingArchived) {
                const archived = exerciseLibrary.filter(ex => ex.archived);
                btn.textContent = '‚Üê Back';
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
                renderArchivedList(archived);
            } else {
                btn.textContent = 'üì¶ Archived';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
                renderExerciseList();
            }
        }

        function renderArchivedList(archivedExercises) {
            const container = document.getElementById('exercise-list-content');

            if (archivedExercises.length === 0) {
                container.innerHTML = '<div class="history-item">No archived exercises.</div>';
                return;
            }

            container.innerHTML = archivedExercises.map(ex => {
                const spec = ex.current || {};
                return `
                    <div class="history-item">
                        <div>${ex.name}</div>
                        <div class="history-meta">${describeSpec(spec)}</div>
                        <div style="margin-top: 8px; display: flex; gap: 8px;">
                            <button class="control-btn btn-success" onclick="unarchiveExercise('${ex.id}'); event.stopPropagation();" style="flex: 1; padding: 8px; font-size: 14px;">Restore</button>
                            <button class="control-btn btn-danger" onclick="permanentlyDeleteExercise('${ex.id}'); event.stopPropagation();" style="flex: 1; padding: 8px; font-size: 14px;">Delete Forever</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function unarchiveExercise(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            entry.archived = false;
            updateExerciseLifecycle(entry, { archived: false });
            persistExerciseLibrary();
            exerciseLibrary = loadExerciseLibrary();
            haptic('success');
            speak('Exercise restored');
            showArchivedExercises(); // Refresh archived view
            void syncExerciseLibraryToFirestore('unarchive');
        }

        function permanentlyDeleteExercise(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            showActionSheet(`PERMANENTLY delete "${entry.name}"? This cannot be undone!`, () => {
                exerciseLibrary = exerciseLibrary.filter(ex => ex.id !== exerciseId);
                persistExerciseLibrary();
                exerciseLibrary = loadExerciseLibrary();
                haptic('success');
                showArchivedExercises(); // Refresh archived view
                void syncExerciseLibraryToFirestore('delete');
            });
        }

        function renderExerciseList(filteredLibrary = null) {
            let list = filteredLibrary || exerciseLibrary.filter(ex => !ex.archived);
            const container = document.getElementById('exercise-list-content');

            if (list.length === 0) {
                container.innerHTML = '<div class="history-item">No exercises found.</div>';
                return;
            }

            // Sort: favorites first, then by last used, then alphabetically
            const sessions = loadHistory();
            list = list.slice().sort((a, b) => {
                // Favorites first
                if (a.favorite && !b.favorite) return -1;
                if (!a.favorite && b.favorite) return 1;

                // Then by most recently used
                const aSession = sessions.filter(s => s.exerciseId === a.id).pop();
                const bSession = sessions.filter(s => s.exerciseId === b.id).pop();
                const aDate = aSession ? new Date(aSession.date).getTime() : 0;
                const bDate = bSession ? new Date(bSession.date).getTime() : 0;
                if (aDate !== bDate) return bDate - aDate;

                // Then alphabetically
                return a.name.localeCompare(b.name);
            });

            container.innerHTML = list.map(ex => {
                const spec = ex.current || {};
                const tags = ex.tags || [];
                const tagHtml = tags.length ? tags.map(t => `<span class="pill">${t}</span>`).join('') : '';
                const hasDetails = ex.details && (ex.details.description || ex.details.executionTips);
                const detailsIndicator = hasDetails ? ' üìã' : '';

                // Calculate quick stats and adherence
                const exerciseSessions = sessions.filter(s => s.exerciseId === ex.id || s.exerciseName === ex.name);
                const totalSessions = exerciseSessions.length;
                const lastSession = exerciseSessions.length ? new Date(exerciseSessions[exerciseSessions.length - 1].date) : null;

                // PT Adherence indicators
                let adherenceColor = '#999';
                let adherenceText = '';
                let adherenceIcon = '';

                if (lastSession) {
                    const daysSince = Math.floor((Date.now() - lastSession.getTime()) / (1000 * 60 * 60 * 24));
                    if (daysSince === 0) {
                        adherenceText = 'Done today ‚úì';
                        adherenceColor = '#34C759';
                    } else if (daysSince <= 3) {
                        adherenceText = `${daysSince} day${daysSince > 1 ? 's' : ''} ago`;
                        adherenceColor = '#34C759';
                    } else if (daysSince <= 7) {
                        adherenceText = `${daysSince} days ago`;
                        adherenceColor = '#FF9500';
                        adherenceIcon = '‚ö†Ô∏è ';
                    } else {
                        adherenceText = `${daysSince} days ago`;
                        adherenceColor = '#FF3B30';
                        adherenceIcon = '‚ùó ';
                    }
                } else {
                    adherenceText = 'Never done';
                    adherenceColor = '#8E8E93';
                    adherenceIcon = '‚óã ';
                }

                const statsHtml = `<div style="font-size: 12px; color: ${adherenceColor}; margin-top: 4px; font-weight: 600;">${adherenceIcon}${adherenceText}${totalSessions > 0 ? ` ¬∑ ${totalSessions} session${totalSessions > 1 ? 's' : ''} total` : ''}</div>`;

                // Show alternating indicator
                const hasAlternating = (ex.pattern_modifiers || []).includes('alternating');
                const alternatingIndicator = hasAlternating && isSidedPattern(ex.pattern) ? ' ‚ö°' : '';

                return `
                    <div class="history-item" style="cursor: pointer; border-left: 4px solid ${adherenceColor};">
                        <div onclick="selectExerciseFromList('${ex.id}')">${ex.name}${detailsIndicator}${alternatingIndicator}</div>
                        ${tagHtml ? `<div style="margin-top: 4px;">${tagHtml}</div>` : ''}
                        <div class="history-meta">${describeSpec(spec)}</div>
                        ${statsHtml}
                        <div style="margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap;">
                            <button class="control-btn ${ex.favorite ? 'btn-primary' : 'btn-secondary'}" onclick="toggleFavorite('${ex.id}'); event.stopPropagation();" style="flex: 0 0 auto; padding: 8px 12px; font-size: 18px;">${ex.favorite ? '‚≠ê' : '‚òÜ'}</button>
                            <button class="control-btn btn-primary" onclick="showEditDosageModal('${ex.id}'); event.stopPropagation();" style="flex: 1; padding: 8px; font-size: 14px;">üíä Dosage</button>
                            ${totalSessions > 0 ? `<button class="control-btn btn-success" onclick="showExerciseProgress('${ex.id}'); event.stopPropagation();" style="flex: 1; padding: 8px; font-size: 14px;">üìä Progress</button>` : ''}
                            <button class="control-btn btn-secondary" onclick="showExerciseDetailsModal('${ex.id}'); event.stopPropagation();" style="flex: 1; padding: 8px; font-size: 14px;">Details</button>
                            <button class="control-btn btn-danger" onclick="archiveExercise('${ex.id}'); event.stopPropagation();" style="flex: 1; padding: 8px; font-size: 14px;">Archive</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function selectExerciseFromList(exerciseId) {
            // Check for unsaved progress
            if (currentExercise && currentExercise.sessionData && currentExercise.sessionData.length > 0) {
                const setsLogged = currentExercise.sessionData.length;
                const message = `‚ö†Ô∏è Switch exercises?\n\nYou have ${setsLogged} unsaved set${setsLogged !== 1 ? 's' : ''} for "${currentExercise.name}".\n\nProgress will be lost if you switch now.`;

                showActionSheet(message, () => {
                    proceedToSwitchExercise(exerciseId);
                });
                return;
            }

            proceedToSwitchExercise(exerciseId);
        }

        function proceedToSwitchExercise(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            currentExercise = toSessionExercise(entry);

            // Remember this exercise for next session
            localStorage.setItem(LAST_EXERCISE_KEY, exerciseId);

            seedTimerSeconds();
            stopTimer();
            updateDisplay();
            closeExerciseList();
            haptic('success');

            // Announce last session info if available
            const sessions = loadHistory();
            const lastSession = sessions.filter(s => s.exerciseId === exerciseId).pop();
            if (lastSession) {
                const daysSince = Math.floor((Date.now() - new Date(lastSession.date).getTime()) / (1000 * 60 * 60 * 24));
                if (daysSince === 0) {
                    speak('Last session: today');
                } else if (daysSince === 1) {
                    speak('Last session: yesterday');
                } else if (daysSince < 7) {
                    speak(`Last session: ${daysSince} days ago`);
                }
            }
        }

        function deleteExerciseFromList(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            showActionSheet(`Delete "${entry.name}"? This cannot be undone.`, () => {
                exerciseLibrary = exerciseLibrary.filter(ex => ex.id !== exerciseId);
                persistExerciseLibrary();
                exerciseLibrary = loadExerciseLibrary();
                renderExerciseList();
                haptic('success');
            });
        }

        // Exercise Details Modal
        let editingDetailsExerciseId = null;

        function showExerciseDetailsModal(exerciseId = null) {
            if (!exerciseId && !currentExercise) {
                alert('Please select an exercise first');
                return;
            }
            editingDetailsExerciseId = exerciseId || currentExercise.id;
            const entry = getLibraryEntryById(editingDetailsExerciseId);
            const details = entry.details || {};

            document.getElementById('exercise-details-title').textContent = entry.name;
            document.getElementById('exercise-description').value = details.description || '';
            document.getElementById('exercise-tips').value = details.executionTips || '';
            document.getElementById('exercise-feel').value = details.shouldFeel || '';
            document.getElementById('exercise-not-feel').value = details.shouldNotFeel || '';
            document.getElementById('exercise-modifications').value = details.modifications || '';
            document.getElementById('exercise-rest-seconds').value = details.restSeconds || '';

            // Display professional guidance if available (from imported exercises)
            const guidanceSection = document.getElementById('professional-guidance-section');
            const guidanceContent = document.getElementById('professional-guidance-content');

            if (entry.guidance && (entry.guidance.external_cues?.length > 0 || entry.guidance.motor_cues?.length > 0 || entry.guidance.compensation_warnings?.length > 0 || entry.guidance.safety_flags?.length > 0)) {
                let html = '';

                // Show description if available
                if (entry.description) {
                    html += `
                        <div style="margin-bottom: 12px;">
                            <div style="font-weight: 600; font-size: 13px; margin-bottom: 4px;">Description</div>
                            <div style="font-size: 13px; color: var(--ios-gray);">${entry.description}</div>
                        </div>
                    `;
                }

                // External cues
                if (entry.guidance.external_cues && entry.guidance.external_cues.length > 0) {
                    html += `
                        <div style="margin-bottom: 12px;">
                            <div style="font-weight: 600; font-size: 13px; margin-bottom: 4px;">üëÄ External Cues</div>
                            <ul style="font-size: 12px; color: var(--ios-gray); margin: 0; padding-left: 20px;">
                                ${entry.guidance.external_cues.map(cue => `<li style="margin-bottom: 4px;">${cue}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                }

                // Motor cues
                if (entry.guidance.motor_cues && entry.guidance.motor_cues.length > 0) {
                    html += `
                        <div style="margin-bottom: 12px;">
                            <div style="font-weight: 600; font-size: 13px; margin-bottom: 4px;">üí™ Motor Cues</div>
                            <ul style="font-size: 12px; color: var(--ios-gray); margin: 0; padding-left: 20px;">
                                ${entry.guidance.motor_cues.map(cue => `<li style="margin-bottom: 4px;">${cue}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                }

                // Compensation warnings
                if (entry.guidance.compensation_warnings && entry.guidance.compensation_warnings.length > 0) {
                    html += `
                        <div style="margin-bottom: 12px;">
                            <div style="font-weight: 600; font-size: 13px; margin-bottom: 4px; color: var(--ios-orange);">‚ö†Ô∏è Compensation Warnings</div>
                            <ul style="font-size: 12px; color: var(--ios-gray); margin: 0; padding-left: 20px;">
                                ${entry.guidance.compensation_warnings.map(warning => `<li style="margin-bottom: 4px;">${warning}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                }

                // Safety flags
                if (entry.guidance.safety_flags && entry.guidance.safety_flags.length > 0) {
                    html += `
                        <div style="margin-bottom: 0;">
                            <div style="font-weight: 600; font-size: 13px; margin-bottom: 4px; color: var(--ios-red);">üõë Safety Flags</div>
                            <ul style="font-size: 12px; color: var(--ios-red); margin: 0; padding-left: 20px;">
                                ${entry.guidance.safety_flags.map(flag => `<li style="margin-bottom: 4px;">${flag}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                }

                guidanceContent.innerHTML = html;
                guidanceSection.style.display = 'block';
            } else {
                guidanceSection.style.display = 'none';
            }

            document.getElementById('exercise-details-modal').classList.add('active');
            haptic('medium');
        }

        function closeExerciseDetailsModal() {
            document.getElementById('exercise-details-modal').classList.remove('active');
            haptic('medium');
        }

        function saveExerciseDetails() {
            const entry = getLibraryEntryById(editingDetailsExerciseId);
            const details = {
                description: document.getElementById('exercise-description').value.trim(),
                executionTips: document.getElementById('exercise-tips').value.trim(),
                shouldFeel: document.getElementById('exercise-feel').value.trim(),
                shouldNotFeel: document.getElementById('exercise-not-feel').value.trim(),
                modifications: document.getElementById('exercise-modifications').value.trim(),
                restSeconds: parseInt(document.getElementById('exercise-rest-seconds').value) || null
            };

            entry.details = details;
            persistExerciseLibrary();
            exerciseLibrary = loadExerciseLibrary();

            closeExerciseDetailsModal();
            haptic('success');
        }

        // Rest Timer
        let restTimerInterval = null;
        let restSecondsRemaining = 0;
        let restSecondsTotal = 0;

        function showRestTimer(seconds) {
            restSecondsTotal = seconds;
            restSecondsRemaining = seconds;
            document.getElementById('rest-countdown').textContent = restSecondsRemaining;
            document.getElementById('rest-progress-bar').style.width = '100%';
            document.getElementById('rest-timer-modal').classList.add('active');
            haptic('medium');

            restTimerInterval = setInterval(() => {
                restSecondsRemaining--;
                document.getElementById('rest-countdown').textContent = restSecondsRemaining;
                const progress = (restSecondsRemaining / restSecondsTotal) * 100;
                document.getElementById('rest-progress-bar').style.width = progress + '%';

                // Countdown beeps
                if (restSecondsRemaining <= 3 && restSecondsRemaining > 0) {
                    playBeep(500, 100);
                    haptic('medium');
                }

                if (restSecondsRemaining <= 0) {
                    clearInterval(restTimerInterval);
                    restTimerInterval = null;
                    playCompletionSound();
                    haptic('success');
                    speak('Rest complete');
                    closeRestTimer();
                }
            }, 1000);
        }

        function closeRestTimer() {
            if (restTimerInterval) {
                clearInterval(restTimerInterval);
                restTimerInterval = null;
            }
            document.getElementById('rest-timer-modal').classList.remove('active');
            haptic('medium');
        }

        function skipRest() {
            if (restTimerInterval) {
                clearInterval(restTimerInterval);
                restTimerInterval = null;
            }
            closeRestTimer();
            haptic('medium');
        }

        // Session Recovery
        const RECOVERY_KEY = 'pt_session_recovery';

        function saveSessionRecovery() {
            //Escape if currentExercise is null or partially initialized
            if (
                !currentExercise ||
                !Array.isArray(currentExercise.sessionData)
            ) {
                localStorage.removeItem(RECOVERY_KEY);
                void syncRuntimeToFirestore();
                return;
            }
            
            if (currentExercise.sessionData.length > 0 || currentExercise.currentSet > 1 || currentExercise.currentRep > 0) {
                const recovery = {
                    exerciseId: currentExercise.id,
                    exerciseName: currentExercise.name,
                    currentSet: currentExercise.currentSet,
                    currentRep: currentExercise.currentRep,
                    sessionData: currentExercise.sessionData,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem(RECOVERY_KEY, JSON.stringify(recovery));
                void syncRuntimeToFirestore();
            } else {
                localStorage.removeItem(RECOVERY_KEY);
                void syncRuntimeToFirestore();
            }
        }

        function checkSessionRecovery() {
            const recoveryData = localStorage.getItem(RECOVERY_KEY);
            if (!recoveryData) return;

            try {
                const recovery = JSON.parse(recoveryData);
                const timeDiff = Date.now() - new Date(recovery.timestamp).getTime();
                const hoursSince = timeDiff / (1000 * 60 * 60);

                // Only offer recovery if less than 24 hours old
                if (hoursSince < 24 && recovery.sessionData.length > 0) {
                    showActionSheet(
                        `Recover incomplete session for "${recovery.exerciseName}"? (${recovery.sessionData.length} sets completed)`,
                        () => {
                            const entry = getLibraryEntryById(recovery.exerciseId);
                            if (entry) {
                                currentExercise = toSessionExercise(entry);
                                currentExercise.currentSet = recovery.currentSet;
                                currentExercise.currentRep = recovery.currentRep;
                                currentExercise.sessionData = recovery.sessionData;
                                seedTimerSeconds();
                                updateDisplay();
                                haptic('success');
                                speak(`Recovered session: Set ${recovery.currentSet}`);
                            } else {
                                localStorage.removeItem(RECOVERY_KEY);
                                void syncRuntimeToFirestore();
                            }
                        }
                    );
                } else {
                    localStorage.removeItem(RECOVERY_KEY);
                    void syncRuntimeToFirestore();
                }
            } catch (e) {
                console.warn('Failed to parse recovery data:', e);
                localStorage.removeItem(RECOVERY_KEY);
                void syncRuntimeToFirestore();
            }
        }

        // Auto-save recovery every time session data changes
        window.addEventListener('beforeunload', saveSessionRecovery);
        setInterval(saveSessionRecovery, 5000); // Save every 5 seconds

        // PT Export Function
        function exportForPT() {
            // Load saved PT email if exists
            const savedEmail = localStorage.getItem('pt_email_address');
            if (savedEmail) {
                document.getElementById('pt-email-address').value = savedEmail;
            }
            document.getElementById('pt-note').value = '';
            document.getElementById('export-pt-modal').classList.add('active');
            haptic('medium');
        }

        function closeExportPTModal() {
            document.getElementById('export-pt-modal').classList.remove('active');
        }

        async function buildPtDataExport(note) {
            return {
                exportDate: new Date().toLocaleDateString('en-US', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                }),
                noteForPT: note || null,
                sessionHistory: serializeSessionHistory(loadHistory()),
                exerciseLibrary: loadExerciseLibrary(),
                rolesData: await loadRolesData(),
                schema: await loadSchema(),
                vocabulary: await loadVocabulary()
            };
        }

        async function copyPtPayloadOnly() {
            const note = document.getElementById('pt-note').value.trim();
            const exportData = await buildPtDataExport(note);
            const payload = await ptPayloadUtils.buildV2Block({ type: 'PT_DATA', obj: exportData });
            try {
                await navigator.clipboard.writeText(payload);
                alert('Payload copied to clipboard. Paste it into your PT editor.');
            } catch (err) {
                console.warn('Clipboard copy failed:', err);
                alert('Unable to copy to clipboard in this browser. Please use Send Email instead.');
            }
        }

        async function sendToPT() {
            const ptEmail = document.getElementById('pt-email-address').value.trim();
            const note = document.getElementById('pt-note').value.trim();

            // Save PT email for next time
            if (ptEmail) {
                localStorage.setItem('pt_email_address', ptEmail);
            }

            const exportData = await buildPtDataExport(note);
            const payload = await ptPayloadUtils.buildV2Block({ type: 'PT_DATA', obj: exportData });
            const dateStr = new Date().toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });

            // Build current dosage summary
            const activeExercises = loadExerciseLibrary().filter(ex => !ex.archived);
            let dosageSummary = '';
            if (activeExercises.length > 0) {
                dosageSummary = '\nCURRENT PROGRAM (Active Exercises):\n';
                dosageSummary += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
                activeExercises.forEach(ex => {
                    const spec = ex.current || {};
                    dosageSummary += `‚Ä¢ ${ex.name}: ${describeSpec(spec)}\n`;
                });
                dosageSummary += '\n';
            }

            // Format email body with V2 block
            const emailBody = `Hi,

${note ? note + '\n\n' : ''}Please paste the data below into the PT Editor to review my progress.
${dosageSummary}
${payload}`;

            const subject = `PT Tracker Data - ${dateStr}`;

            // Create mailto link
            const mailtoLink = `mailto:${encodeURIComponent(ptEmail)}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(emailBody)}`;

            // Open email client
            window.location.href = mailtoLink;

            closeExportPTModal();
            haptic('success');
        }

        // Import PT Modifications from PT
        function importPTModifications() {
            document.getElementById('import-pt-content').value = '';
            document.getElementById('import-pt-modal').classList.add('active');
            haptic('medium');
        }

        function closeImportPTModal() {
            document.getElementById('import-pt-modal').classList.remove('active');
        }

        async function processPastedImport() {
            const pastedContent = document.getElementById('import-pt-content').value;

            if (!pastedContent.trim()) {
                alert('Please paste the email content from your PT');
                return;
            }

            try {
                const parsed = await ptPayloadUtils.parseV2FromText(pastedContent, 'PT_MODIFICATIONS');
                if (parsed.errors.length > 0) {
                    alert(parsed.errors.join('\n\n'));
                    return;
                }

                if (parsed.type !== 'PT_MODIFICATIONS') {
                    alert(`Invalid payload type: ${parsed.type}. Expected PT_MODIFICATIONS.`);
                    return;
                }

                const data = parsed.obj;

                if (!data || data.modificationType !== 'PT_MODIFICATIONS') {
                    alert('Invalid data: This is not a PT modifications payload.');
                    return;
                }

                closeImportPTModal();
                showModificationReview(data.modifications);
            } catch (err) {
                alert('Error parsing data: ' + err.message + '\n\nMake sure you pasted the complete email content.');
                console.error('Import error:', err);
            }
        }

        function mergeExerciseLibraries(sharedLibrary, localLibrary) {
            const exerciseMap = new Map();

            (sharedLibrary || []).forEach(ex => {
                if (!ex?.id) return;
                exerciseMap.set(ex.id, normalizeExerciseEntry(ex));
            });

            (localLibrary || []).forEach(ex => {
                if (!ex?.id) return;
                exerciseMap.set(ex.id, normalizeExerciseEntry(ex));
            });

            return Array.from(exerciseMap.values());
        }

        function shouldSyncSharedData({ label, existingCount, nextCount, sharedLoaded }) {
            if (!sharedLoaded) {
                console.warn(`[Import] Skipping ${label} sync to Firestore because shared data failed to load.`);
                return false;
            }

            if (existingCount > 0 && nextCount === 0) {
                console.warn(`[Import] Skipping ${label} sync to Firestore to prevent wipe (${existingCount} -> 0).`);
                return false;
            }

            return true;
        }

        async function showModificationReview(mods) {
            const newExCount = mods.newExercises?.length || 0;
            const editedExCount = Object.keys(mods.editedExercises || {}).length;
            const archivedExCount = mods.archivedExercises?.length || 0;
            const newRoleCount = Object.values(mods.newRoles || {}).reduce((sum, roles) => sum + roles.length, 0);
            const deletedRoleCount = Object.values(mods.deletedRoles || {}).reduce((sum, roles) => sum + roles.length, 0);
            const editedRoleCount = Object.keys(mods.editedRoles || {}).length;
            const dosageChangeCount = Object.keys(mods.dosageChanges || {}).length;
            const updatedVocabCount = Object.values(mods.updatedVocab || {}).reduce((sum, terms) => sum + Object.keys(terms).length, 0);

            let message = `PT Modifications Summary:\n\n`;
            if (newExCount > 0) message += `‚Ä¢ ${newExCount} new exercise${newExCount !== 1 ? 's' : ''}\n`;
            if (editedExCount > 0) message += `‚Ä¢ ${editedExCount} edited exercise${editedExCount !== 1 ? 's' : ''}\n`;
            if (archivedExCount > 0) message += `‚Ä¢ ${archivedExCount} archived exercise${archivedExCount !== 1 ? 's' : ''}\n`;
            if (newRoleCount > 0) message += `‚Ä¢ ${newRoleCount} new role${newRoleCount !== 1 ? 's' : ''}\n`;
            if (deletedRoleCount > 0) message += `‚Ä¢ ${deletedRoleCount} deleted role${deletedRoleCount !== 1 ? 's' : ''}\n`;
            if (editedRoleCount > 0) message += `‚Ä¢ ${editedRoleCount} edited role set${editedRoleCount !== 1 ? 's' : ''}\n`;
            if (dosageChangeCount > 0) message += `‚Ä¢ ${dosageChangeCount} dosage${dosageChangeCount !== 1 ? 's' : ''} updated\n`;
            if (updatedVocabCount > 0) message += `‚Ä¢ ${updatedVocabCount} vocabulary update${updatedVocabCount !== 1 ? 's' : ''}\n`;
            message += `\nAccept and merge all changes?`;

            if (!confirm(message)) {
                return;
            }

            // Load current data (prefer shared Firestore, fallback to localStorage)
            const localExerciseLibrary = loadExerciseLibrary();
            let sharedExerciseLibrary = [];
            let sharedExerciseLibraryLoaded = false;
            let rolesData = null;
            let rolesDataLoaded = false;
            let sharedRolesCount = 0;
            let vocabulary = null;
            let vocabularyLoaded = false;
            let sharedVocabularyCount = 0;

            try {
                sharedExerciseLibrary = await loadExerciseLibraryShared({
                    fallbackUrl: 'exercise_library.json',
                    seedIfMissing: false
                });
                sharedExerciseLibraryLoaded = true;
            } catch (error) {
                console.warn('[Import] Failed to load exercise library from Firestore; using local storage:', error);
            }

            const exerciseLibrary = mergeExerciseLibraries(sharedExerciseLibrary, localExerciseLibrary);

            try {
                rolesData = await loadExerciseRolesShared({
                    fallbackUrl: 'exercise_roles.json',
                    seedIfMissing: true
                });
                rolesDataLoaded = true;
                sharedRolesCount = Object.keys(rolesData?.exercise_roles || {}).length;
            } catch (error) {
                console.warn('[Import] Failed to load roles from Firestore; using local storage:', error);
                rolesData = loadRolesDataSync();
            }

            try {
                vocabulary = await loadExerciseVocabularyShared({
                    fallbackUrl: 'exercise_roles_vocabulary.json',
                    seedIfMissing: true
                });
                vocabularyLoaded = true;
                sharedVocabularyCount = Object.keys(vocabulary || {}).length;
            } catch (error) {
                console.warn('[Import] Failed to load vocabulary from Firestore; using local storage:', error);
                vocabulary = loadVocabularySync();
            }

            const localRoles = loadRolesDataSync();
            if (localRoles?.exercise_roles) {
                rolesData.exercise_roles = {
                    ...rolesData.exercise_roles,
                    ...localRoles.exercise_roles
                };
            }

            const localVocabulary = loadVocabularySync();
            if (localVocabulary && Object.keys(localVocabulary).length > 0) {
                vocabulary = {
                    ...vocabulary,
                    ...localVocabulary
                };
            }
            let mergedCount = 0;

            // 1. Add new exercises to library
            if (mods.newExercises && mods.newExercises.length > 0) {
                mods.newExercises.forEach(ex => {
                    const exists = exerciseLibrary.find(e => e.id === ex.id);
                    if (!exists) {
                        exerciseLibrary.push(ex);
                        mergedCount++;
                    }
                });
            }

            // 2. Update edited exercises in library
            if (mods.editedExercises && Object.keys(mods.editedExercises).length > 0) {
                Object.keys(mods.editedExercises).forEach(exerciseId => {
                    const updatedExercise = mods.editedExercises[exerciseId];
                    const index = exerciseLibrary.findIndex(e => e.id === exerciseId);
                    if (index !== -1) {
                        exerciseLibrary[index] = updatedExercise;
                        mergedCount++;
                    } else {
                        console.warn(`[Import] Edited exercise not found: ${exerciseId}`);
                    }
                });
            }

            // 3. Archive exercises (remove from library)
            if (mods.archivedExercises && mods.archivedExercises.length > 0) {
                mods.archivedExercises.forEach(exerciseId => {
                    const index = exerciseLibrary.findIndex(e => e.id === exerciseId);
                    if (index !== -1) {
                        exerciseLibrary.splice(index, 1);
                        mergedCount++;
                    }
                    // Also remove role data
                    if (rolesData.exercise_roles[exerciseId]) {
                        delete rolesData.exercise_roles[exerciseId];
                    }
                });
            }

            // 4. Add new roles
            if (mods.newRoles && Object.keys(mods.newRoles).length > 0) {
                Object.keys(mods.newRoles).forEach(exerciseId => {
                    // Find the exercise to get its name
                    const exercise = exerciseLibrary.find(e => e.id === exerciseId);
                    const exerciseName = exercise ? (exercise.name || exercise.canonical_name || exercise.title || exerciseId) : exerciseId;

                    if (!rolesData.exercise_roles[exerciseId]) {
                        rolesData.exercise_roles[exerciseId] = { name: exerciseName, roles: [] };
                    }
                    const newRoles = mods.newRoles[exerciseId];
                    newRoles.forEach(role => {
                        rolesData.exercise_roles[exerciseId].roles.push(role);
                        mergedCount++;
                    });
                });
            }

            // 5. Delete roles
            if (mods.deletedRoles && Object.keys(mods.deletedRoles).length > 0) {
                Object.keys(mods.deletedRoles).forEach(exerciseId => {
                    if (rolesData.exercise_roles[exerciseId]) {
                        const rolesToDelete = mods.deletedRoles[exerciseId];
                        rolesToDelete.forEach(roleToDelete => {
                            const index = rolesData.exercise_roles[exerciseId].roles.findIndex(r =>
                                r.region === roleToDelete.region &&
                                r.capacity === roleToDelete.capacity &&
                                (r.focus || '') === (roleToDelete.focus || '')
                            );
                            if (index !== -1) {
                                rolesData.exercise_roles[exerciseId].roles.splice(index, 1);
                                mergedCount++;
                            }
                        });
                    } else {
                        console.warn(`[Import] Role data not found for exercise: ${exerciseId}`);
                    }
                });
            }

            // 6. Update edited roles (replace entire role set for exercise)
            if (mods.editedRoles && Object.keys(mods.editedRoles).length > 0) {
                Object.keys(mods.editedRoles).forEach(exerciseId => {
                    if (rolesData.exercise_roles[exerciseId]) {
                        rolesData.exercise_roles[exerciseId].roles = mods.editedRoles[exerciseId];
                        mergedCount++;
                    } else {
                        // Create new entry if it doesn't exist
                        const exercise = exerciseLibrary.find(e => e.id === exerciseId);
                        const exerciseName = exercise ? (exercise.name || exercise.canonical_name || exercise.title || exerciseId) : exerciseId;
                        rolesData.exercise_roles[exerciseId] = {
                            name: exerciseName,
                            roles: mods.editedRoles[exerciseId]
                        };
                        mergedCount++;
                    }
                });
            }

            // 7. Update dosages
            if (mods.dosageChanges && Object.keys(mods.dosageChanges).length > 0) {
                Object.keys(mods.dosageChanges).forEach(exerciseId => {
                    const exercise = exerciseLibrary.find(e => e.id === exerciseId);
                    if (exercise) {
                        const previousSpec = exercise.current || {};
                        exercise.current = mods.dosageChanges[exerciseId];

                        // Add to history
                        if (!exercise.history) exercise.history = [];
                        exercise.history.push({
                            timestamp: new Date().toISOString(),
                            summary: `Dosage updated by PT`,
                            previous: previousSpec,
                            next: mods.dosageChanges[exerciseId],
                            supersedes: []
                        });
                        mergedCount++;
                    } else {
                        console.warn(`[Import] Dosage change for unknown exercise: ${exerciseId}`);
                    }
                });
            }

            // 8. Update vocabulary
            if (mods.updatedVocab && Object.keys(mods.updatedVocab).length > 0) {
                Object.keys(mods.updatedVocab).forEach(category => {
                    if (!vocabulary[category]) {
                        vocabulary[category] = {};
                    }
                    Object.assign(vocabulary[category], mods.updatedVocab[category]);
                    mergedCount++;
                });
            }

            // Save all updated data
            localStorage.setItem(LIBRARY_KEY, JSON.stringify(exerciseLibrary));
            saveRolesDataSync(rolesData);
            saveVocabularySync(vocabulary);

            const schemaFormattedLibrary = buildExerciseLibrarySchemaData(exerciseLibrary);
            try {
                const sharedLibraryCount = sharedExerciseLibrary.length;
                const nextLibraryCount = schemaFormattedLibrary.exercises?.length || 0;
                const nextRolesCount = Object.keys(rolesData?.exercise_roles || {}).length;
                const nextVocabularyCount = Object.keys(vocabulary || {}).length;

                const syncTasks = [];

                if (shouldSyncSharedData({
                    label: 'exercise library',
                    existingCount: sharedLibraryCount,
                    nextCount: nextLibraryCount,
                    sharedLoaded: sharedExerciseLibraryLoaded
                })) {
                    syncTasks.push(saveExerciseLibraryShared(schemaFormattedLibrary));
                }

                if (shouldSyncSharedData({
                    label: 'exercise roles',
                    existingCount: sharedRolesCount,
                    nextCount: nextRolesCount,
                    sharedLoaded: rolesDataLoaded
                })) {
                    syncTasks.push(saveExerciseRolesShared(rolesData));
                }

                if (shouldSyncSharedData({
                    label: 'exercise vocabulary',
                    existingCount: sharedVocabularyCount,
                    nextCount: nextVocabularyCount,
                    sharedLoaded: vocabularyLoaded
                })) {
                    syncTasks.push(saveExerciseVocabularyShared(vocabulary));
                }

                if (syncTasks.length > 0) {
                    await Promise.all(syncTasks);
                }
                console.log('[Import] Shared data synced to Firestore');
            } catch (error) {
                console.warn('[Import] Failed to sync shared data to Firestore:', error);
            }

            haptic('success');

            // Export backup package (library + roles + schemas) after successful import
            try {
                const dateStr = new Date().toISOString().split('T')[0];

                // Convert library to schema format (remove internal fields like history, current, bilateral)
                const schemaFormattedLibrary = buildExerciseLibrarySchemaData(exerciseLibrary);

                // Load schema files
                Promise.all([
                    loadExerciseFileSchemaShared({
                        fallbackUrl: 'schema/exercise_file.schema.json',
                        seedIfMissing: true
                    }),
                    loadExerciseRolesSchemaShared({
                        fallbackUrl: 'schema/exercise_roles.schema.json',
                        seedIfMissing: true
                    })
                ]).then(([exerciseSchema, rolesSchema]) => {
                    const zipFiles = [
                        {
                            name: `exercise_library-${dateStr}.json`,
                            content: JSON.stringify(schemaFormattedLibrary, null, 2)
                        },
                        {
                            name: `exercise_roles-${dateStr}.json`,
                            content: JSON.stringify(rolesData, null, 2)
                        },
                        {
                            name: `exercise_file.schema-${dateStr}.json`,
                            content: JSON.stringify(exerciseSchema, null, 2)
                        },
                        {
                            name: `exercise_roles.schema-${dateStr}.json`,
                            content: JSON.stringify(rolesSchema, null, 2)
                        },
                        {
                            name: `exercise_roles_vocabulary-${dateStr}.json`,
                            content: JSON.stringify(vocabulary, null, 2)
                        }
                    ];

                    const zipBlob = createZip(zipFiles);
                    downloadBlob(`pt-import-backup-${dateStr}.zip`, zipBlob);

                    // Delay reload to allow download to start
                    setTimeout(() => {
                        alert(`Successfully merged ${mergedCount} changes from your PT!\n\nBackup downloaded. The app will now reload to apply all changes.`);
                        location.reload();
                    }, 1500);
                }).catch(err => {
                    console.error('[Import] Failed to load schemas for backup:', err);
                    // Still reload even if backup fails
                    alert(`Successfully merged ${mergedCount} changes from your PT!\n\n(Backup download failed - please export manually)\n\nThe app will now reload to apply all changes.`);
                    location.reload();
                });
            } catch (e) {
                console.error('[Import] Failed to export backup:', e);
                // Still reload even if backup fails
                alert(`Successfully merged ${mergedCount} changes from your PT!\n\n(Backup download failed - please export manually)\n\nThe app will now reload to apply all changes.`);
                location.reload();
            }
        }

        // Weekly Summary for PT - Quick Overview
        function exportWeeklySummary() {
            const sessions = loadHistory();
            const now = new Date();
            const sevenDaysAgo = new Date(now - (7 * 24 * 60 * 60 * 1000));
            sevenDaysAgo.setHours(0, 0, 0, 0);

            const weekSessions = sessions.filter(s => new Date(s.date) >= sevenDaysAgo);

            if (weekSessions.length === 0) {
                alert('No sessions in the last 7 days.');
                return;
            }

            let summary = `PT 7-DAY SUMMARY (ROLLING)\n`;
            summary += `${sevenDaysAgo.toLocaleDateString()} - ${now.toLocaleDateString()}\n`;
            summary += `Generated: ${new Date().toLocaleDateString()}\n\n`;

            summary += `${'='.repeat(40)}\n`;
            summary += `OVERVIEW\n`;
            summary += `${'='.repeat(40)}\n`;
            summary += `Total sessions (last 7 days): ${weekSessions.length}\n`;

            // Count unique exercises
            const uniqueExercises = new Set(weekSessions.map(s => s.exerciseId));
            summary += `Exercises performed: ${uniqueExercises.size}\n`;

            // Total work
            const totalSets = weekSessions.reduce((sum, s) => sum + (s.sets?.length || 0), 0);
            const totalReps = weekSessions.reduce((sum, s) => sum + s.sets.reduce((rs, set) => rs + (set.reps || 0), 0), 0);
            summary += `Total sets: ${totalSets}\n`;
            summary += `Total reps: ${totalReps}\n\n`;

            // Group by exercise
            summary += `${'='.repeat(40)}\n`;
            summary += `EXERCISES THIS WEEK\n`;
            summary += `${'='.repeat(40)}\n`;

            const exerciseGroups = {};
            weekSessions.forEach(session => {
                const exName = session.exerciseName;
                if (!exerciseGroups[exName]) {
                    exerciseGroups[exName] = {
                        sessions: [],
                        totalSets: 0,
                        totalReps: 0
                    };
                }
                exerciseGroups[exName].sessions.push(session);
                exerciseGroups[exName].totalSets += session.sets.length;
                exerciseGroups[exName].totalReps += session.sets.reduce((sum, set) => sum + (set.reps || 0), 0);
            });

            Object.keys(exerciseGroups).sort().forEach(exName => {
                const group = exerciseGroups[exName];
                summary += `\n${exName}\n`;
                summary += `  Sessions: ${group.sessions.length}√ó (last 7 days)\n`;
                summary += `  Total: ${group.totalSets} sets, ${group.totalReps} reps\n`;

                // Show dates
                const dates = group.sessions.map(s => new Date(s.date).toLocaleDateString());
                summary += `  Dates: ${dates.join(', ')}\n`;

                // Show notes if any
                const notes = group.sessions.filter(s => s.notes).map(s => s.notes);
                if (notes.length > 0) {
                    summary += `  Notes: ${notes.join(' | ')}\n`;
                }
            });

            summary += `\n${'='.repeat(40)}\n`;
            summary += `BODY PARTS WORKED\n`;
            summary += `${'='.repeat(40)}\n`;

            // Count body parts
            const bodyParts = {};
            weekSessions.forEach(session => {
                const exercise = getLibraryEntryById(session.exerciseId);
                if (exercise && exercise.tags) {
                    exercise.tags.forEach(tag => {
                        bodyParts[tag] = (bodyParts[tag] || 0) + 1;
                    });
                }
            });

            if (Object.keys(bodyParts).length > 0) {
                Object.keys(bodyParts).sort((a, b) => bodyParts[b] - bodyParts[a]).forEach(part => {
                    summary += `  ${part}: ${bodyParts[part]}√ó (last 7 days)\n`;
                });
            } else {
                summary += `  (No body part tags set)\n`;
            }

            summary += `\n${'='.repeat(40)}\n`;
            summary += `END OF 7-DAY SUMMARY\n`;

            // Copy to clipboard
            navigator.clipboard.writeText(summary).then(() => {
                speak('Summary copied');
                haptic('success');
                alert('7-day summary copied! Share with your PT.');
            }).catch(() => {
                const textarea = document.createElement('textarea');
                textarea.value = summary;
                textarea.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; font-family: monospace; font-size: 12px; padding: 20px;';
                document.body.appendChild(textarea);
                textarea.select();
                alert('7-day summary generated! Copy and share with your PT.');
            });
        }

        // PT-Appropriate Progress Tracking (Weekly Sessions, not daily streaks)
        function calculateWeeklyProgress() {
            const sessions = loadHistory();
            if (sessions.length === 0) return { thisWeek: 0, lastWeek: 0, totalWeeks: 0 };

            const now = new Date();
            const startOfThisWeek = new Date(now);
            startOfThisWeek.setDate(now.getDate() - now.getDay()); // Sunday
            startOfThisWeek.setHours(0, 0, 0, 0);

            const startOfLastWeek = new Date(startOfThisWeek);
            startOfLastWeek.setDate(startOfLastWeek.getDate() - 7);

            const thisWeekSessions = sessions.filter(s => new Date(s.date) >= startOfThisWeek);
            const lastWeekSessions = sessions.filter(s => {
                const date = new Date(s.date);
                return date >= startOfLastWeek && date < startOfThisWeek;
            });

            // Count unique workout weeks
            const uniqueWeeks = new Set();
            sessions.forEach(s => {
                const date = new Date(s.date);
                const weekStart = new Date(date);
                weekStart.setDate(date.getDate() - date.getDay());
                uniqueWeeks.add(weekStart.toDateString());
            });

            return {
                thisWeek: thisWeekSessions.length,
                lastWeek: lastWeekSessions.length,
                totalWeeks: uniqueWeeks.size
            };
        }

        function updateStreakDisplay() {
            const { thisWeek, lastWeek, totalWeeks } = calculateWeeklyProgress();
            const display = document.getElementById('streak-display');

            if (thisWeek > 0) {
                display.textContent = `${thisWeek} session${thisWeek > 1 ? 's' : ''} this week`;
                if (thisWeek >= 3) display.textContent += ' üí™';
            } else if (lastWeek > 0) {
                display.textContent = `${lastWeek} last week`;
            } else if (totalWeeks > 0) {
                display.textContent = `${totalWeeks} week${totalWeeks > 1 ? 's' : ''} tracked`;
            } else {
                display.textContent = '';
            }
        }

        // Body Heatmap - REPLACED BY REHAB COVERAGE VIEW
        /*
        const BODY_PART_COORDS = {
            neck: { top: '8%', left: '40%', width: '20%', height: '8%' },
            shoulder: { top: '16%', left: '20%', width: '60%', height: '10%' },
            arm: { top: '18%', left: '10%', width: '15%', height: '18%' },
            core: { top: '28%', left: '35%', width: '30%', height: '16%' },
            back: { top: '17%', left: '35%', width: '30%', height: '20%' },
            hip: { top: '38%', left: '32%', width: '36%', height: '12%' },
            glute: { top: '44%', left: '32%', width: '36%', height: '10%' },
            leg: { top: '50%', left: '30%', width: '18%', height: '25%' },
            knee: { top: '62%', left: '30%', width: '18%', height: '10%' },
            ankle: { top: '88%', left: '30%', width: '18%', height: '8%' },
            wrist: { top: '34%', left: '8%', width: '12%', height: '6%' },
            elbow: { top: '28%', left: '8%', width: '12%', height: '6%' }
        };

        function getBodyPartHeatLevel(sessions, bodyPart) {
            // Count sessions in last 7 days that worked this body part
            const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
            const recentSessions = sessions.filter(s => new Date(s.date).getTime() > sevenDaysAgo);

            let count = 0;
            recentSessions.forEach(session => {
                const exercise = getLibraryEntryById(session.exerciseId);
                if (!exercise) return;

                // Check tags
                if (exercise.tags && exercise.tags.includes(bodyPart)) count++;

                // Check anatomic regions
                if (exercise.anatomicRegions && exercise.anatomicRegions.toLowerCase().includes(bodyPart)) count++;
            });

            if (count === 0) return 'heat-none';
            if (count <= 2) return 'heat-low';
            if (count <= 4) return 'heat-medium';
            if (count <= 6) return 'heat-high';
            return 'heat-very-high';
        }

        function showBodyHeatmap() {
            const sessions = loadHistory();
            const diagram = document.getElementById('body-diagram');

            // Clear previous overlays
            diagram.innerHTML = '';

            // Add overlays for each body part
            Object.keys(BODY_PART_COORDS).forEach(part => {
                const coords = BODY_PART_COORDS[part];
                const heatLevel = getBodyPartHeatLevel(sessions, part);

                const overlay = document.createElement('div');
                overlay.className = `body-part-overlay ${heatLevel}`;
                overlay.style.top = coords.top;
                overlay.style.left = coords.left;
                overlay.style.width = coords.width;
                overlay.style.height = coords.height;
                overlay.textContent = part === 'leg' ? 'leg' : '';
                overlay.onclick = () => showBodyPartDetails(part, sessions);

                diagram.appendChild(overlay);
            });

            document.getElementById('body-heatmap-modal').classList.add('active');
            document.getElementById('body-part-details').innerHTML = '';
            haptic('medium');
        }

        function closeBodyHeatmap() {
            document.getElementById('body-heatmap-modal').classList.remove('active');
            haptic('medium');
        }

        function showBodyPartDetails(bodyPart, sessions) {
            const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
            const recentSessions = sessions.filter(s => new Date(s.date).getTime() > sevenDaysAgo);

            const relevantExercises = [];
            recentSessions.forEach(session => {
                const exercise = getLibraryEntryById(session.exerciseId);
                if (!exercise) return;

                const matchesTags = exercise.tags && exercise.tags.includes(bodyPart);
                const matchesRegions = exercise.anatomicRegions && exercise.anatomicRegions.toLowerCase().includes(bodyPart);

                if (matchesTags || matchesRegions) {
                    const existing = relevantExercises.find(e => e.id === exercise.id);
                    if (existing) {
                        existing.count++;
                        existing.lastDate = new Date(Math.max(new Date(existing.lastDate), new Date(session.date)));
                    } else {
                        relevantExercises.push({
                            id: exercise.id,
                            name: exercise.name,
                            count: 1,
                            lastDate: new Date(session.date)
                        });
                    }
                }
            });

            const detailsDiv = document.getElementById('body-part-details');

            if (relevantExercises.length === 0) {
                detailsDiv.innerHTML = `
                    <div class="history-list">
                        <div class="history-item">
                            <strong>${bodyPart.toUpperCase()}</strong>
                            <div class="history-meta">No exercises in last 7 days</div>
                        </div>
                    </div>
                `;
            } else {
                detailsDiv.innerHTML = `
                    <div class="history-list">
                        <div class="history-item">
                            <strong>${bodyPart.toUpperCase()}</strong>
                            <div style="margin-top: 8px;">
                                ${relevantExercises.map(ex => `
                                    <div style="font-size: 14px; padding: 4px 0;">
                                        ${ex.name} <span class="pill">${ex.count}√ó this week</span>
                                        <div style="font-size: 11px; color: var(--text-secondary);">Last: ${ex.lastDate.toLocaleDateString()}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }

            haptic('medium');
        }
        */

        // Quick Exercise Switcher
        function showQuickSwitcher() {
            // If no exercise selected, go straight to exercise list
            if (!currentExercise) {
                showExerciseList();
                return;
            }

            const container = document.getElementById('quick-switcher-list');
            const activeExercises = exerciseLibrary.filter(ex => !ex.archived && (ex.favorite || ex.id === currentExercise.id));

            if (activeExercises.length <= 1) {
                // Show full exercise list if only one active
                showExerciseList();
                return;
            }

            container.innerHTML = activeExercises.map(ex => {
                const isCurrent = ex.id === currentExercise.id;
                const patternBadge = ' ' + getPatternBadge(ex.pattern);
                return `
                    <div class="history-item" style="cursor: pointer; background: ${isCurrent ? 'rgba(0,122,255,0.1)' : 'white'};" onclick="quickSwitchTo('${ex.id}')">
                        <div>${isCurrent ? '‚ñ∂ ' : ''}${ex.name}${patternBadge}${ex.favorite ? ' ‚≠ê' : ''}</div>
                        <div class="history-meta">${describeSpec(ex.current || {})}</div>
                    </div>
                `;
            }).join('');

            document.getElementById('quick-switcher-modal').classList.add('active');
            haptic('medium');
        }

        function closeQuickSwitcher() {
            document.getElementById('quick-switcher-modal').classList.remove('active');
            haptic('medium');
        }

        function quickSwitchTo(exerciseId) {
            if (exerciseId === currentExercise.id) {
                closeQuickSwitcher();
                return;
            }

            // Save current progress before switching
            saveSessionRecovery();

            const entry = getLibraryEntryById(exerciseId);
            currentExercise = toSessionExercise(entry);

            // Remember this exercise for next session
            localStorage.setItem(LAST_EXERCISE_KEY, exerciseId);

            seedTimerSeconds();
            stopTimer();
            updateDisplay();
            closeQuickSwitcher();
            haptic('success');
            speak(`Switched to ${entry.name}`);
        }

        // Exercise Library Browser Functions
        let libraryExercises = [];
        let selectedLibraryExercise = null;
        let showOnlyNewExercises = true;  // Default: filter out already-imported
        let selectedExercisesForImport = new Set();  // Track checked exercises
        let isLoadingLibraryExercises = false;

        async function loadExerciseLibraryData() {
            isLoadingLibraryExercises = true;
            try {
                const timeoutMs = 7000;
                const exercises = await Promise.race([
                    loadExerciseLibraryShared({
                        fallbackUrl: 'exercise_library.json',
                        seedIfMissing: false
                    }),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Request timed out.')), timeoutMs))
                ]);
                libraryExercises = exercises || [];
                console.log(`Loaded ${libraryExercises.length} exercises from shared library`);
                return libraryExercises;
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.error('Exercise library request timed out.');
                    alert('Failed to load exercise library:\nRequest timed out.\n\nCheck your connection and try again.');
                } else {
                console.error('Failed to load exercise library:', error);
                alert(`Failed to load exercise library:\n${error.message}\n\nCheck your connection and try again.`);
                }
                libraryExercises = [];
                return [];
            } finally {
                isLoadingLibraryExercises = false;
            }
        }

        async function syncRolesToFirestore(rolesData) {
            if (!currentUser) return;
            try {
                await saveExerciseRolesShared(rolesData);
            } catch (error) {
                console.warn('[Roles] Failed to sync roles to Firestore:', error);
            }
        }

        async function syncVocabularyToFirestore(vocabulary) {
            if (!currentUser) return;
            try {
                await saveExerciseVocabularyShared(vocabulary);
            } catch (error) {
                console.warn('[Vocabulary] Failed to sync vocabulary to Firestore:', error);
            }
        }

        async function showLibraryBrowser() {
            console.log('Opening library browser...');
            try {
                // Show loading message immediately
                document.getElementById('library-exercises-list').innerHTML = '<div class="history-item">Loading exercise library‚Ä¶</div>';
                document.getElementById('library-browser-modal').classList.add('active');

                if (libraryExercises.length === 0) {
                    console.log('Loading exercise library...');
                    await loadExerciseLibraryData();
                }

                console.log(`Library exercises loaded: ${libraryExercises.length}`);
                selectedExercisesForImport.clear();
                document.getElementById('bulk-import-btn').style.display = 'none';
                renderLibraryExercises();
                haptic('medium');
            } catch (error) {
                console.error('Error showing library browser:', error);
                alert(`Failed to open library browser:\n${error.message}`);
            }
        }

        function toggleShowOnlyNew() {
            showOnlyNewExercises = document.getElementById('show-new-toggle').checked;
            selectedExercisesForImport.clear();
            document.getElementById('bulk-import-btn').style.display = 'none';
            renderLibraryExercises();
        }

        function toggleExerciseSelection(exerciseId, event) {
            event.stopPropagation();
            if (selectedExercisesForImport.has(exerciseId)) {
                selectedExercisesForImport.delete(exerciseId);
            } else {
                selectedExercisesForImport.add(exerciseId);
            }

            // Show/hide import button based on selection
            const importBtn = document.getElementById('bulk-import-btn');
            importBtn.style.display = selectedExercisesForImport.size > 0 ? 'block' : 'none';

            // Update checkbox state
            const checkbox = document.getElementById(`ex-check-${exerciseId}`);
            if (checkbox) checkbox.checked = selectedExercisesForImport.has(exerciseId);
        }

        function renderLibraryExercises() {
            console.log('Rendering library exercises...');
            const container = document.getElementById('library-exercises-list');
            const searchTerm = document.getElementById('library-search').value.toLowerCase();

            // Check if still loading
            if (isLoadingLibraryExercises) {
                container.innerHTML = '<div class="history-item">Loading exercise library‚Ä¶</div>';
                return;
            }

            console.log(`Total library exercises: ${libraryExercises.length}`);
            console.log(`Exercise library size: ${exerciseLibrary.length}`);

            // Filter exercises based on search and "show only new" toggle
            let filtered = libraryExercises.filter(ex => {
                try {
                    const matchesSearch =
                        ex.canonical_name.toLowerCase().includes(searchTerm) ||
                        ex.description.toLowerCase().includes(searchTerm) ||
                        (ex.primary_muscles && ex.primary_muscles.some(m => m.toLowerCase().includes(searchTerm))) ||
                        (ex.equipment && ex.equipment.required && ex.equipment.required.some(e => e.toLowerCase().includes(searchTerm)));
                    return matchesSearch;
                } catch (error) {
                    console.error('Error filtering exercise:', ex.id, error);
                    return false;
                }
            });

            // Apply "show only new" filter
            if (showOnlyNewExercises) {
                filtered = filtered.filter(ex => !exerciseLibrary.find(e => e.id === ex.id));
            }

            console.log(`Filtered exercises: ${filtered.length}`);

            if (filtered.length === 0) {
                const message = showOnlyNewExercises
                    ? 'No new exercises found. Uncheck "Show only new" to see all.'
                    : 'No exercises found in library';
                container.innerHTML = `<div class="history-item">${message}</div>`;
                console.log('No exercises to display');
                return;
            }

            try {
                container.innerHTML = filtered.map((ex, idx) => {
                    try {
                        const patternLabel = getPatternBadge(ex.pattern) + ' ' + getPatternLabel(ex.pattern);
                        const patternColor = getPatternColor(ex.pattern);
                        const equipmentRequired = ex.equipment && ex.equipment.required ? ex.equipment.required : [];
                        const equipmentLabel = equipmentRequired.length > 0
                            ? equipmentRequired.join(', ')
                            : 'No equipment';

                        const alreadyImported = exerciseLibrary.find(e => e.id === ex.id);
                        const isChecked = selectedExercisesForImport.has(ex.id);
                        const checkboxDisabled = alreadyImported && !showOnlyNewExercises;
                        const primaryMuscles = ex.primary_muscles || [];

                        return `
                            <div class="history-item" style="display: flex; gap: 12px; align-items: start; ${alreadyImported && !showOnlyNewExercises ? 'opacity: 0.5;' : ''}">
                                <input type="checkbox"
                                       id="ex-check-${ex.id}"
                                       ${isChecked ? 'checked' : ''}
                                       ${checkboxDisabled ? 'disabled' : ''}
                                       onclick="toggleExerciseSelection('${ex.id}', event)"
                                       style="width: 20px; height: 20px; margin-top: 2px; cursor: ${checkboxDisabled ? 'not-allowed' : 'pointer'};">
                                <div style="flex: 1; cursor: pointer;" onclick="showExerciseDetail('${ex.id}')">
                                    <div style="font-weight: 600; margin-bottom: 4px;">
                                        ${ex.canonical_name}
                                        ${alreadyImported && !showOnlyNewExercises ? '<span style="font-size: 11px; color: var(--ios-green); margin-left: 6px;">‚úì Imported</span>' : ''}
                                    </div>
                                    <div style="font-size: 12px; color: var(--ios-gray); margin-bottom: 4px;">${(ex.description || '').substring(0, 100)}${(ex.description || '').length > 100 ? '...' : ''}</div>
                                    <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;">
                                        <span class="pill" style="background: ${patternColor}; color: white; font-size: 11px; padding: 4px 8px;">${patternLabel}</span>
                                        <span class="pill" style="background: rgba(0,122,255,0.1); color: var(--ios-blue); font-size: 11px; padding: 4px 8px;">üì¶ ${equipmentLabel}</span>
                                        <span class="pill" style="background: rgba(0,122,255,0.1); color: var(--ios-blue); font-size: 11px; padding: 4px 8px;">üí™ ${primaryMuscles.length} muscles</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    } catch (error) {
                        console.error(`Error rendering exercise ${ex.id}:`, error);
                        return `<div class="history-item" style="color: var(--ios-red);">Error rendering ${ex.id}</div>`;
                    }
                }).join('');
                console.log('Library exercises rendered successfully');
            } catch (error) {
                console.error('Error rendering library list:', error);
                container.innerHTML = `<div class="history-item" style="color: var(--ios-red);">Error loading exercises. Check console for details.</div>`;
            }
        }

        function filterLibraryExercises() {
            renderLibraryExercises();
        }

        function showExerciseDetail(exerciseId) {
            selectedLibraryExercise = libraryExercises.find(ex => ex.id === exerciseId);
            if (!selectedLibraryExercise) return;

            const ex = selectedLibraryExercise;
            document.getElementById('exercise-detail-title').textContent = ex.canonical_name;

            const detailContent = `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Description</div>
                    <div style="font-size: 14px; color: var(--ios-gray);">${ex.description}</div>
                </div>

                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Pattern</div>
                    <div style="font-size: 14px;">
                        <span class="pill" style="background: ${getPatternColor(ex.pattern)}; color: white;">
                            ${getPatternBadge(ex.pattern)} ${isSidedPattern(ex.pattern) ? 'Sided Exercise (work left and right separately)' : 'Bilateral Exercise (both sides together)'}
                        </span>
                        ${(ex.pattern_modifiers || []).includes('alternating') && isSidedPattern(ex.pattern) ? `
                        <span class="pill" style="background: var(--ios-orange); color: white; margin-left: 6px;">
                            ‚ö° ALTERNATING (switch sides each rep within set)
                        </span>
                        ` : ''}
                    </div>
                </div>

                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Primary Muscles</div>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        ${ex.primary_muscles.map(m => `<span class="pill" style="background: rgba(0,122,255,0.1); color: var(--ios-blue); font-size: 13px;">${m}</span>`).join('')}
                    </div>
                </div>

                ${ex.secondary_muscles.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Secondary Muscles</div>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        ${ex.secondary_muscles.map(m => `<span class="pill" style="background: rgba(0,122,255,0.05); color: var(--ios-gray); font-size: 12px;">${m}</span>`).join('')}
                    </div>
                </div>
                ` : ''}

                ${ex.equipment.required.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Equipment Required</div>
                    <div style="font-size: 14px; color: var(--ios-gray);">${ex.equipment.required.join(', ')}</div>
                </div>
                ` : ''}

                ${ex.equipment.optional.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Optional Equipment</div>
                    <div style="font-size: 14px; color: var(--ios-gray);">${ex.equipment.optional.join(', ')}</div>
                </div>
                ` : ''}

                ${ex.guidance.external_cues.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">üëÄ External Cues</div>
                    <ul style="font-size: 13px; color: var(--ios-gray); margin: 0; padding-left: 20px;">
                        ${ex.guidance.external_cues.map(cue => `<li style="margin-bottom: 6px;">${cue}</li>`).join('')}
                    </ul>
                </div>
                ` : ''}

                ${ex.guidance.motor_cues.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">üí™ Motor Cues</div>
                    <ul style="font-size: 13px; color: var(--ios-gray); margin: 0; padding-left: 20px;">
                        ${ex.guidance.motor_cues.map(cue => `<li style="margin-bottom: 6px;">${cue}</li>`).join('')}
                    </ul>
                </div>
                ` : ''}

                ${ex.guidance.compensation_warnings.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px; color: var(--ios-orange);">‚ö†Ô∏è Compensation Warnings</div>
                    <ul style="font-size: 13px; color: var(--ios-gray); margin: 0; padding-left: 20px;">
                        ${ex.guidance.compensation_warnings.map(warning => `<li style="margin-bottom: 6px;">${warning}</li>`).join('')}
                    </ul>
                </div>
                ` : ''}

                ${ex.guidance.safety_flags.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px; color: var(--ios-red);">üõë Safety Flags</div>
                    <ul style="font-size: 13px; color: var(--ios-red); margin: 0; padding-left: 20px;">
                        ${ex.guidance.safety_flags.map(flag => `<li style="margin-bottom: 6px;">${flag}</li>`).join('')}
                    </ul>
                </div>
                ` : ''}
            `;

            document.getElementById('exercise-detail-content').innerHTML = detailContent;
            document.getElementById('library-browser-modal').classList.remove('active');
            document.getElementById('exercise-detail-modal').classList.add('active');
            haptic('medium');
        }

        function closeExerciseDetail() {
            document.getElementById('exercise-detail-modal').classList.remove('active');
            document.getElementById('library-browser-modal').classList.add('active');
            haptic('medium');
        }

        function importLibraryExercise() {
            if (!selectedLibraryExercise) return;

            const ex = selectedLibraryExercise;

            // Check if already imported
            if (exerciseLibrary.find(e => e.id === ex.id)) {
                alert('This exercise is already in your library!');
                return;
            }

            // If PT has assigned dosage, use it directly
            if (ex.current && ex.current.sets) {
                importExerciseWithDosage(ex, ex.current, 'PT-assigned dosage');
                closeExerciseDetail();
                closeLibraryBrowser();

                const isBilateral = isBilateralPattern(ex.pattern);
                const hasAlternating = (ex.pattern_modifiers || []).includes('alternating');
                let patternMsg = isSidedPattern(ex.pattern)
                    ? 'üîÑ Side tracking enabled: Will log left and right separately'
                    : '‚úì Bilateral exercise: Both sides work together';
                if (hasAlternating && isSidedPattern(ex.pattern)) {
                    patternMsg += '\n‚ö° ALTERNATING: Switch sides on each rep within the set';
                }

                const dosageSummary = buildDosageSummary(ex.current, ex.pattern_modifiers || []);
                alert(`"${ex.canonical_name}" added to your program!\n\n${dosageSummary}\n(Using PT-assigned dosage)\n\n${patternMsg}`);
            } else {
                // No PT dosage - show prompt
                showDosagePrompt(ex);
            }
        }

        // Helper to build dosage summary string
        function buildDosageSummary(dosageSpec, modifiers) {
            const replacesReps = modifiers.includes('duration_seconds') || modifiers.includes('distance_feet');
            let summary = `${dosageSpec.sets} sets`;
            if (!replacesReps && dosageSpec.repsPerSet) {
                summary += ` √ó ${dosageSpec.repsPerSet} reps`;
            }
            if (dosageSpec.secondsPerRep && dosageSpec.secondsPerRep > 0) {
                summary += ` √ó ${dosageSpec.secondsPerRep}s`;
            }
            if (dosageSpec.distanceFeet && dosageSpec.distanceFeet > 0) {
                summary += ` √ó ${dosageSpec.distanceFeet}ft`;
            }
            return summary;
        }

        // Helper to import exercise with a given dosage spec
        function importExerciseWithDosage(ex, dosageSpec, source) {
            const isBilateral = isBilateralPattern(ex.pattern);
            const sideOptions = getSideOptionsForPattern(ex.pattern);
            const simpleTags = ex.tags.functional || [];
            const equipmentList = ex.equipment.required || [];

            const dosageSummary = buildDosageSummary(dosageSpec, ex.pattern_modifiers || []);

            const newExercise = {
                id: ex.id,
                name: ex.canonical_name,
                description: ex.description,
                pt_category: ex.pt_category,
                primary_muscles: ex.primary_muscles,
                secondary_muscles: ex.secondary_muscles,
                pattern: ex.pattern,
                pattern_modifiers: ex.pattern_modifiers,
                form_parameters_required: ex.form_parameters_required || [],
                equipment: equipmentList,
                equipmentOptional: ex.equipment.optional || [],
                guidance: ex.guidance,
                tags: simpleTags,
                sideOptions: sideOptions,
                primaryMuscles: ex.primary_muscles.join(', '),
                anatomicRegions: ex.tags.heatmap ? ex.tags.heatmap.join(', ') : '',
                difficulty: '',
                supersedes: [],
                current: dosageSpec,
                history: [
                    {
                        timestamp: new Date().toISOString(),
                        summary: `${source} (${dosageSummary})`,
                        previous: {},
                        next: dosageSpec,
                        supersedes: []
                    }
                ],
                favorite: false,
                archived: false
            };

            exerciseLibrary.push(newExercise);
            persistExerciseLibrary();
        }

        // Queue for bulk import - process one at a time with dosage prompts
        let bulkImportQueue = [];

        function bulkImportExercises() {
            if (selectedExercisesForImport.size === 0) {
                alert('No exercises selected');
                return;
            }

            // Convert selected IDs to array and filter out already-imported
            bulkImportQueue = Array.from(selectedExercisesForImport).filter(exerciseId => {
                const ex = libraryExercises.find(e => e.id === exerciseId);
                if (!ex) return false;
                // Skip if already imported
                if (exerciseLibrary.find(e => e.id === ex.id)) return false;
                return true;
            });

            if (bulkImportQueue.length === 0) {
                alert('All selected exercises are already in your program');
                selectedExercisesForImport.clear();
                return;
            }

            // Clear selection and close library browser
            selectedExercisesForImport.clear();
            closeLibraryBrowser();

            // Start importing first exercise
            processNextBulkImport();
        }

        function processNextBulkImport() {
            if (bulkImportQueue.length === 0) {
                // All done!
                alert('All exercises imported successfully!');
                haptic('success');
                return;
            }

            // Get next exercise ID and show dosage prompt
            const exerciseId = bulkImportQueue.shift();
            const ex = libraryExercises.find(e => e.id === exerciseId);
            if (ex) {
                showDosagePrompt(ex);
            } else {
                // Skip if not found, continue to next
                processNextBulkImport();
            }
        }

        function closeLibraryBrowser() {
            document.getElementById('library-browser-modal').classList.remove('active');
            haptic('medium');
        }

        Object.assign(window, {
            showQuickSwitcher,
            showWeeklyStats,
            showExerciseDetailsModal,
            showLibraryDiagnostics,
            // Expose for inline "Close" button in the library diagnostics modal.
            closeLibraryDiagnostics,
            toggleHamburgerMenu,
            showSettings,
            exportForPT,
            importPTModifications,
            endSessionEarly,
            incrementCounter,
            startTimer,
            stopTimer,
            resetTimer,
            logPartialTimerRep,
            previousSet,
            showLogSetModal,
            completeSet,
            showExerciseList,
            showHistory,
            togglePocketMode,
            closeExerciseModal,
            closeExerciseList,
            saveExercise,
            showPlanSessionModal,
            showLibraryBrowser,
            showArchivedExercises,
            showDataBackup,
            closeFormParamsModal,
            skipFormParams,
            saveFormParams,
            closeSessionNotesModal,
            skipFormParams,
            saveFormParams,
            confirmSkipNotes,
            saveSessionWithNotes,
            closeLogSetModal,
            saveLoggedSet,
            closeExerciseDetailsModal,
            saveExerciseDetails,
            skipRest,
            closeRestTimer,
            closeQuickSwitcher,
            exportWeeklySummary,
            reloadApp,
            addSetToEditSession,
            updateEditSessionSet,
            deleteSession,
            closeEditSession,
            saveEditedSession,
            closeHistoryModal,
            closeAllSessions,
            closeWeeklyStats,
            showAllSessions,
            closeAllSessions,
            closeWeeklyStats,
            showAllSessions,
            closeExerciseProgress,
            closeLibraryBrowser,
            bulkImportExercises,
            closeExerciseDetail,
            importLibraryExercise,
            exportAllData,
            exportExerciseLibrary,
            exportExerciseHistory,
            closeDataBackup,
            closeSettings,
            closeDosagePrompt,
            confirmDosage,
            closeEditDosage,
            saveEditedDosage,
            closePlanSessionModal,
            startPlannedSession,
            hideActionSheet,
            confirmActionSheet,
            closeExportPTModal,
            copyPtPayloadOnly,
            sendToPT,
            closeImportPTModal,
            processPastedImport,
            handlePocketTap,
            selectCurrentSide,
            selectLogSetSide,
            quickStartExercise,
            toggleExerciseInPlan,
            switchToPlannedExercise,
            showExerciseProgress,
            editSession,
            deleteEditSessionSet,
            selectExerciseFromList,
            toggleFilterTag,
            unarchiveExercise,
            permanentlyDeleteExercise,
            toggleFavorite,
            showEditDosageModal,
            archiveExercise,
            quickSwitchTo,
            toggleExerciseSelection,
            toggleShowOnlyNew,
            showExerciseDetail
        });

        // Auth button event listeners
        document.getElementById('auth-signin-btn').addEventListener('click', handleSignIn);
        document.getElementById('auth-signup-btn').addEventListener('click', handleSignUp);
        document.getElementById('auth-forgot-password').addEventListener('click', handleForgotPassword);
        document.getElementById('auth-skip-btn').addEventListener('click', hideAuthModal);

        // Menu auth button event listeners
        document.getElementById('menu-signin-btn').addEventListener('click', handleMenuSignIn);
        document.getElementById('menu-signout-btn').addEventListener('click', handleMenuSignOut);

        // Allow Enter key to submit auth form
        document.getElementById('auth-password').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleSignIn();
            }
        });

        // Check for #signin hash (from coverage page redirect)
        if (window.location.hash === '#signin') {
            window.location.hash = ''; // Clear hash
            setTimeout(() => {
                if (!currentUser) {
                    showAuthModal();
                }
            }, 500); // Wait for auth state to be ready
        }

        // Initialize
        loadPreferences(); // Load user preferences
        document.getElementById('header-version').textContent = APP_VERSION; // Show version in header
        updateDisplay();
        updateStreakDisplay();
        // updateQuickStartShortcuts(); // REMOVED: Quick Start section removed
        setTimeout(checkSessionRecovery, 500); // Check for recovery after UI loads
        void reconcileSharedExerciseLibrary();
        // Mark app boot complete to suppress the load-failed overlay.
        window.appBooted = true;
        const loadWarning = document.getElementById('app-load-warning');
        if (loadWarning) loadWarning.style.display = 'none';

        // Register Service Worker for offline support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw-pt.js')
                    .then(registration => {
                        console.log('PT Tracker SW registered:', registration.scope);
                    })
                    .catch(error => {
                        console.log('PT Tracker SW registration failed:', error);
                    });
            });
        }
    </script>
</body>
</html>
