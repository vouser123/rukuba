<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>PT Exercise Editor</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        :root {
            --ios-blue: #007AFF;
            --ios-green: #34C759;
            --ios-red: #FF3B30;
            --ios-orange: #FF9500;
            --ios-gray: #8E8E93;
            --bg-primary: #FFFFFF;
            --bg-secondary: #F2F2F7;
            --text-primary: #000000;
            --text-secondary: #3C3C43;
            --border-color: #C6C6C8;
            --input-bg: #FFFFFF;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-primary: #000000;
                --bg-secondary: #1C1C1E;
                --text-primary: #FFFFFF;
                --text-secondary: #EBEBF5;
                --border-color: #38383A;
                --input-bg: #1C1C1E;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 16px;
            padding-bottom: 80px;
        }

        .header {
            position: sticky;
            top: 0;
            background: var(--bg-secondary);
            padding: 16px 0;
            z-index: 100;
            margin-bottom: 16px;
        }

        h1 { font-size: 28px; margin-bottom: 8px; }

        .button {
            background: var(--ios-blue);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin: 8px 0;
        }

        .button:active { opacity: 0.7; }
        .button-secondary { background: var(--ios-gray); }
        .button-success { background: var(--ios-green); }
        .button-danger { background: var(--ios-red); }

        .card {
            background: var(--bg-primary);
            border-radius: 12px;
            padding: 16px;
            margin: 12px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .exercise-list-item {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
        }

        .exercise-list-item:active { background: var(--bg-secondary); }

        .input, .textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--input-bg);
            color: var(--text-primary);
            font-size: 16px;
            margin: 8px 0;
        }

        .textarea {
            min-height: 100px;
            resize: vertical;
            font-family: inherit;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
        }

        .label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            margin: 12px 0 4px 0;
        }

        .hint {
            font-size: 12px;
            color: var(--ios-gray);
            margin: 4px 0 8px 0;
        }

        .array-item {
            display: flex;
            gap: 8px;
            margin: 8px 0;
            align-items: center;
        }

        .array-item input { flex: 1; margin: 0; }

        .remove-btn {
            background: var(--ios-red);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .add-btn {
            background: var(--ios-green);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin: 8px 0;
        }

        .intent-toggle {
            display: flex;
            gap: 8px;
            margin: 8px 0;
        }

        .intent-option {
            flex: 1;
            padding: 8px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            font-size: 14px;
        }

        .intent-option.active {
            border-color: var(--ios-blue);
            background: rgba(0, 122, 255, 0.1);
            font-weight: 600;
        }

        .section {
            margin: 20px 0;
            padding: 16px;
            background: var(--bg-primary);
            border-radius: 12px;
        }

        .section-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 12px;
            color: var(--ios-blue);
        }

        .validation-errors {
            background: rgba(255, 59, 48, 0.1);
            border: 2px solid var(--ios-red);
            border-radius: 8px;
            padding: 12px;
            margin: 12px 0;
        }

        .error-item {
            padding: 8px;
            margin: 4px 0;
            cursor: pointer;
            border-radius: 4px;
        }

        .error-item:active { background: rgba(255, 59, 48, 0.2); }

        .hidden { display: none; }

        .enum-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 8px;
            margin: 8px 0;
        }

        .enum-option {
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            font-size: 14px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: inherit;
            -webkit-appearance: none;
            -webkit-tap-highlight-color: transparent;
        }

        .enum-option:active {
            opacity: 0.7;
        }

        .enum-option.selected {
            border-color: var(--ios-blue);
            background: rgba(0, 122, 255, 0.1);
            font-weight: 600;
        }

        .quick-start-btn {
            white-space: normal;
            word-wrap: break-word;
            text-align: left;
            line-height: 1.4;
        }

        .bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            padding: 12px 16px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            display: flex;
            gap: 8px;
        }

        .bottom-bar .button { margin: 0; }
    </style>
</head>
<body>
    <div class="header">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h1>PT Exercise Editor</h1>
            <a href="./pt_tracker.html" style="background: var(--ios-gray); color: white; text-decoration: none; padding: 8px 16px; border-radius: 8px; font-size: 14px; font-weight: 600;">‚Üê Back to Tracker</a>
        </div>
        <div style="font-size: 14px; color: var(--text-secondary);">Schema-driven exercise management</div>
    </div>

    <div id="list-view">
        <div class="card">
            <button class="button button-success" onclick="createNewExercise()">+ Create New Exercise</button>
            <button class="button button-secondary" onclick="showExportDialog()">üì§ Export All Data</button>
            <button class="button button-secondary" onclick="reloadFromJSON()">üîÑ Reload from JSON</button>
        </div>

        <!-- Debug Panel -->
        <div id="debug-panel" class="card" style="background: var(--bg-tertiary); border-left: 4px solid var(--ios-blue); font-size: 13px; font-family: monospace;">
            <div style="font-weight: 600; margin-bottom: 8px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto;">üìä Debug Info</div>
            <div id="debug-output" style="white-space: pre-wrap; color: var(--text-secondary);"></div>
        </div>

        <div class="card">
            <h2 style="font-size: 20px; margin-bottom: 12px;">Exercises</h2>
            <div id="exercise-list"></div>
        </div>
    </div>

    <div id="editor-view" class="hidden">
        <button class="button button-secondary" onclick="backToList()">‚Üê Back to List</button>
        <div id="editor-form"></div>
        <div style="height: 80px;"></div>
        <div class="bottom-bar">
            <button class="button button-success" onclick="saveAndBackToList()" style="flex: 2;">üíæ Save</button>
            <button class="button button-danger" onclick="deleteExercise()" style="flex: 1;">üóë Delete</button>
        </div>
        <div style="position: fixed; bottom: 80px; left: 0; right: 0; padding: 0 16px;" id="draft-actions">
            <div style="display: flex; gap: 8px; background: var(--bg-primary); padding: 8px; border-radius: 12px; box-shadow: 0 -2px 10px rgba(0,0,0,0.1);">
                <button class="button button-secondary" onclick="discardDraft()" style="flex: 1; padding: 8px; font-size: 14px;">‚Ü©Ô∏è Discard Draft</button>
                <button class="button button-success" onclick="commitDraft()" style="flex: 1; padding: 8px; font-size: 14px;">‚úì Commit Draft</button>
            </div>
        </div>
    </div>

    <!-- Supersedes Selection Modal -->
    <div id="supersedes-modal" class="hidden" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 9999; display: none;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--bg-primary); border-radius: 12px; max-width: 500px; width: 90%; max-height: 80vh; overflow: hidden; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
            <div style="padding: 16px; border-bottom: 1px solid var(--border-color);">
                <h3 style="margin: 0; font-size: 18px;">Select Exercises to Supersede</h3>
                <input type="text" id="supersedes-search" placeholder="Search exercises..." style="width: 100%; padding: 8px; margin-top: 12px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 14px;" oninput="filterSupersedes(this.value)">
            </div>
            <div id="supersedes-list" style="max-height: 400px; overflow-y: auto; padding: 8px;">
                <!-- Populated by JS -->
            </div>
            <div style="padding: 12px; border-top: 1px solid var(--border-color); display: flex; gap: 8px;">
                <button class="button button-secondary" onclick="closeSupersedesModal()" style="flex: 1;">Cancel</button>
                <button class="button button-success" onclick="saveSupersedesSelection()" style="flex: 1;">Save Selection</button>
            </div>
        </div>
    </div>

    <div id="export-dialog" class="hidden">
        <div class="card">
            <h2 style="font-size: 20px; margin-bottom: 12px;">Export Data</h2>
            <div id="validation-results"></div>
            <div style="font-size: 13px; color: var(--text-secondary); margin: 12px 0; line-height: 1.5;">
                Email address is optional. Copy the payload only or open your email client with the payload ready to send.
            </div>
            <input type="email" id="editor-email" placeholder="recipient@example.com" style="
                width: 100%;
                padding: 10px;
                border: 1px solid var(--border-color);
                border-radius: 8px;
                margin-bottom: 10px;
                font-size: 14px;
            ">
            <textarea id="editor-note" placeholder="Optional: Add a note" style="
                width: 100%;
                min-height: 80px;
                padding: 10px;
                border: 1px solid var(--border-color);
                border-radius: 8px;
                font-size: 14px;
                resize: vertical;
                margin-bottom: 12px;
            "></textarea>
            <button class="button button-success" onclick="downloadExport()" id="download-btn">üì• Download JSON</button>
            <button class="button button-success" onclick="copyExercisePayloadOnly()" id="copy-btn">üìã Copy Payload Only</button>
            <button class="button button-success" onclick="sendExercisePayloadEmail()" id="send-btn">üìß Send Email</button>
            <button class="button button-secondary" onclick="hideExportDialog()">Cancel</button>
        </div>
    </div>

    <script src="pt_payload_utils.js"></script>
    <script src="shared/exercise_form_module.js"></script>
    <script type="module">
        import { ulid } from "https://cdn.jsdelivr.net/npm/ulid@2.3.0/dist/index.esm.js";
        window.ulid = ulid;
    </script>
    <script type="module">
        import {
            loadExerciseLibraryShared,
            loadExerciseFileSchemaShared
        } from './shared/firestore_shared_data.js';

        window.sharedDataLoader = {
            loadExerciseLibraryShared,
            loadExerciseFileSchemaShared
        };
    </script>
    <script>
        function generateULID() {
            return window.ulid();
        }

        // Debug helper
        function debugLog(message) {
            console.log(message);
            const debugOutput = document.getElementById('debug-output');
            if (debugOutput) {
                debugOutput.textContent += message + '\n';
            }
        }

        // State
        const exerciseFormModule = window.exerciseFormModule;
        let schema = null;
        let resolvedExerciseSchema = null;
        let baselineExercises = [];
        let drafts = {};
        let currentExerciseId = null;
        let exportData = null;

        // Resolve $refs in schema
        function resolveRef(ref, rootSchema) {
            if (!ref || !ref.startsWith('#/')) return null;
            const path = ref.substring(2).split('/');
            let resolved = rootSchema;
            for (const part of path) {
                resolved = resolved[part];
                if (!resolved) return null;
            }
            return resolved;
        }

        function resolveSchema(schemaNode, rootSchema) {
            if (!schemaNode || typeof schemaNode !== 'object') return schemaNode;

            if (schemaNode.$ref) {
                const resolved = resolveRef(schemaNode.$ref, rootSchema);
                return resolveSchema(resolved, rootSchema);
            }

            const result = Array.isArray(schemaNode) ? [] : {};
            for (const key in schemaNode) {
                if (key === '$ref') continue;
                result[key] = resolveSchema(schemaNode[key], rootSchema);
            }
            return result;
        }

        // Create empty exercise from schema
        function createEmptyExerciseFromSchema(exerciseId) {
            return exerciseFormModule.createEmptyExercise({
                schema: resolvedExerciseSchema,
                id: exerciseId
            });
        }

        // Dynamic form rendering
        function renderEditor(exercise) {
            const form = document.getElementById('editor-form');
            const props = resolvedExerciseSchema.properties;
            const required = resolvedExerciseSchema.required || [];

            let html = '';

            // Group fields by type for better UX
            const topLevelFields = [];
            const objectFields = {};

            for (const fieldName in props) {
                if (fieldName === 'id') continue;

                const fieldSchema = props[fieldName];
                const types = Array.isArray(fieldSchema.type) ? fieldSchema.type : [fieldSchema.type];
                const primaryType = types.find(t => t !== 'null') || types[0];

                if (primaryType === 'object') {
                    objectFields[fieldName] = fieldSchema;
                } else {
                    topLevelFields.push(fieldName);
                }
            }

            // Exercise ID (readonly, special case)
            html += '<div class="section">';
            html += '<div class="label">Exercise ID (Auto-generated)</div>';
            html += `<input type="text" class="input" value="${exercise.id}" readonly disabled style="opacity: 0.6;">`;
            html += '</div>';

            // Render top-level fields
            html += '<div class="section">';
            html += '<div class="section-title">Exercise Details</div>';
            for (const fieldName of topLevelFields) {
                html += renderField(fieldName, props[fieldName], exercise[fieldName], required.includes(fieldName), []);
            }
            html += '</div>';

            // Render object fields (nested)
            for (const fieldName in objectFields) {
                html += '<div class="section">';
                html += `<div class="section-title">${formatFieldName(fieldName)}</div>`;
                const fieldSchema = objectFields[fieldName];
                const value = exercise[fieldName] || {};

                if (fieldSchema.properties) {
                    for (const subFieldName in fieldSchema.properties) {
                        const subFieldSchema = fieldSchema.properties[subFieldName];
                        const subRequired = fieldSchema.required || [];
                        html += renderField(subFieldName, subFieldSchema, value[subFieldName], subRequired.includes(subFieldName), [fieldName]);
                    }
                }
                html += '</div>';
            }

            form.innerHTML = html;
        }

        function renderField(fieldName, fieldSchema, value, isRequired, parentPath) {
            const fullPath = [...parentPath, fieldName].join('.');
            const label = formatFieldName(fieldName) + (isRequired ? ' *' : '');
            const hint = fieldSchema.description || '';
            const types = Array.isArray(fieldSchema.type) ? fieldSchema.type : [fieldSchema.type];
            const isNullable = types.includes('null');
            const primaryType = types.find(t => t !== 'null') || types[0];

            let html = '';

            // Special case: supersedes field - render as multi-select of exercises
            if (fieldName === 'supersedes') {
                return renderSupersedesField(fullPath, label, value, hint);
            }

            if (primaryType === 'array') {
                if (fieldSchema.items && fieldSchema.items.enum) {
                    // Multi-select enum
                    html += renderMultiSelectEnum(fullPath, label, value, fieldSchema.items.enum, hint);
                } else {
                    // Array of strings
                    html += renderArrayField(fullPath, label, value, hint);
                }
            } else if (primaryType === 'string') {
                if (fieldSchema.enum) {
                    // Single-select enum
                    html += renderEnumField(fullPath, label, value, fieldSchema.enum, hint);
                } else if (fieldSchema.format === 'date') {
                    // Date field
                    if (isNullable) {
                        html += renderNullableDateField(fullPath, label, value, hint);
                    } else {
                        html += renderDateField(fullPath, label, value, hint);
                    }
                } else if (fieldSchema.minLength && fieldSchema.minLength > 50) {
                    // Long text
                    html += renderTextareaField(fullPath, label, value, hint);
                } else {
                    // Regular text
                    html += renderTextField(fullPath, label, value, hint);
                }
            } else {
                // Fallback
                html += renderTextField(fullPath, label, value, hint);
            }

            return html;
        }

        function formatFieldName(name) {
            return name.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        }

        function renderTextField(path, label, value, hint) {
            let html = `<div class="label">${label}</div>`;
            if (hint) html += `<div class="hint">${hint}</div>`;
            const normalizedValue = exerciseFormModule.normalizeValueForPath(path, value || '');
            html += `<input type="text" class="input" value="${normalizedValue}" onchange="updateFieldByPath('${path}', this.value)">`;
            return html;
        }

        function renderTextareaField(path, label, value, hint) {
            let html = `<div class="label">${label}</div>`;
            if (hint) html += `<div class="hint">${hint}</div>`;
            html += `<textarea class="textarea" onchange="updateFieldByPath('${path}', this.value)">${value || ''}</textarea>`;
            return html;
        }

        function renderDateField(path, label, value, hint) {
            let html = `<div class="label">${label}</div>`;
            if (hint) html += `<div class="hint">${hint}</div>`;
            html += `<input type="date" class="input" value="${value || ''}" onchange="updateFieldByPath('${path}', this.value)">`;
            return html;
        }

        function renderNullableDateField(path, label, value, hint) {
            const containerId = 'container_' + path.replace(/\./g, '_');
            const intent = value === null ? 'null' : 'set';

            let html = `<div class="label">${label}</div>`;
            if (hint) html += `<div class="hint">${hint}</div>`;
            html += `<div class="intent-toggle">
                <div class="intent-option ${intent === 'null' ? 'active' : ''}" onclick="setDateIntent('${path}', 'null')">Not Set</div>
                <div class="intent-option ${intent === 'set' ? 'active' : ''}" onclick="setDateIntent('${path}', 'set')">Set Date</div>
            </div>`;
            html += `<div id="${containerId}">`;
            if (intent === 'set') {
                html += `<input type="date" class="input" value="${value || ''}" onchange="updateFieldByPath('${path}', this.value)">`;
            }
            html += `</div>`;
            return html;
        }

        function renderEnumField(path, label, value, enumValues, hint) {
            let html = `<div class="label">${label}</div>`;
            if (hint) html += `<div class="hint">${hint}</div>`;
            html += '<div class="enum-grid">';
            enumValues.forEach(val => {
                const selected = value === val ? 'selected' : '';
                html += `<div class="enum-option ${selected}" onclick="updateFieldByPath('${path}', '${val}'); this.parentElement.querySelectorAll('.enum-option').forEach(el => el.classList.remove('selected')); this.classList.add('selected');">${val.replace(/_/g, ' ')}</div>`;
            });
            html += '</div>';
            return html;
        }

        function renderArrayField(path, label, values, hint) {
            const containerId = 'container_' + path.replace(/\./g, '_');
            let html = `<div class="label">${label}</div>`;
            if (hint) html += `<div class="hint">${hint}</div>`;
            html += `<div id="${containerId}">`;
            (values || []).forEach((val, idx) => {
                const normalizedValue = exerciseFormModule.normalizeValueForPath(path, val || '');
                html += `<div class="array-item">
                    <input type="text" class="input" value="${normalizedValue}" onchange="updateArrayItemByPath('${path}', ${idx}, this.value)">
                    <button class="remove-btn" onclick="removeArrayItemByPath('${path}', ${idx})">‚àí</button>
                </div>`;
            });
            html += `</div>`;
            html += `<button class="add-btn" onclick="addArrayItemByPath('${path}')">+ Add Item</button>`;
            return html;
        }

        function renderMultiSelectEnum(path, label, selected, enumValues, hint) {
            let html = `<div class="label">${label}</div>`;
            if (hint) html += `<div class="hint">${hint}</div>`;
            html += `<div style="display: flex; flex-wrap: wrap; gap: 8px; margin: 8px 0;">`;
            enumValues.forEach(val => {
                const isSelected = (selected || []).includes(val);
                const selectedClass = isSelected ? 'selected' : '';
                html += `<button type="button" class="enum-option ${selectedClass}" onclick="toggleEnumValueByPath('${path}', '${val}', this)">${val}</button>`;
            });
            html += '</div>';
            return html;
        }

        function renderSupersedesField(path, label, selectedIds, hint) {
            let html = `<div class="label">${label}</div>`;
            if (hint) html += `<div class="hint">${hint}</div>`;

            // Get list of all exercises except the current one
            const allExercises = [...baselineExercises];
            Object.keys(drafts).forEach(id => {
                const existingIndex = allExercises.findIndex(ex => ex.id === id);
                if (existingIndex >= 0) {
                    allExercises[existingIndex] = drafts[id];
                } else {
                    allExercises.push(drafts[id]);
                }
            });

            // Filter out current exercise
            const availableExercises = allExercises.filter(ex => ex.id !== currentExerciseId);

            if (availableExercises.length === 0) {
                html += `<div style="color: var(--text-secondary); font-size: 14px; margin: 8px 0;">No other exercises available</div>`;
                return html;
            }

            // Sort by name
            availableExercises.sort((a, b) => {
                const nameA = a.canonical_name || a.name || '';
                const nameB = b.canonical_name || b.name || '';
                return nameA.localeCompare(nameB);
            });

            // Store available exercises for modal
            window.supersedesData = {
                path: path,
                availableExercises: availableExercises,
                selectedIds: selectedIds || []
            };

            // Show selected count and button to open modal
            const selectedCount = (selectedIds || []).length;
            const selectedNames = (selectedIds || []).map(id => {
                const ex = availableExercises.find(e => e.id === id);
                return ex ? (ex.canonical_name || ex.name || id) : id;
            });

            html += `<div style="margin: 8px 0;">`;
            if (selectedCount > 0) {
                html += `<div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 8px; padding: 8px; background: rgba(0,122,255,0.05); border-radius: 8px;">`;
                html += `<strong>${selectedCount} exercise${selectedCount > 1 ? 's' : ''} selected:</strong><br>`;
                html += selectedNames.join(', ');
                html += `</div>`;
            }
            html += `<button type="button" class="button button-secondary" onclick="openSupersedesModal()">üìù Select Exercises to Supersede</button>`;
            html += `</div>`;

            return html;
        }

        // Field update functions
        function updateFieldByPath(path, value) {
            const current = getCurrentExercise();
            const parts = path.split('.');
            const updated = JSON.parse(JSON.stringify(current));

            let obj = updated;
            for (let i = 0; i < parts.length - 1; i++) {
                obj = obj[parts[i]];
            }
            obj[parts[parts.length - 1]] = exerciseFormModule.normalizeValueForPath(path, value);

            drafts[currentExerciseId] = updated;
            saveDrafts();
        }

        function updateArrayItemByPath(path, index, value) {
            const current = getCurrentExercise();
            const parts = path.split('.');
            const updated = JSON.parse(JSON.stringify(current));

            let obj = updated;
            for (let i = 0; i < parts.length - 1; i++) {
                obj = obj[parts[i]];
            }
            const arr = obj[parts[parts.length - 1]];
            arr[index] = exerciseFormModule.normalizeValueForPath(path, value);

            drafts[currentExerciseId] = updated;
            saveDrafts();
        }

        function removeArrayItemByPath(path, index) {
            const current = getCurrentExercise();
            const parts = path.split('.');
            const updated = JSON.parse(JSON.stringify(current));

            let obj = updated;
            for (let i = 0; i < parts.length - 1; i++) {
                obj = obj[parts[i]];
            }
            const arr = obj[parts[parts.length - 1]];
            arr.splice(index, 1);

            drafts[currentExerciseId] = updated;
            saveDrafts();
            editExercise(currentExerciseId); // Re-render
        }

        function addArrayItemByPath(path) {
            const current = getCurrentExercise();
            const parts = path.split('.');
            const updated = JSON.parse(JSON.stringify(current));

            let obj = updated;
            for (let i = 0; i < parts.length - 1; i++) {
                obj = obj[parts[i]];
            }
            const arr = obj[parts[parts.length - 1]];
            arr.push('');

            drafts[currentExerciseId] = updated;
            saveDrafts();
            editExercise(currentExerciseId); // Re-render
        }

        function toggleEnumValueByPath(path, value, element) {
            try {
                console.log('[toggleEnumValueByPath] path:', path, 'value:', value);
                const current = getCurrentExercise();
                const parts = path.split('.');
                const updated = JSON.parse(JSON.stringify(current));

                let obj = updated;
                for (let i = 0; i < parts.length - 1; i++) {
                    obj = obj[parts[i]];
                }

                // Ensure array exists
                const fieldName = parts[parts.length - 1];
                if (!obj[fieldName]) {
                    obj[fieldName] = [];
                    console.log('[toggleEnumValueByPath] Initialized empty array for', fieldName);
                }
                const arr = obj[fieldName];

                const index = arr.indexOf(value);
                if (index >= 0) {
                    arr.splice(index, 1);
                    element.classList.remove('selected');
                    console.log('[toggleEnumValueByPath] Removed', value, 'from', fieldName);
                } else {
                    arr.push(value);
                    element.classList.add('selected');
                    console.log('[toggleEnumValueByPath] Added', value, 'to', fieldName);
                }

                drafts[currentExerciseId] = updated;
                saveDrafts();
                console.log('[toggleEnumValueByPath] Draft saved, array now:', arr);
            } catch (e) {
                console.error('[toggleEnumValueByPath] Error:', e);
                alert('Error toggling value: ' + e.message);
            }
        }

        // Supersedes modal functions
        let tempSupersedesSelection = [];

        function openSupersedesModal() {
            const data = window.supersedesData;
            if (!data) return;

            tempSupersedesSelection = [...data.selectedIds];
            const modal = document.getElementById('supersedes-modal');
            const list = document.getElementById('supersedes-list');

            // Render all exercises
            renderSupersedesList(data.availableExercises);

            modal.style.display = 'block';
            modal.classList.remove('hidden');
        }

        function renderSupersedesList(exercises) {
            const list = document.getElementById('supersedes-list');
            list.innerHTML = exercises.map(ex => {
                const exerciseId = ex.id;
                const exerciseName = ex.canonical_name || ex.name || exerciseId;
                const isSelected = tempSupersedesSelection.includes(exerciseId);
                return `
                    <div style="padding: 12px; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; gap: 12px;">
                        <input type="checkbox" id="super-${exerciseId}" ${isSelected ? 'checked' : ''} onchange="toggleSupersedesItem('${exerciseId.replace(/'/g, "\\'")}', this.checked)" style="width: 20px; height: 20px;">
                        <label for="super-${exerciseId}" style="flex: 1; cursor: pointer; font-size: 14px;">${exerciseName}</label>
                    </div>
                `;
            }).join('');
        }

        function filterSupersedes(searchTerm) {
            const data = window.supersedesData;
            if (!data) return;

            const filtered = data.availableExercises.filter(ex => {
                const name = (ex.canonical_name || ex.name || '').toLowerCase();
                return name.includes(searchTerm.toLowerCase());
            });

            renderSupersedesList(filtered);
        }

        function toggleSupersedesItem(exerciseId, isChecked) {
            if (isChecked) {
                if (!tempSupersedesSelection.includes(exerciseId)) {
                    tempSupersedesSelection.push(exerciseId);
                }
            } else {
                tempSupersedesSelection = tempSupersedesSelection.filter(id => id !== exerciseId);
            }
        }

        function closeSupersedesModal() {
            const modal = document.getElementById('supersedes-modal');
            modal.style.display = 'none';
            modal.classList.add('hidden');
            document.getElementById('supersedes-search').value = '';
        }

        function saveSupersedesSelection() {
            const data = window.supersedesData;
            if (!data) return;

            const oldSupersedes = data.selectedIds || [];
            const newSupersedes = tempSupersedesSelection;

            // Update the current exercise's supersedes field
            updateFieldByPath(data.path, newSupersedes);

            // Update bidirectional relationships
            const now = new Date().toISOString();

            // 1. For exercises newly added to supersedes list
            newSupersedes.forEach(supersededId => {
                if (!oldSupersedes.includes(supersededId)) {
                    // This exercise is now superseded by current exercise
                    const supersededEx = drafts[supersededId] || baselineExercises.find(ex => ex.id === supersededId);
                    if (supersededEx) {
                        // Create draft if not already exists
                        if (!drafts[supersededId]) {
                            drafts[supersededId] = JSON.parse(JSON.stringify(supersededEx));
                        }
                        drafts[supersededId].superseded_by = currentExerciseId;
                        drafts[supersededId].superseded_date = now;
                        console.log(`[Supersedes] Set ${supersededId} superseded_by to ${currentExerciseId}`);
                    }
                }
            });

            // 2. For exercises removed from supersedes list
            oldSupersedes.forEach(supersededId => {
                if (!newSupersedes.includes(supersededId)) {
                    // This exercise is no longer superseded by current exercise
                    const supersededEx = drafts[supersededId] || baselineExercises.find(ex => ex.id === supersededId);
                    if (supersededEx && supersededEx.superseded_by === currentExerciseId) {
                        // Create draft if not already exists
                        if (!drafts[supersededId]) {
                            drafts[supersededId] = JSON.parse(JSON.stringify(supersededEx));
                        }
                        drafts[supersededId].superseded_by = null;
                        drafts[supersededId].superseded_date = null;
                        console.log(`[Supersedes] Cleared ${supersededId} superseded_by`);
                    }
                }
            });

            saveDrafts();
            closeSupersedesModal();

            // Re-render the editor to show updated selection
            editExercise(currentExerciseId);

            alert(`Updated supersedes relationships!\n\n${newSupersedes.length} exercise${newSupersedes.length !== 1 ? 's' : ''} now superseded by this exercise.`);
        }

        function setDateIntent(path, intent) {
            if (intent === 'null') {
                updateFieldByPath(path, null);
            } else {
                updateFieldByPath(path, new Date().toISOString().split('T')[0]);
            }
            editExercise(currentExerciseId); // Re-render
        }

        // Core functions
        function getCurrentExercise() {
            return drafts[currentExerciseId] || baselineExercises.find(ex => ex.id === currentExerciseId);
        }

        function saveDrafts() {
            localStorage.setItem('pt_exercise_drafts', JSON.stringify(drafts));
        }

        async function init() {
            try {
                debugLog('[Init] Starting exercise editor initialization');
                const sharedLoader = window.sharedDataLoader;
                if (!sharedLoader) {
                    debugLog('[Init] ‚ùå Shared data loader missing on window.sharedDataLoader');
                    throw new Error('Shared data loader unavailable. Try reloading the page.');
                }

                // Get service worker cache version if available
                if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    debugLog(`[SW] Service worker active`);
                    try {
                        const cacheNames = await caches.keys();
                        debugLog(`[SW] Active caches: ${cacheNames.join(', ')}`);
                    } catch (e) {
                        debugLog(`[SW] Could not read cache names: ${e.message}`);
                    }
                } else {
                    debugLog(`[SW] No service worker active`);
                }

                const [schemaData, libraryExercises] = await Promise.all([
                    sharedLoader.loadExerciseFileSchemaShared({
                        fallbackUrl: './schema/exercise_file.schema.json',
                        seedIfMissing: true
                    }),
                    sharedLoader.loadExerciseLibraryShared({
                        fallbackUrl: './exercise_library.json',
                        seedIfMissing: true
                    })
                ]);

                schema = schemaData;

                // Resolve exercise schema with all $refs
                const exerciseSchemaNode = schema.$defs.exercise;
                resolvedExerciseSchema = resolveSchema(exerciseSchemaNode, schema);

                baselineExercises = libraryExercises || [];
                debugLog(`[Init] Loaded ${baselineExercises.length} exercises from shared library`);
                if (baselineExercises.length > 0) {
                    const first3 = baselineExercises.slice(0, 3).map(ex => `  ‚Ä¢ ${ex.canonical_name || ex.name} (${ex.id})`).join('\n');
                    const last3 = baselineExercises.slice(-3).map(ex => `  ‚Ä¢ ${ex.canonical_name || ex.name} (${ex.id})`).join('\n');
                    debugLog(`[Init] First 3:\n${first3}`);
                    debugLog(`[Init] Last 3:\n${last3}`);
                } else {
                    debugLog('[Init] ‚ö†Ô∏è NO EXERCISES LOADED!');
                }

                // Migrate exercise_id ‚Üí id (one-time, idempotent)
                baselineExercises.forEach(ex => {
                    if (ex.exercise_id && !ex.id) {
                        ex.id = ex.exercise_id;
                        delete ex.exercise_id;
                    }
                });

                const stored = localStorage.getItem('pt_exercise_drafts');
                if (stored) {
                    try {
                        drafts = JSON.parse(stored);
                        // Migrate exercise_id ‚Üí id in drafts
                        Object.values(drafts).forEach(ex => {
                            if (ex.exercise_id && !ex.id) {
                                ex.id = ex.exercise_id;
                                delete ex.exercise_id;
                            }
                        });
                    } catch (e) {
                        console.error('Failed to load drafts:', e);
                        drafts = {};
                    }
                }

                renderExerciseList();
            } catch (e) {
                debugLog(`[Init] ‚ùå Failed to load schema or shared data: ${e.message}`);
                alert('Failed to load schema or shared data: ' + e.message);
            }
        }

        function renderExerciseList() {
            const container = document.getElementById('exercise-list');
            const allExercises = [...baselineExercises];

            debugLog(`[Render] Starting render with ${baselineExercises.length} baseline exercises, ${Object.keys(drafts).length} drafts`);

            Object.keys(drafts).forEach(id => {
                const existing = allExercises.findIndex(ex => ex.id === id);
                if (existing >= 0) {
                    allExercises[existing] = { ...allExercises[existing], ...drafts[id], _isDraft: true };
                } else {
                    allExercises.push({ ...drafts[id], _isDraft: true });
                }
            });

            debugLog(`[Render] Total exercises to display: ${allExercises.length}`);

            if (allExercises.length === 0) {
                debugLog('[Render] ‚ö†Ô∏è NO EXERCISES TO DISPLAY!');
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">No exercises yet. Create your first one!</div>';
                return;
            }

            // Get canonical_name field name from schema (first string field likely to be name)
            const nameField = Object.keys(resolvedExerciseSchema.properties).find(key => {
                const prop = resolvedExerciseSchema.properties[key];
                const types = Array.isArray(prop.type) ? prop.type : [prop.type];
                return types.includes('string') && key !== 'id' && !prop.enum;
            }) || 'canonical_name';

            container.innerHTML = allExercises.map(ex => `
                <div class="exercise-list-item" onclick="editExercise('${ex.id}')">
                    <div style="font-weight: 600; font-size: 16px;">${ex[nameField] || 'Unnamed Exercise'}</div>
                    <div style="font-size: 13px; color: var(--text-secondary); margin-top: 4px;">
                        ${ex.id}
                        ${ex._isDraft ? '<span style="color: var(--ios-orange); margin-left: 8px;">‚óè DRAFT</span>' : ''}
                    </div>
                </div>
            `).join('');
        }

        function createNewExercise() {
            const id = generateULID();
            const emptyExercise = createEmptyExerciseFromSchema(id);
            drafts[id] = emptyExercise;
            saveDrafts();
            editExercise(id);
        }

        function editExercise(exerciseId) {
            currentExerciseId = exerciseId;
            const exercise = getCurrentExercise();

            if (!exercise) {
                alert('Exercise not found');
                return;
            }

            renderEditor(exercise);
            document.getElementById('list-view').classList.add('hidden');
            document.getElementById('editor-view').classList.remove('hidden');

            // Show/hide draft actions
            const isDraft = drafts[currentExerciseId] !== undefined;
            const draftActions = document.getElementById('draft-actions');
            draftActions.style.display = isDraft ? 'block' : 'none';
        }

        function backToList() {
            document.getElementById('editor-view').classList.add('hidden');
            document.getElementById('list-view').classList.remove('hidden');
            currentExerciseId = null;
            renderExerciseList();
        }

        function saveAndBackToList() {
            // Already saved via auto-save in updateFieldByPath
            alert('Exercise saved!');
            backToList();
        }

        function discardDraft() {
            if (!confirm('Discard all changes to this exercise?\n\nThis will revert to the baseline version.')) {
                return;
            }

            delete drafts[currentExerciseId];
            saveDrafts();
            alert('Draft discarded! Reverted to baseline.');
            backToList();
        }

        function commitDraft() {
            if (!confirm('Commit this draft?\n\nThis will mark it as the new baseline and remove the DRAFT indicator.')) {
                return;
            }

            // Find and update baseline
            const draft = drafts[currentExerciseId];
            const baselineIndex = baselineExercises.findIndex(ex => ex.id === currentExerciseId);

            if (baselineIndex >= 0) {
                baselineExercises[baselineIndex] = { ...draft };
            } else {
                baselineExercises.push({ ...draft });
            }

            // Remove from drafts
            delete drafts[currentExerciseId];
            saveDrafts();

            alert('Draft committed! This is now the baseline.\n\nReminder: You still need to export the data to save it to a file.');
            backToList();
        }

        function deleteExercise() {
            const exercise = getCurrentExercise();
            const exerciseName = exercise.name || exercise.exercise_name || 'this exercise';

            if (!confirm(`Delete "${exerciseName}"?\n\nThis cannot be undone.`)) {
                return;
            }

            // Remove from drafts
            if (drafts[currentExerciseId]) {
                delete drafts[currentExerciseId];
                saveDrafts();
            }

            // Remove from baseline
            const baselineIndex = baselineExercises.findIndex(ex => ex.id === currentExerciseId);
            if (baselineIndex >= 0) {
                baselineExercises.splice(baselineIndex, 1);
            }

            alert('Exercise deleted!');
            backToList();
        }

        async function reloadFromJSON() {
            if (!confirm('Reload from shared exercise library?\n\nThis will:\n‚Ä¢ Discard ALL drafts\n‚Ä¢ Restore all deleted exercises\n‚Ä¢ Reset to the shared library state\n\nContinue?')) {
                return;
            }

            try {
                const sharedLoader = window.sharedDataLoader;
                if (!sharedLoader) {
                    throw new Error('Shared data loader unavailable. Try reloading the page.');
                }

                // Clear all drafts
                drafts = {};
                localStorage.removeItem('pt_exercise_drafts');

                // Reload from shared library
                baselineExercises = await sharedLoader.loadExerciseLibraryShared({
                    fallbackUrl: './exercise_library.json',
                    seedIfMissing: true
                });
                debugLog(`[Reload] Reloaded ${baselineExercises.length} exercises from shared library`);
                if (baselineExercises.length > 0) {
                    const first3 = baselineExercises.slice(0, 3).map(ex => `  ‚Ä¢ ${ex.canonical_name || ex.name} (${ex.id})`).join('\n');
                    const last3 = baselineExercises.slice(-3).map(ex => `  ‚Ä¢ ${ex.canonical_name || ex.name} (${ex.id})`).join('\n');
                    debugLog(`[Reload] First 3:\n${first3}`);
                    debugLog(`[Reload] Last 3:\n${last3}`);
                } else {
                    debugLog('[Reload] ‚ö†Ô∏è NO EXERCISES LOADED!');
                }

                // Migrate exercise_id ‚Üí id (one-time, idempotent)
                baselineExercises.forEach(ex => {
                    if (ex.exercise_id && !ex.id) {
                        ex.id = ex.exercise_id;
                        delete ex.exercise_id;
                    }
                });

                renderExerciseList();
                alert('‚úì Reloaded from shared library!\n\nAll drafts discarded, exercises restored.');
            } catch (e) {
                alert('Failed to reload from shared library:\n\n' + e.message);
                console.error('Reload error:', e);
            }
        }

        function showExportDialog() {
            const merged = [...baselineExercises];

            Object.keys(drafts).forEach(id => {
                const existing = merged.findIndex(ex => ex.id === id);
                if (existing >= 0) {
                    merged[existing] = drafts[id];
                } else {
                    merged.push(drafts[id]);
                }
            });

            exportData = { exercises: merged };

            const errors = validateExportAgainstSchema(exportData);
            const resultsDiv = document.getElementById('validation-results');

            if (errors.length === 0) {
                resultsDiv.innerHTML = '<div style="color: var(--ios-green); font-weight: 600; padding: 12px;">‚úì Validation passed! Ready to export.</div>';
                document.getElementById('download-btn').disabled = false;
                document.getElementById('copy-btn').disabled = false;
                document.getElementById('send-btn').disabled = false;
            } else {
                resultsDiv.innerHTML = `
                    <div class="validation-errors">
                        <div style="font-weight: 600; margin-bottom: 8px;">‚ö†Ô∏è ${errors.length} Validation Error${errors.length > 1 ? 's' : ''}</div>
                        ${errors.map(err => `<div class="error-item" onclick="alert('${err.replace(/'/g, "\\'")}')">${err}</div>`).join('')}
                    </div>
                `;
                document.getElementById('download-btn').disabled = true;
                document.getElementById('copy-btn').disabled = true;
                document.getElementById('send-btn').disabled = true;
            }

            document.getElementById('list-view').classList.add('hidden');
            document.getElementById('export-dialog').classList.remove('hidden');
        }

        function hideExportDialog() {
            document.getElementById('export-dialog').classList.add('hidden');
            document.getElementById('list-view').classList.remove('hidden');
        }

        function downloadExport() {
            if (!exportData) {
                alert('No export data available');
                return;
            }

            try {
                const jsonStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const dateStr = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                const filename = `exercise_library_${dateStr}.json`;

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.rel = 'noopener';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                setTimeout(() => URL.revokeObjectURL(url), 1000);

                alert(`JSON file downloaded!\n\n${filename}\n\n${exportData.exercises.length} exercises`);
            } catch (err) {
                alert('Failed to download JSON:\n\n' + err.message);
                console.error('Download error:', err);
            }
        }

        function validateExportAgainstSchema(data) {
            const errors = [];

            if (!data.exercises || !Array.isArray(data.exercises)) {
                errors.push('Export data must contain exercises array');
                return errors;
            }

            const required = resolvedExerciseSchema.required || [];
            const props = resolvedExerciseSchema.properties;

            data.exercises.forEach((ex, idx) => {
                const prefix = `Exercise ${idx + 1} (${ex.id}): `;

                // Check required fields from schema
                required.forEach(fieldName => {
                    const fieldSchema = props[fieldName];
                    const value = ex[fieldName];
                    const types = Array.isArray(fieldSchema.type) ? fieldSchema.type : [fieldSchema.type];
                    const isNullable = types.includes('null');

                    // Field is missing entirely
                    if (value === undefined) {
                        errors.push(prefix + `Missing required field: ${fieldName}`);
                        return;
                    }

                    // Field is null but not nullable
                    if (value === null && !isNullable) {
                        errors.push(prefix + `${fieldName} cannot be null`);
                        return;
                    }

                    // Field is empty string (but not null) - only error if not nullable
                    if (value === '' && !isNullable) {
                        errors.push(prefix + `${fieldName} cannot be empty`);
                    }
                });

                // Validate types from schema
                for (const fieldName in props) {
                    if (ex[fieldName] === undefined) continue;

                    const fieldSchema = props[fieldName];
                    const value = ex[fieldName];
                    const types = Array.isArray(fieldSchema.type) ? fieldSchema.type : [fieldSchema.type];
                    const isNullable = types.includes('null');
                    const primaryType = types.find(t => t !== 'null') || types[0];

                    if (value === null && !isNullable) {
                        errors.push(prefix + `${fieldName} cannot be null`);
                        continue;
                    }

                    if (value !== null) {
                        if (primaryType === 'array' && !Array.isArray(value)) {
                            errors.push(prefix + `${fieldName} must be array`);
                        } else if (primaryType === 'object' && (typeof value !== 'object' || Array.isArray(value))) {
                            errors.push(prefix + `${fieldName} must be object`);
                        } else if (primaryType === 'string' && typeof value !== 'string') {
                            errors.push(prefix + `${fieldName} must be string`);
                        }

                        // Check enum values
                        if (fieldSchema.enum && !fieldSchema.enum.includes(value)) {
                            errors.push(prefix + `${fieldName} must be one of: ${fieldSchema.enum.join(', ')}`);
                        }

                        // Check array constraints
                        if (primaryType === 'array' && Array.isArray(value)) {
                            if (fieldSchema.minItems && value.length < fieldSchema.minItems) {
                                errors.push(prefix + `${fieldName} must have at least ${fieldSchema.minItems} items`);
                            }
                            if (fieldSchema.maxItems && value.length > fieldSchema.maxItems) {
                                errors.push(prefix + `${fieldName} must have at most ${fieldSchema.maxItems} items`);
                            }
                        }
                    }
                }
            });

            return errors;
        }

        async function copyExercisePayloadOnly() {
            if (!exportData) return;
            const payload = await ptPayloadUtils.buildV2Block({ type: 'PT_DATA', obj: exportData });
            try {
                await navigator.clipboard.writeText(payload);
                alert('Payload copied. Paste it into the recipient app.');
            } catch (err) {
                console.warn('Clipboard copy failed:', err);
                alert('Unable to copy to clipboard in this browser. Please use Send Email instead.');
            }
        }

        async function sendExercisePayloadEmail() {
            if (!exportData) return;
            const recipient = document.getElementById('editor-email').value.trim();
            const note = document.getElementById('editor-note').value.trim();
            const payload = await ptPayloadUtils.buildV2Block({ type: 'PT_DATA', obj: exportData });
            const subject = `PT Exercise Library Export - ${new Date().toLocaleDateString('en-US')}`;
            const body = `${note ? note + '\\n\\n' : ''}Please paste the payload below into the PT app:\\n\\n${payload}`;
            const mailtoLink = `mailto:${encodeURIComponent(recipient)}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
            window.location.href = mailtoLink;
        }

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
