<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>O&M Timing Practice Prototype</title>
  <style>
    :root {
      color-scheme: light;
      --bg: #f6f4ef;
      --text: #1b1b1b;
      --muted: #6c6c6c;
      --accent: #2f5d62;
      --outline: #1b1b1b;
    }

    body {
      margin: 0;
      font-family: "Helvetica Neue", Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      display: flex;
      min-height: 100vh;
      align-items: center;
      justify-content: center;
    }

    .panel {
      width: min(560px, 90vw);
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 24px;
      padding: 24px;
    }

    .setup {
      background: #fff;
      border: 2px solid var(--outline);
      border-radius: 18px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      text-align: left;
    }

    .setup h2 {
      margin: 0;
      font-size: 1.1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .setup h3 {
      margin: 0 0 8px;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--accent);
    }

    .setup-group {
      border-top: 1px solid #dedad1;
      padding-top: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .setup-group:first-of-type {
      border-top: none;
      padding-top: 0;
    }

    .setup label {
      font-size: 0.9rem;
      color: var(--text);
    }

    .setup input[type="number"] {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 2px solid var(--outline);
      font-size: 1rem;
      margin-top: 6px;
    }

    .sound-options {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    fieldset {
      border: 1px solid #dedad1;
      border-radius: 12px;
      padding: 10px 12px 12px;
      margin: 0;
    }

    legend {
      padding: 0 6px;
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .sound-option {
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 10px;
      padding: 6px 0;
    }

    .sound-option button {
      border: 2px solid var(--outline);
      border-radius: 999px;
      background: #fff;
      padding: 4px 12px;
      cursor: pointer;
      font-size: 0.85rem;
    }

    .sound-option button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .mode-toggle {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
    }

    .mode-toggle label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.95rem;
    }

    .mode-toggle input[type="radio"] {
      accent-color: var(--accent);
    }

    .sound-toggle {
      align-self: center;
      border: 2px solid var(--outline);
      border-radius: 999px;
      padding: 6px 14px;
      background: #fff;
      font-size: 1rem;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }

    .sound-toggle[aria-pressed="false"] {
      opacity: 0.55;
    }

    .markers {
      display: flex;
      justify-content: center;
      gap: 18px;
    }

    .marker {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .marker-shape {
      width: 42px;
      height: 42px;
      border-radius: 50%;
      border: 3px solid var(--outline);
      display: grid;
      place-items: center;
      background: #fff;
    }

    .marker-shape span {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid var(--outline);
    }

    .marker.complete .marker-shape {
      background: var(--accent);
      border-color: var(--accent);
    }

    .marker.complete .marker-shape span {
      border-color: #fff;
      background: #fff;
    }

    .marker.current .marker-shape {
      background: #fff;
      border-style: double;
    }

    .marker label {
      font-size: 0.85rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .action-btn {
      width: min(260px, 70vw);
      height: 180px;
      margin: 0 auto;
      border-radius: 22px;
      border: 4px solid var(--outline);
      background: #fff;
      font-size: 1.2rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
    }

    .action-btn.running {
      background: var(--accent);
      color: #fff;
      border-radius: 40px;
      border-style: double;
    }

    .action-btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .status {
      font-size: 0.95rem;
      color: var(--muted);
      min-height: 1.2rem;
    }
  </style>
</head>
<body>
  <main class="panel">
    <section class="setup" aria-label="Settings and setup">
      <h2>Settings / Setup</h2>
      <div class="setup-group" aria-label="Sound calibration">
        <h3>Sound Calibration</h3>
        <fieldset aria-label="Acceptable feedback sounds">
          <legend>Acceptable (within tolerance)</legend>
          <div class="sound-options">
            <div class="sound-option">
              <input type="radio" id="acceptable-a" name="acceptableSound" value="acceptable-a" />
              <label for="acceptable-a">Chime A</label>
              <button type="button" class="preview-btn" data-sound="acceptable-a" aria-label="Play acceptable sound option A">Play</button>
            </div>
            <div class="sound-option">
              <input type="radio" id="acceptable-b" name="acceptableSound" value="acceptable-b" />
              <label for="acceptable-b">Chime B</label>
              <button type="button" class="preview-btn" data-sound="acceptable-b" aria-label="Play acceptable sound option B">Play</button>
            </div>
          </div>
        </fieldset>
        <fieldset aria-label="Out of bounds feedback sounds">
          <legend>Out of bounds (outside tolerance)</legend>
          <div class="sound-options">
            <div class="sound-option">
              <input type="radio" id="outside-a" name="outsideSound" value="outside-a" />
              <label for="outside-a">Low Pulse A</label>
              <button type="button" class="preview-btn" data-sound="outside-a" aria-label="Play out of bounds sound option A">Play</button>
            </div>
            <div class="sound-option">
              <input type="radio" id="outside-b" name="outsideSound" value="outside-b" />
              <label for="outside-b">Low Pulse B</label>
              <button type="button" class="preview-btn" data-sound="outside-b" aria-label="Play out of bounds sound option B">Play</button>
            </div>
          </div>
        </fieldset>
      </div>
      <div class="setup-group" aria-label="Time entry">
        <h3>Time Entry</h3>
        <label for="clearTime">Time to clear from left (seconds)</label>
        <input id="clearTime" type="number" step="0.1" min="0.1" inputmode="decimal" aria-label="Time to clear from left in seconds" />
        <label for="fullTime">Full street time (seconds)</label>
        <input id="fullTime" type="number" step="0.1" min="0.1" inputmode="decimal" aria-label="Full street time in seconds" />
      </div>
      <div class="setup-group" aria-label="Margin of error">
        <h3>Margin of Error</h3>
        <label for="marginInput">Acceptable margin of error (seconds)</label>
        <input id="marginInput" type="number" step="0.1" min="0" inputmode="decimal" aria-label="Acceptable margin of error in seconds" value="0.4" />
      </div>
    </section>

    <div class="mode-toggle" role="group" aria-label="Mode selection">
      <label>
        <input type="radio" name="mode" value="2" checked aria-label="Start to finish mode" />
        Start â†’ Finish
      </label>
      <label>
        <input type="radio" name="mode" value="3" aria-label="Start boundary finish mode" />
        Start â†’ Boundary â†’ Finish
      </label>
    </div>

    <button class="sound-toggle" id="soundToggle" type="button" aria-pressed="true" aria-label="Toggle sound on or off">
      <span aria-hidden="true">ðŸ”Š</span>
      Sound On
    </button>

    <section class="markers" id="markers"></section>

    <button class="action-btn" id="actionBtn" type="button" aria-label="Begin or mark timing">Begin</button>

    <div class="status" id="statusText">Ready.</div>
  </main>

  <script>
    const actionBtn = document.getElementById("actionBtn");
    const markersEl = document.getElementById("markers");
    const statusText = document.getElementById("statusText");
    const modeInputs = [...document.querySelectorAll("input[name='mode']")];
    const soundToggle = document.getElementById("soundToggle");
    const clearTimeInput = document.getElementById("clearTime");
    const fullTimeInput = document.getElementById("fullTime");
    const marginInput = document.getElementById("marginInput");
    const acceptableInputs = [...document.querySelectorAll("input[name='acceptableSound']")];
    const outsideInputs = [...document.querySelectorAll("input[name='outsideSound']")];
    const previewButtons = [...document.querySelectorAll(".preview-btn")];
    const setupControls = [
      clearTimeInput,
      fullTimeInput,
      marginInput,
      ...acceptableInputs,
      ...outsideInputs,
      ...previewButtons
    ];

    const modes = {
      2: { labels: ["Start", "Finish"] },
      3: { labels: ["Start", "Boundary", "Finish"] }
    };

    let audioContext;
    let soundEnabled = true;
    let markerTimes = [];
    let currentMode = 2;
    let stage = 0;
    let started = false;
    let replayTimeout;

    const tones = {
      confirm: { base: 350, harmonic: 700 },
      user: { base: 410 },
      reference: { acceptable: 600, outside: 320 }
    };

    const feedbackOptions = {
      acceptable: {
        "acceptable-a": {
          label: "Chime A",
          partials: [
            { freq: 540, gain: 0.22 },
            { freq: 630, gain: 0.12 }
          ]
        },
        "acceptable-b": {
          label: "Chime B",
          partials: [
            { freq: 590, gain: 0.2 },
            { freq: 650, gain: 0.1 }
          ]
        }
      },
      outside: {
        "outside-a": {
          label: "Low Pulse A",
          partials: [
            { freq: 240, gain: 0.2 },
            { freq: 290, gain: 0.08 }
          ]
        },
        "outside-b": {
          label: "Low Pulse B",
          partials: [
            { freq: 260, gain: 0.18 },
            { freq: 300, gain: 0.08 }
          ]
        }
      }
    };

    function ensureAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioContext.state === "suspended") {
        audioContext.resume();
      }
      return audioContext;
    }

    function playCompositeTone(
      partials,
      duration = 0.16,
      startTime = 0,
      allowMuted = false
    ) {
      if (!soundEnabled && !allowMuted) return;
      const context = ensureAudioContext();
      if (context.state === "suspended") {
        context.resume().then(() => {
          playCompositeTone(partials, duration, startTime, allowMuted);
        });
        return;
      }
      const now = context.currentTime + startTime;
      const gain = context.createGain();
      const attack = 0.01;
      const release = 0.07;
      gain.gain.setValueAtTime(0, now);
      gain.gain.linearRampToValueAtTime(0.25, now + attack);
      gain.gain.linearRampToValueAtTime(0, now + duration + release);
      partials.forEach((partial) => {
        const osc = context.createOscillator();
        osc.type = "sine";
        osc.frequency.value = partial.freq;
        const oscGain = context.createGain();
        oscGain.gain.setValueAtTime(partial.gain, now);
        osc.connect(oscGain).connect(gain);
        osc.start(now);
        osc.stop(now + duration + release + 0.02);
      });
      gain.connect(context.destination);
    }

    function playConfirmTone() {
      playCompositeTone(
        [
          { freq: tones.confirm.base, gain: 0.22 },
          { freq: tones.confirm.harmonic, gain: 0.1 }
        ],
        0.18,
        0
      );
    }

    function playUserMarkerTone(startTime = 0) {
      playCompositeTone([{ freq: tones.user.base, gain: 0.2 }], 0.14, startTime);
    }

    function playReferenceTone(pitch, startTime = 0) {
      playCompositeTone([{ freq: pitch, gain: 0.18 }], 0.14, startTime);
    }

    function playFeedbackTone(type, startTime = 0) {
      const selection =
        type === "acceptable"
          ? getSelectedSound("acceptable")
          : getSelectedSound("outside");
      const option = feedbackOptions[type][selection];
      playCompositeTone(option.partials, 0.12, startTime);
    }

    function getSelectedSound(category) {
      const key =
        category === "acceptable"
          ? "om-feedback-acceptable"
          : "om-feedback-outside";
      const inputs = category === "acceptable" ? acceptableInputs : outsideInputs;
      const stored = localStorage.getItem(key);
      const fallback = inputs[0]?.value;
      return stored && feedbackOptions[category][stored] ? stored : fallback;
    }

    function applyStoredSelections() {
      const acceptableSelection = getSelectedSound("acceptable");
      const outsideSelection = getSelectedSound("outside");
      acceptableInputs.forEach((input) => {
        input.checked = input.value === acceptableSelection;
      });
      outsideInputs.forEach((input) => {
        input.checked = input.value === outsideSelection;
      });
      if (acceptableSelection) {
        storeSelection("acceptable", acceptableSelection);
      }
      if (outsideSelection) {
        storeSelection("outside", outsideSelection);
      }
    }

    function storeSelection(category, value) {
      const key =
        category === "acceptable"
          ? "om-feedback-acceptable"
          : "om-feedback-outside";
      localStorage.setItem(key, value);
    }

    function lockSettings(lock) {
      setupControls.forEach((control) => {
        control.disabled = lock;
      });
    }

    function getTimingInputs() {
      return {
        clearTime: Number(clearTimeInput.value),
        fullTime: Number(fullTimeInput.value)
      };
    }

    function getMargin() {
      return Number(marginInput.value);
    }

    function validateSetup() {
      const { clearTime, fullTime } = getTimingInputs();
      const margin = getMargin();
      if (!Number.isFinite(clearTime) || clearTime <= 0) {
        setStatus("Enter a time to clear from left before starting.");
        return false;
      }
      if (!Number.isFinite(fullTime) || fullTime <= 0) {
        setStatus("Enter a full street time before starting.");
        return false;
      }
      if (!Number.isFinite(margin) || margin < 0) {
        setStatus("Enter a margin of error before starting.");
        return false;
      }
      return true;
    }

    function getReferenceTimes() {
      const { clearTime, fullTime } = getTimingInputs();
      if (currentMode === 2) {
        return [0, fullTime];
      }
      return [0, clearTime, fullTime];
    }

    function updateMode() {
      const selected = modeInputs.find((input) => input.checked);
      currentMode = Number(selected.value);
      renderMarkers();
      resetState();
    }

    function renderMarkers() {
      markersEl.innerHTML = "";
      const { labels } = modes[currentMode];
      labels.forEach((label, index) => {
        const item = document.createElement("div");
        item.className = "marker";
        item.dataset.index = String(index);
        item.innerHTML = `
          <div class="marker-shape"><span></span></div>
          <label>${label}</label>
        `;
        markersEl.appendChild(item);
      });
      updateMarkerStates();
    }

    function updateMarkerStates() {
      const markerNodes = [...markersEl.querySelectorAll(".marker")];
      markerNodes.forEach((node, index) => {
        node.classList.toggle("complete", index < stage);
        node.classList.toggle("current", index === stage && started);
      });
    }

    function setStatus(message) {
      statusText.textContent = message;
    }

    function lockModeSelection(lock) {
      modeInputs.forEach((input) => {
        input.disabled = lock;
      });
    }

    function resetState(message = "Ready.") {
      markerTimes = [];
      stage = 0;
      started = false;
      actionBtn.disabled = false;
      actionBtn.textContent = "Begin";
      setStatus(message);
      updateMarkerStates();
      lockModeSelection(false);
      lockSettings(false);
      actionBtn.classList.remove("running");
    }

    function recordMarker() {
      if (!started) {
        if (!validateSetup()) {
          return;
        }
        started = true;
        lockModeSelection(true);
        lockSettings(true);
        markerTimes = [0];
        stage = 1;
        actionBtn.textContent = "Mark";
        setStatus("Listening for the next marker.");
        playConfirmTone();
        actionBtn.classList.add("running");
        updateMarkerStates();
        return;
      }

      const elapsed = (performance.now() - startTimestamp) / 1000;
      markerTimes.push(elapsed);
      playConfirmTone();
      stage += 1;

      if (stage >= modes[currentMode].labels.length) {
        actionBtn.disabled = true;
        actionBtn.textContent = "Replay";
        setStatus("Replaying your markers and the reference.");
        updateMarkerStates();
        beginReplay();
      } else {
        setStatus("Listening for the next marker.");
        updateMarkerStates();
      }
    }

    function beginReplay() {
      const reference = getReferenceTimes();
      const baseDelay = 0.6;
      const maxTime = Math.max(
        ...markerTimes,
        ...reference
      );

      markerTimes.forEach((time) => {
        playUserMarkerTone(baseDelay + time);
      });

      reference.slice(1).forEach((time, index) => {
        const userTime = markerTimes[index + 1] ?? 0;
        const diff = Math.abs(userTime - time);
        const feedbackType = diff <= getMargin() ? "acceptable" : "outside";
        const pitch = tones.reference[feedbackType];
        playReferenceTone(pitch, baseDelay + time);
      });

      clearTimeout(replayTimeout);
      replayTimeout = setTimeout(() => {
        resetState("Ready for another try.");
      }, (maxTime + baseDelay + 1.2) * 1000);
    }

    let startTimestamp = 0;

    actionBtn.addEventListener("click", () => {
      ensureAudioContext();
      if (!started) {
        startTimestamp = performance.now();
      }
      recordMarker();
    });

    modeInputs.forEach((input) => {
      input.addEventListener("change", updateMode);
    });

    soundToggle.addEventListener("click", () => {
      soundEnabled = !soundEnabled;
      soundToggle.setAttribute("aria-pressed", String(soundEnabled));
      soundToggle.innerHTML = soundEnabled
        ? "<span aria-hidden=\"true\">ðŸ”Š</span> Sound On"
        : "<span aria-hidden=\"true\">ðŸ”‡</span> Sound Off";
      if (soundEnabled) {
        playConfirmTone();
      }
    });

    acceptableInputs.forEach((input) => {
      input.addEventListener("change", () => {
        storeSelection("acceptable", input.value);
      });
    });

    outsideInputs.forEach((input) => {
      input.addEventListener("change", () => {
        storeSelection("outside", input.value);
      });
    });

    previewButtons.forEach((button) => {
      button.addEventListener("click", () => {
        ensureAudioContext();
        const soundId = button.dataset.sound;
        if (feedbackOptions.acceptable[soundId]) {
          playCompositeTone(feedbackOptions.acceptable[soundId].partials, 0.16, 0, true);
          return;
        }
        if (feedbackOptions.outside[soundId]) {
          playCompositeTone(feedbackOptions.outside[soundId].partials, 0.16, 0, true);
        }
      });
    });

    const unlockAudio = () => {
      ensureAudioContext();
      document.removeEventListener("pointerdown", unlockAudio);
      document.removeEventListener("keydown", unlockAudio);
    };

    document.addEventListener("pointerdown", unlockAudio, { once: true });
    document.addEventListener("keydown", unlockAudio, { once: true });

    applyStoredSelections();
    renderMarkers();
  </script>
</body>
</html>
