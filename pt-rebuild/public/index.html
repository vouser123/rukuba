<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PT Tracker</title>
    <link rel="stylesheet" href="main.css">
    <style>
        :root {
            color-scheme: light;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: #f5f5f5;
            overflow-x: hidden;
            touch-action: manipulation; /* Prevent iOS double-tap zoom */
            -webkit-user-select: none;
            user-select: none;
        }

        /* Utility Classes */
        .hidden {
            display: none !important;
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--toast-bg, #333);
            color: var(--toast-text, white);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10001;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            max-width: 90%;
            text-align: center;
            font-size: 1rem;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .toast.error {
            background: var(--toast-error-bg, #dc3545);
        }

        .toast.success {
            background: var(--toast-success-bg, #28a745);
        }

        /* Auth Modal */
        .auth-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .auth-modal.hidden {
            display: none;
        }

        .auth-content {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            max-width: 400px;
            width: 90%;
        }

        .auth-content h2 {
            margin: 0 0 1.5rem 0;
        }

        .auth-form input {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }

        .auth-form button {
            width: 100%;
            padding: 0.75rem;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
        }

        .auth-form button:active {
            background: #0056b3;
        }

        .auth-error {
            color: #d32f2f;
            margin-top: 1rem;
            font-size: 14px;
        }

        /* Header */
        .header {
            background: white;
            padding: 1rem;
            border-bottom: 2px solid #007bff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            margin: 0;
            font-size: 1.5rem;
            color: #007bff;
        }

        .header-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .sync-badge {
            background: #ffc107;
            color: #000;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }

        .sync-badge.hidden {
            display: none;
        }

        .messages-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            background: #dc3545;
            color: white;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 10px;
            font-weight: bold;
            min-width: 16px;
            text-align: center;
        }

        .messages-badge.hidden {
            display: none;
        }

        .btn {
            padding: 0.5rem 1rem;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px; /* Apple HIG minimum touch target */
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-success {
            background: #28a745;
        }

        .btn:active {
            opacity: 0.8;
        }

        /* Hamburger Menu */
        .hamburger-btn {
            background: transparent;
            border: none;
            font-size: 22px;
            cursor: pointer;
            padding: 4px 8px;
            touch-action: manipulation;
        }

        .hamburger-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9998;
        }

        .hamburger-overlay.active {
            display: block;
        }

        .hamburger-menu {
            display: none;
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 280px;
            background: white;
            z-index: 9999;
            box-shadow: -2px 0 8px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
        }

        .hamburger-menu.active {
            display: block;
        }

        .hamburger-header {
            padding: 20px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .hamburger-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .hamburger-close {
            background: transparent;
            border: none;
            color: #007bff;
            font-size: 16px;
            cursor: pointer;
            padding: 8px;
        }

        .hamburger-item {
            padding: 16px 20px;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            text-decoration: none;
            color: inherit;
            touch-action: manipulation;
        }

        .hamburger-item:active {
            background: #f0f0f0;
        }

        .hamburger-icon {
            font-size: 20px;
            width: 24px;
            text-align: center;
        }

        /* Side Tracking */
        .side-tracking {
            background: white;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .side-tracking-label {
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: #666;
        }

        .side-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .side-btn {
            flex: 1;
            padding: 0.75rem;
            background: white;
            border: 2px solid #007bff;
            color: #007bff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px;
        }

        .side-btn.active {
            background: #007bff;
            color: white;
        }

        .side-btn:active {
            opacity: 0.8;
        }

        /* Visual Feedback */
        .log-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(40, 167, 69, 0.95);
            color: white;
            padding: 2rem;
            border-radius: 12px;
            font-size: 3rem;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .log-feedback.show {
            opacity: 1;
        }

        /* Exercise Picker View */
        .view {
            display: none;
            padding: 1rem;
        }

        .view.active {
            display: block;
        }

        .search-container {
            margin-bottom: 1rem;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }

        .exercise-card {
            background: white;
            padding: 1rem;
            margin-bottom: 0.5rem;
            border-radius: 4px;
            border: 1px solid #ddd;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .exercise-card:active {
            background: #f0f0f0;
        }

        .exercise-name {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 0.25rem;
        }

        .exercise-dosage {
            font-size: 0.9rem;
            color: #666;
        }

        .exercise-adherence {
            font-size: 0.8rem;
            font-weight: 600;
            margin-top: 4px;
        }

        .exercise-adherence.green { color: #34C759; }
        .exercise-adherence.orange { color: #FF9500; }
        .exercise-adherence.red { color: #FF3B30; }
        .exercise-adherence.gray { color: #8E8E93; }

        .exercise-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
        }

        .exercise-tag {
            font-size: 0.7rem;
            background: #e0e0e0;
            color: #555;
            padding: 2px 8px;
            border-radius: 12px;
        }

        /* Control Buttons Row */
        .control-buttons {
            display: flex;
            gap: 8px;
            margin-top: 1rem;
            padding: 0 1rem;
        }

        .control-btn {
            flex: 1;
            padding: 14px 12px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            touch-action: manipulation;
        }

        .control-btn-secondary {
            background: #6c757d;
            color: white;
        }

        .control-btn-primary {
            background: #007AFF;
            color: white;
        }

        .control-btn-success {
            background: #34C759;
            color: white;
        }

        .control-btn:active {
            opacity: 0.8;
        }

        /* Logger View */
        .logger-header {
            background: white;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .logger-exercise-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .logger-dosage {
            font-size: 0.9rem;
            color: #666;
        }

        .counter-container {
            background: white;
            padding: 2rem 1rem;
            margin-bottom: 1rem;
            border-radius: 4px;
            border: 1px solid #ddd;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .counter-label {
            font-size: 1rem;
            color: #666;
            margin-bottom: 1.5rem;
        }

        /**
         * Big tappable circle for counting reps.
         * iOS Safari optimized: Large touch target, smooth feedback.
         */
        .counter-display {
            width: min(320px, 85vw);
            height: min(320px, 85vw);
            border-radius: 50%;
            background: var(--counter-bg, white);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 72px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            font-weight: 700;
            color: var(--counter-color, #007bff);
            box-shadow: 0 4px 20px rgba(0, 122, 255, 0.3);
            margin-bottom: 30px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            /* iOS Safari touch fixes for large tap target */
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }

        .counter-display:active {
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(0, 122, 255, 0.2);
        }

        .counter-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 0.5rem;
        }

        .counter-btn {
            padding: 0.5rem 1.5rem;
            border-radius: 8px;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px;
            color: white;
        }

        .counter-btn-minus {
            background: #dc3545;
        }

        .counter-btn-plus {
            background: #28a745;
        }

        .counter-btn:active {
            opacity: 0.8;
        }

        /* Timer Mode */
        .timer-container {
            background: white;
            padding: 2rem 1rem;
            margin-bottom: 1rem;
            border-radius: 4px;
            border: 1px solid #ddd;
            text-align: center;
        }

        .timer-info {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 0.5rem;
        }

        .timer-display {
            font-size: 4rem;
            font-weight: bold;
            color: var(--timer-color, #007bff);
            margin: 1rem 0;
            font-variant-numeric: tabular-nums;
        }

        .timer-target {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 1.5rem;
        }

        .timer-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .timer-btn {
            padding: 0.75rem 2rem;
            border-radius: 4px;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px;
        }

        .timer-btn-start {
            background: #28a745;
            color: white;
        }

        .timer-btn-reset {
            background: #6c757d;
            color: white;
        }

        .timer-btn:active {
            opacity: 0.8;
        }

        .set-info {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        .set-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .log-set-btn {
            width: 100%;
            padding: 1rem;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 0.5rem;
        }

        .log-set-btn:active {
            background: #218838;
        }

        .finish-session-btn {
            width: 100%;
            padding: 1rem;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
        }

        .finish-session-btn:active {
            background: #0056b3;
        }

        /* History View */
        .session-card {
            background: white;
            padding: 1rem;
            margin-bottom: 0.5rem;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .session-date {
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .session-exercise {
            font-size: 0.9rem;
            color: #666;
        }

        .session-sets {
            font-size: 0.85rem;
            color: #999;
            margin-top: 0.25rem;
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            overflow-y: auto;
        }

        .modal.hidden {
            display: none;
        }

        .modal-content {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .modal-header h2 {
            margin: 0;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 2rem;
            height: 2rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .modal-input,
        .modal-select {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 17px; /* Prevent iOS zoom on focus */
            margin-bottom: 12px;
            font-family: inherit;
            background: #f2f2f7;
            color: #111;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            -webkit-appearance: none;
            -webkit-tap-highlight-color: transparent;
        }

        .modal-input:focus,
        .modal-select:focus {
            outline: none;
            box-shadow: 0 0 0 2px #007AFF;
        }

        input[type="number"],
        input[type="text"],
        textarea,
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.25rem;
            font-weight: 500;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 17px; /* >= 16px prevents iOS zoom */
        }

        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }

        .form-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1.5rem;
        }

        .form-actions button {
            flex: 1;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #666;
        }

        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: #666;
        }

        .nav-tabs {
            display: flex;
            background: white;
            border-bottom: 1px solid #ddd;
        }

        .nav-tab {
            flex: 1;
            padding: 1rem;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            border-bottom: 2px solid transparent;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px;
        }

        .nav-tab.active {
            border-bottom-color: #007bff;
            color: #007bff;
            font-weight: bold;
        }

        .nav-tab:active {
            background: #f0f0f0;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                color-scheme: dark;
                --toast-bg: #1f2430;
                --toast-text: #f5f5f5;
                --toast-error-bg: #ff5a5f;
                --toast-success-bg: #3ddc84;
                --counter-bg: #1b1f27;
                --counter-color: #7bb1ff;
                --timer-color: #7bb1ff;
            }

            body {
                background: #0f1115;
                color: #f5f5f5;
            }

            .auth-modal {
                background: rgba(0, 0, 0, 0.85);
            }

            .auth-content,
            .header,
            .hamburger-menu,
            .side-tracking,
            .exercise-card,
            .logger-header,
            .counter-container,
            .timer-container,
            .session-card,
            .modal-content,
            .nav-tabs,
            .set-info {
                background: #1c1f26;
                border-color: #2a2f3a;
            }

            .header {
                border-bottom-color: #4c8dff;
            }

            .header h1,
            .hamburger-close,
            .nav-tab.active {
                color: #4c8dff;
            }

            .sync-badge {
                background: #3a3f4b;
                color: #f5f5f5;
            }

            .auth-form input,
            .search-input,
            .form-group input,
            .form-group select,
            .form-group textarea {
                background: #1b1f27;
                border-color: #2a2f3a;
                color: #f5f5f5;
            }

            .hamburger-header,
            .hamburger-item,
            .nav-tabs {
                border-color: #2a2f3a;
            }

            .hamburger-item:active,
            .exercise-card:active,
            .nav-tab:active {
                background: #232836;
            }

            .side-btn {
                background: #1c1f26;
                border-color: #4c8dff;
                color: #8fb8ff;
            }

            .side-btn.active {
                background: #4c8dff;
                color: #0f1115;
            }

            .side-tracking-label,
            .exercise-dosage,
            .logger-dosage,
            .counter-label,
            .timer-info,
            .timer-target,
            .session-exercise,
            .session-sets,
            .loading,
            .empty-state {
                color: #b5b5b5;
            }

            .modal {
                background: rgba(0, 0, 0, 0.7);
            }

            #formParamsContainer,
            #nextSetParamsContainer {
                background: rgba(76, 141, 255, 0.12) !important;
            }

            #formParamsContainer > div,
            #nextSetParamsContainer > div {
                color: #d5d5d5;
            }

            .exercise-tag {
                background: #3a3f4b;
                color: #b5b5b5;
            }

            .control-btn-secondary {
                background: #4a4f5c;
            }
        }
    </style>
</head>
<body>
    <!-- Auth Modal -->
    <div id="authModal" class="auth-modal">
        <div class="auth-content">
            <h2>PT Tracker Sign In</h2>
            <form id="authForm" class="auth-form">
                <input
                    type="email"
                    id="emailInput"
                    placeholder="Email"
                    required
                    autocomplete="email"
                >
                <input
                    type="password"
                    id="passwordInput"
                    placeholder="Password"
                    required
                    autocomplete="current-password"
                >
                <button type="submit">Sign In</button>
                <div id="authError" class="auth-error"></div>
            </form>
        </div>
    </div>

    <!-- Header -->
    <div class="header">
        <h1>PT Tracker</h1>
        <div class="header-actions">
            <span id="syncBadge" class="sync-badge hidden">0 unsynced</span>
            <button class="hamburger-btn" data-action="toggle-hamburger">‚ò∞</button>
        </div>
    </div>

    <!-- Hamburger Menu -->
    <div class="hamburger-overlay" id="hamburgerOverlay" data-action="toggle-hamburger"></div>
    <div class="hamburger-menu" id="hamburgerMenu">
        <div class="hamburger-header">
            <h3>Menu</h3>
            <button class="hamburger-close" data-action="toggle-hamburger">Close</button>
        </div>
        <div>
            <div class="hamburger-item" data-action="show-messages">
                <span class="hamburger-icon" style="position: relative;">
                    üí¨
                    <span id="messagesBadge" class="messages-badge hidden"></span>
                </span>
                <span>Messages</span>
            </div>
            <a href="pt_editor.html" class="hamburger-item" id="ptEditorLink">
                <span class="hamburger-icon">‚úèÔ∏è</span>
                <span>Exercise Editor</span>
            </a>
            <a href="pt_view.html" class="hamburger-item">
                <span class="hamburger-icon">üìä</span>
                <span>View History</span>
            </a>
            <a href="rehab_coverage.html" class="hamburger-item">
                <span class="hamburger-icon">üìà</span>
                <span>Coverage Analysis</span>
            </a>
            <div class="hamburger-item" data-action="manual-sync">
                <span class="hamburger-icon">üîÑ</span>
                <span>Sync Now</span>
            </div>
            <div class="hamburger-item" data-action="show-debug">
                <span class="hamburger-icon">üêõ</span>
                <span>Show Debug Info</span>
            </div>
            <div class="hamburger-item" data-action="reload">
                <span class="hamburger-icon">üîÑ</span>
                <span>Reload</span>
            </div>
            <div class="hamburger-item" data-action="sign-out">
                <span class="hamburger-icon">üö™</span>
                <span>Sign Out</span>
            </div>
        </div>
    </div>

    <!-- Navigation Tabs -->
    <div class="nav-tabs">
        <button class="nav-tab active" data-action="show-view" data-view="picker">Exercises</button>
        <button class="nav-tab" data-action="show-view" data-view="history">History</button>
    </div>

    <!-- Exercise Picker View -->
    <div id="pickerView" class="view active">
        <div class="search-container">
            <input
                type="text"
                id="searchInput"
                class="search-input"
                placeholder="Search exercises..."
            >
        </div>
        <div id="exerciseList">
            <div class="loading">Loading exercises...</div>
        </div>
    </div>

    <!-- Logger View -->
    <div id="loggerView" class="view">
        <div class="logger-header">
            <div class="logger-exercise-name" id="loggerExerciseName"></div>
            <div class="logger-dosage" id="loggerDosage"></div>
        </div>

        <div class="side-tracking">
            <div class="side-tracking-label" id="sideTrackingLabel">Working right side</div>
            <div class="side-buttons">
                <button class="side-btn" data-action="select-side" data-side="left">üëà Left</button>
                <button class="side-btn active" data-action="select-side" data-side="right">üëâ Right</button>
            </div>
        </div>

        <!-- Counter Mode (for reps) -->
        <div id="counterMode" class="counter-container">
            <div class="counter-label" id="counterLabel">Reps</div>
            <!-- Big tappable circle - tap to increment reps -->
            <div class="counter-display" id="counterDisplay" data-action="counter-tap">0</div>
            <div class="counter-controls">
                <button class="counter-btn counter-btn-minus" data-action="counter-decrease">‚àí Undo</button>
            </div>
        </div>

        <!-- Timer Mode (for hold/duration exercises) -->
        <div id="timerMode" class="timer-container hidden">
            <div class="timer-info" id="timerRepInfo">Rep 1 of 10</div>
            <div class="timer-display" id="timerDisplay">00:00</div>
            <div class="timer-target" id="timerTarget">Target: 10 seconds</div>
            <div class="timer-controls">
                <button class="timer-btn timer-btn-start" data-action="timer-start-pause" id="timerStartBtn">Start</button>
                <button class="timer-btn timer-btn-reset" data-action="timer-reset">Reset</button>
            </div>
        </div>

        <div class="set-info">
            <!-- Non-sided progress -->
            <div id="setsProgressBoth" class="set-info-row">
                <span>Sets:</span>
                <span id="setsProgressBothText">0/0</span>
            </div>
            <!-- Sided progress (hidden for non-sided exercises) -->
            <div id="setsProgressSided" class="hidden">
                <div class="set-info-row">
                    <span>üëà Left:</span>
                    <span id="setsProgressLeft">0/0</span>
                </div>
                <div class="set-info-row">
                    <span>üëâ Right:</span>
                    <span id="setsProgressRight">0/0</span>
                </div>
            </div>
            <!-- Target info -->
            <div class="set-info-row" style="margin-top: 4px; font-size: 0.85rem; color: #888;">
                <span>Target:</span>
                <span id="targetDoseDisplay">--</span>
            </div>
        </div>

        <!-- Control Buttons (always visible) -->
        <div class="control-buttons">
            <button class="control-btn control-btn-secondary" data-action="previous-set">Previous</button>
            <button class="control-btn control-btn-primary" data-action="show-log-set-modal">Log Set</button>
            <button class="control-btn control-btn-success" data-action="show-next-set-modal">Next Set</button>
        </div>

        <button class="finish-session-btn" data-action="finish-session" style="margin-top: 1rem;">Done</button>
        <button class="btn btn-secondary" style="width: 100%; margin-top: 0.5rem;" data-action="back-to-picker">‚Üê Back to Exercises</button>
    </div>

    <!-- History View -->
    <div id="historyView" class="view">
        <div id="historyList">
            <div class="loading">Loading history...</div>
        </div>
    </div>

    <!-- Log Set Modal (for manual entry/review) -->
    <div id="logSetModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Log Set</h2>
                <button class="close-btn" data-action="close-log-set-modal">&times;</button>
            </div>
            <div class="form-group">
                <label id="logSetInputLabel" for="logSetInput">Reps performed</label>
                <input type="number" id="logSetInput" min="0" step="1" class="modal-input">
            </div>
            <!-- Form Parameters (weight, band resistance, etc.) -->
            <div id="formParamsContainer" class="hidden" style="background: rgba(0,122,255,0.05); padding: 12px; border-radius: 8px; margin: 12px 0;">
                <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: #333;">Form Parameters:</div>
                <div id="formParamsFields"></div>
            </div>
            <!-- Side selector for Log Set modal -->
            <div id="logSetSideContainer" class="hidden" style="margin: 12px 0;">
                <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px; text-align: center;">üìç SELECT SIDE FOR THIS SET:</div>
                <div style="display: flex; gap: 12px;">
                    <div class="side-select-btn" data-action="log-set-select-side" data-side="left" style="flex: 1; padding: 12px; border-radius: 8px; border: 2px solid #555; background: #2a2a2a; text-align: center; cursor: pointer;">
                        <div style="font-size: 20px;">üëà</div>
                        <div style="font-weight: 600;">LEFT</div>
                        <div id="logSetLeftProgress" style="font-size: 12px; color: #888;">0/0 sets</div>
                    </div>
                    <div class="side-select-btn" data-action="log-set-select-side" data-side="right" style="flex: 1; padding: 12px; border-radius: 8px; border: 2px solid #007AFF; background: #007AFF; text-align: center; cursor: pointer;">
                        <div style="font-size: 20px;">üëâ</div>
                        <div style="font-weight: 600;">RIGHT</div>
                        <div id="logSetRightProgress" style="font-size: 12px; color: rgba(255,255,255,0.8);">0/0 sets</div>
                    </div>
                </div>
            </div>
            <div class="form-actions">
                <button type="button" class="btn btn-secondary" data-action="close-log-set-modal">Cancel</button>
                <button type="button" class="btn" data-action="save-logged-set">Save Set</button>
            </div>
        </div>
    </div>

    <!-- Next Set Modal (confirmation before logging) -->
    <div id="nextSetModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Next Set</h2>
                <button class="close-btn" data-action="close-next-set-modal">&times;</button>
            </div>
            <div style="margin-bottom: 16px;">
                <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Logging:</div>
                <div id="nextSetSummary" style="font-size: 15px; color: #888;"></div>
            </div>
            <!-- Form parameters display -->
            <div id="nextSetParamsContainer" class="hidden" style="background: rgba(0,122,255,0.05); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px;">Parameters:</div>
                <div id="nextSetParamsFields"></div>
            </div>
            <!-- Side display for sided exercises -->
            <div id="nextSetSideDisplay" class="hidden" style="margin-bottom: 16px; font-size: 14px; color: #888;"></div>
            <div class="form-actions" style="display: flex; gap: 8px;">
                <button type="button" class="btn btn-secondary" style="flex: 1;" data-action="close-next-set-modal">Cancel</button>
                <button type="button" class="btn" style="flex: 1; background: #007AFF;" data-action="edit-next-set">Edit</button>
                <button type="button" class="btn" style="flex: 1; background: #34C759;" data-action="confirm-next-set">Log & Next</button>
            </div>
        </div>
    </div>

    <!-- Session Notes Modal -->
    <div id="notesModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Notes (Optional)</h2>
                <button class="close-btn" data-action="close-notes-modal">&times;</button>
            </div>
            <form id="notesForm">
                <div class="form-group">
                    <textarea id="sessionNotes" placeholder="How did it feel? Any pain? Progress notes..."></textarea>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" data-action="cancel-session">Cancel</button>
                    <button type="submit" class="btn">Save & Finish</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Messages Modal -->
    <div id="messagesModal" class="modal hidden">
        <div class="modal-content" style="max-height: 80vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <h2>Messages</h2>
                <button class="close-btn" data-action="close-messages-modal">&times;</button>
            </div>
            <div id="messagesList" style="flex: 1; overflow-y: auto; padding: 1rem 0; min-height: 200px;">
                <!-- Messages loaded here -->
            </div>
            <div style="border-top: 1px solid #ddd; padding-top: 1rem;">
                <textarea id="newMessageText" placeholder="Write a message to your PT..." style="width: 100%; min-height: 80px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-family: inherit; resize: vertical; margin-bottom: 12px;"></textarea>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" data-action="close-messages-modal">Cancel</button>
                    <button type="button" class="btn" data-action="send-message">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Session Modal -->
    <div id="editSessionModal" class="modal hidden">
        <div class="modal-content" style="max-height: 85vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <h2>Edit Session</h2>
                <button class="close-btn" data-action="close-edit-session-modal">&times;</button>
            </div>
            <div style="flex: 1; overflow-y: auto; padding: 0 0 1rem 0;">
                <!-- Exercise info -->
                <div id="editSessionExerciseInfo" style="background: rgba(0,122,255,0.1); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    <div id="editSessionExerciseName" style="font-weight: 600; font-size: 1.1rem;"></div>
                    <div id="editSessionExerciseType" style="font-size: 0.85rem; color: #888; margin-top: 4px;"></div>
                </div>

                <!-- Date -->
                <div class="form-group" style="margin-bottom: 16px;">
                    <label style="font-weight: 600; display: block; margin-bottom: 6px;">Date & Time</label>
                    <input type="datetime-local" id="editSessionDate" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 1rem;">
                </div>

                <!-- Sets -->
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Sets</div>
                    <div id="editSessionSetsList"></div>
                    <button type="button" class="btn btn-secondary" style="margin-top: 8px; font-size: 0.9rem; padding: 8px 16px;" data-action="add-edit-session-set">+ Add Set</button>
                </div>

                <!-- Notes -->
                <div class="form-group" style="margin-bottom: 16px;">
                    <label style="font-weight: 600; display: block; margin-bottom: 6px;">Notes</label>
                    <textarea id="editSessionNotes" placeholder="Session notes..." style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-family: inherit; resize: vertical;"></textarea>
                </div>

                <!-- Delete Session Button -->
                <button type="button" class="btn" style="width: 100%; background: #dc3545; padding: 14px; font-size: 1rem; margin-top: 8px;" data-action="delete-session">üóëÔ∏è Delete Session</button>
            </div>

            <div style="border-top: 1px solid #ddd; padding-top: 1rem;">
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" data-action="close-edit-session-modal">Cancel</button>
                    <button type="button" class="btn" data-action="save-edit-session">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Visual Feedback -->
    <div id="logFeedback" class="log-feedback">‚úì</div>

    <!-- Toast Container -->
    <div id="toastContainer"></div>

    <!-- Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script>
        // Supabase initialization
        let supabaseClient = null;

        // State
        let currentUser = null;
        let authToken = null;
        let refreshToken = null;
        let therapistId = null; // Patient's assigned therapist for messaging
        let allExercises = [];
        let allHistory = []; // All activity logs for smart dropdowns
        let currentExercise = null;
        let currentSession = null;
        let offlineQueue = [];
        let currentSide = 'right'; // Default side: right
        const CUSTOM_PARAM_VALUE = '__custom__'; // Special value for "Other" option

        async function loadSupabaseConfig() {
            const response = await fetch('/api/env');

            if (!response.ok) {
                throw new Error('Failed to load Supabase configuration.');
            }

            return response.json();
        }

        // Initialize app
        async function init() {
            const { supabaseUrl, supabaseAnonKey } = await loadSupabaseConfig();
            supabaseClient = window.supabase.createClient(supabaseUrl, supabaseAnonKey);

            // Check auth state
            const { data: { session } } = await supabaseClient.auth.getSession();

            if (session) {
                currentUser = session.user;
                authToken = session.access_token;
                refreshToken = session.refresh_token;
                hideAuthModal();
                updateEditorLink();
                await loadData();
                checkForNewMessages();
                // Poll for new messages every 30 seconds
                setInterval(checkForNewMessages, 30000);
            } else {
                showAuthModal();
                updateEditorLink();
            }

            // Auth state listener
            supabaseClient.auth.onAuthStateChange((event, session) => {
                if (event === 'SIGNED_IN') {
                    currentUser = session.user;
                    authToken = session.access_token;
                    refreshToken = session.refresh_token;
                    hideAuthModal();
                    updateEditorLink();
                    loadData();
                    checkForNewMessages();
                } else if (event === 'SIGNED_OUT') {
                    currentUser = null;
                    authToken = null;
                    refreshToken = null;
                    showAuthModal();
                    updateEditorLink();
                }
            });

            // Load offline queue from localStorage
            loadOfflineQueue();
            updateSyncBadge();

            // Bind event handlers
            bindEventHandlers();
            updateEditorLink();
        }

        // Auth functions
        function showAuthModal() {
            document.getElementById('authModal').classList.remove('hidden');
        }

        function hideAuthModal() {
            document.getElementById('authModal').classList.add('hidden');
        }

        async function signIn(email, password) {
            const { data, error } = await supabaseClient.auth.signInWithPassword({
                email,
                password
            });

            if (error) {
                throw error;
            }

            return data;
        }

        function updateEditorLink() {
            const editorLink = document.getElementById('ptEditorLink');
            if (!editorLink) return;

            const params = new URLSearchParams();
            if (authToken && refreshToken) {
                params.set('access_token', authToken);
                params.set('refresh_token', refreshToken);
                try {
                    localStorage.setItem('pt_editor_auth', JSON.stringify({
                        access_token: authToken,
                        refresh_token: refreshToken
                    }));
                } catch (error) {
                    // Ignore storage errors
                }
            } else {
                try {
                    localStorage.removeItem('pt_editor_auth');
                } catch (error) {
                    // Ignore storage errors
                }
            }

            const query = params.toString();
            editorLink.href = query ? `pt_editor.html?${query}` : 'pt_editor.html';
        }

        // Data loading
        async function loadData() {
            try {
                document.getElementById('exerciseList').innerHTML = '<div class="loading">Loading exercises...</div>';

                // Get current user's therapist_id for messaging
                try {
                    const usersResult = await fetchWithAuth('/api/users');
                    const users = usersResult.users || [];
                    const me = users.find(u => u.id === currentUser.id || u.email === currentUser.email);
                    if (me?.therapist_id) {
                        therapistId = me.therapist_id;
                    } else {
                        // Find therapist (any user with therapist role) for messaging
                        const therapist = users.find(u => u.role === 'therapist');
                        if (therapist) {
                            therapistId = therapist.id;
                        }
                    }
                } catch (e) {
                    console.warn('Could not fetch therapist ID:', e);
                }

                // Load patient's assigned programs (exercises with dosages)
                const result = await fetchWithAuth(`/api/programs?patient_id=${currentUser.id}`);
                const programs = result.programs || [];

                // Transform programs into exercise format with dosage data
                allExercises = programs.map(program => {
                    const exercise = program.exercises || {};
                    return {
                        // Exercise library fields
                        id: exercise.id,
                        canonical_name: exercise.canonical_name,
                        description: exercise.description,
                        pt_category: exercise.pt_category,
                        pattern: exercise.pattern,
                        pattern_modifiers: exercise.pattern_modifiers,
                        archived: exercise.archived,

                        // Patient dosage fields from patient_programs
                        current_sets: program.current_sets ?? program.sets,
                        current_reps: program.current_reps ?? program.reps_per_set,
                        seconds_per_rep: program.seconds_per_rep,
                        seconds_per_set: program.seconds_per_set,
                        dosage_type: program.dosage_type,
                        distance_feet: program.distance_feet,
                        side: program.side,

                        // Full nested data for reference
                        equipment: exercise.equipment,
                        primary_muscles: exercise.primary_muscles,
                        secondary_muscles: exercise.secondary_muscles,
                        form_parameters_required: exercise.form_parameters_required,
                        guidance: exercise.guidance,
                        roles: exercise.roles
                    };
                });

                // Backfill missing form parameters from the full exercise library (if needed)
                const missingFormParams = allExercises.filter(ex =>
                    !ex.form_parameters_required || ex.form_parameters_required.length === 0
                );

                if (missingFormParams.length > 0) {
                    try {
                        const exercisesResult = await fetchWithAuth('/api/exercises');
                        const library = exercisesResult.exercises || [];
                        const libraryById = new Map(library.map(ex => [ex.id, ex]));

                        allExercises = allExercises.map(ex => {
                            if (ex.form_parameters_required && ex.form_parameters_required.length > 0) {
                                return ex;
                            }
                            const fallback = libraryById.get(ex.id);
                            if (fallback?.form_parameters_required?.length) {
                                return {
                                    ...ex,
                                    form_parameters_required: fallback.form_parameters_required
                                };
                            }
                            return ex;
                        });
                    } catch (error) {
                        console.warn('Failed to backfill form parameters from exercise library:', error);
                    }
                }

                // Load history FIRST so adherence data is available when rendering
                await loadHistory();
                renderExerciseList(allExercises);

            } catch (error) {
                console.error('Failed to load data:', error);
                document.getElementById('exerciseList').innerHTML =
                    '<div class="empty-state">Failed to load exercises. Using offline mode.</div>';
            }
        }

        async function loadHistory() {
            try {
                const result = await fetchWithAuth(`/api/logs?include_all=true&limit=1000`); // Get more for smart dropdowns
                const logs = result.logs || [];
                allHistory = logs; // Store for form parameter dropdowns
                renderHistory(logs);
            } catch (error) {
                console.error('Failed to load history:', error);
                allHistory = [];
                document.getElementById('historyList').innerHTML =
                    '<div class="empty-state">Failed to load history.</div>';
            }
        }

        async function fetchWithAuth(url, options = {}) {
            const headers = {
                'Content-Type': 'application/json',
                ...options.headers
            };

            if (authToken) {
                headers['Authorization'] = `Bearer ${authToken}`;
            }

            const response = await fetch(url, {
                ...options,
                headers
            });

            if (!response.ok) {
                // Read once to avoid "Body is disturbed or locked" errors.
                const responseText = await response.text();
                let errorDetail = responseText;

                if (responseText) {
                    try {
                        const errorBody = JSON.parse(responseText);
                        errorDetail = errorBody.error || errorBody.message || JSON.stringify(errorBody);
                    } catch (e) {
                        // Keep raw response text for non-JSON errors.
                    }
                }

                throw new Error(`API error ${response.status}: ${errorDetail || response.statusText}`);
            }

            return response.json();
        }

        /**
         * Format dosage display string based on exercise type and pattern modifiers.
         * Examples: "3 √ó 10 reps", "3 √ó 30 sec", "20 feet", "3 √ó 10 sec hold"
         */
        function formatDosage(exercise) {
            const sets = exercise.current_sets || 0;
            const reps = exercise.current_reps || 0;
            const holdSeconds = exercise.seconds_per_rep || 0;
            const durationSeconds = exercise.seconds_per_set || 0;
            const distance = exercise.distance_feet || 0;
            const dosageType = exercise.dosage_type;

            const hasDuration = exercise.pattern_modifiers?.includes('duration_seconds') || dosageType === 'duration';
            const hasHold = exercise.pattern_modifiers?.includes('hold_seconds') || dosageType === 'hold';
            const hasDistance = exercise.pattern_modifiers?.includes('distance_feet') || dosageType === 'distance';

            if (hasDistance && distance > 0) {
                return `${distance} feet`;
            } else if (hasDuration && durationSeconds > 0) {
                return `${sets} √ó ${durationSeconds} sec`;
            } else if (hasHold && holdSeconds > 0 && reps > 0) {
                return `${sets} √ó ${reps} reps (${holdSeconds} sec hold)`;
            } else if (reps > 0) {
                return `${sets} √ó ${reps} reps`;
            } else {
                return exercise.pt_category || '';
            }
        }

        /**
         * Calculate days between two dates (local timezone).
         */
        function getDaysDiff(date1, date2) {
            const d1 = new Date(date1);
            const d2 = new Date(date2);
            d1.setHours(0, 0, 0, 0);
            d2.setHours(0, 0, 0, 0);
            const diffTime = Math.abs(d1 - d2);
            return Math.floor(diffTime / (1000 * 60 * 60 * 24));
        }

        /**
         * Get adherence info for an exercise from history.
         * Returns { daysSince, totalSessions, colorClass, icon }
         */
        function getAdherenceInfo(exerciseId, exerciseName) {
            const logs = allHistory.filter(log =>
                log.exercise_id === exerciseId || log.exercise_name === exerciseName
            );

            const totalSessions = logs.length;

            if (totalSessions === 0) {
                return { daysSince: null, totalSessions: 0, colorClass: 'gray', icon: '‚óã', text: 'Never done' };
            }

            // Find most recent log
            const sortedLogs = logs.sort((a, b) => new Date(b.performed_at) - new Date(a.performed_at));
            const lastLog = sortedLogs[0];
            const daysSince = getDaysDiff(new Date(), new Date(lastLog.performed_at));

            let colorClass, icon, text;
            if (daysSince === 0) {
                colorClass = 'green';
                icon = '‚úì';
                text = 'Done today';
            } else if (daysSince <= 3) {
                colorClass = 'green';
                icon = '';
                text = `${daysSince} day${daysSince > 1 ? 's' : ''} ago`;
            } else if (daysSince <= 7) {
                colorClass = 'orange';
                icon = '‚ö†Ô∏è ';
                text = `${daysSince} days ago`;
            } else {
                colorClass = 'red';
                icon = '‚ùó ';
                text = `${daysSince} days ago`;
            }

            return { daysSince, totalSessions, colorClass, icon, text };
        }

        // Render functions
        function renderExerciseList(exercises) {
            const listEl = document.getElementById('exerciseList');

            if (exercises.length === 0) {
                listEl.innerHTML = '<div class="empty-state">No exercises found.</div>';
                return;
            }

            const html = exercises
                .filter(ex => !ex.archived)
                .map(ex => {
                    const adherence = getAdherenceInfo(ex.id, ex.canonical_name);
                    const adherenceHtml = `<div class="exercise-adherence ${adherence.colorClass}">${adherence.icon}${adherence.text}${adherence.totalSessions > 0 ? ` ¬∑ ${adherence.totalSessions} session${adherence.totalSessions > 1 ? 's' : ''} total` : ''}</div>`;

                    // Category tag
                    const tagHtml = ex.pt_category ? `<div class="exercise-tags"><span class="exercise-tag">${escapeHtml(ex.pt_category)}</span></div>` : '';

                    return `
                        <div class="exercise-card" data-action="select-exercise" data-id="${ex.id}">
                            <div class="exercise-name">${escapeHtml(ex.canonical_name)}</div>
                            <div class="exercise-dosage">${escapeHtml(formatDosage(ex))}</div>
                            ${adherenceHtml}
                            ${tagHtml}
                        </div>
                    `;
                }).join('');

            listEl.innerHTML = html || '<div class="empty-state">No active exercises.</div>';
        }

        function renderHistory(logs) {
            const listEl = document.getElementById('historyList');

            if (logs.length === 0) {
                listEl.innerHTML = '<div class="empty-state">No history yet. Start logging exercises!</div>';
                return;
            }

            const html = logs.map(log => {
                const date = new Date(log.performed_at);
                const dateStr = formatDateTimeWithZone(date, {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit'
                });
                const setsCount = log.sets ? log.sets.length : 0;

                return `
                    <div class="session-card" data-action="edit-session" data-log-id="${log.id}" style="cursor: pointer;">
                        <div class="session-date">${dateStr}</div>
                        <div class="session-exercise">${escapeHtml(log.exercise_name)}</div>
                        <div class="session-sets">${setsCount} sets logged</div>
                    </div>
                `;
            }).join('');

            listEl.innerHTML = html;
        }

        // Exercise selection
        function selectExercise(exerciseId) {
            currentExercise = allExercises.find(ex => ex.id === exerciseId);
            if (!currentExercise) {
                showToast('Exercise not found', 'error');
                return;
            }

            // Determine activity type from pattern modifiers
            let activityType = 'reps'; // default
            if (currentExercise.pattern_modifiers && currentExercise.pattern_modifiers.length > 0) {
                if (currentExercise.pattern_modifiers.includes('distance_feet')) {
                    activityType = 'distance';
                } else if (currentExercise.pattern_modifiers.includes('hold_seconds')) {
                    activityType = 'hold';
                } else if (currentExercise.pattern_modifiers.includes('duration_seconds')) {
                    activityType = 'duration';
                }
            } else if (currentExercise.dosage_type) {
                activityType = currentExercise.dosage_type;
            }

            // Initialize new session
            currentSession = {
                sessionId: generateSessionId(),
                exerciseId: currentExercise.id,
                exerciseName: currentExercise.canonical_name,
                activityType: activityType,
                sets: [],
                date: new Date().toISOString()
            };

            // Setup logger view
            document.getElementById('loggerExerciseName').textContent = currentExercise.canonical_name;
            document.getElementById('loggerDosage').textContent = formatDosage(currentExercise);

            // Handle side tracking visibility - only show for pattern: "side"
            const sideTracking = document.querySelector('.side-tracking');
            const isSidePattern = currentExercise.pattern === 'side';

            if (isSidePattern) {
                // Show side selector and reset to default
                sideTracking.classList.remove('hidden');
                currentSide = 'right';
                selectSide('right');
                // Show sided progress, hide both progress
                document.getElementById('setsProgressBoth').classList.add('hidden');
                document.getElementById('setsProgressSided').classList.remove('hidden');
            } else {
                // Hide side selector for bilateral (both) exercises
                sideTracking.classList.add('hidden');
                currentSide = null; // No side tracking for bilateral
                // Show both progress, hide sided progress
                document.getElementById('setsProgressBoth').classList.remove('hidden');
                document.getElementById('setsProgressSided').classList.add('hidden');
            }

            // Update sets progress display
            updateSetsProgress();

            // Update target display
            updateTargetDisplay();

            // Determine which mode to show: timer mode or counter mode
            const hasTimerModifier = currentExercise.pattern_modifiers?.includes('duration_seconds') ||
                                      currentExercise.pattern_modifiers?.includes('hold_seconds') ||
                                      ['duration', 'hold'].includes(currentExercise.dosage_type);

            const counterMode = document.getElementById('counterMode');
            const timerMode = document.getElementById('timerMode');

            if (hasTimerModifier) {
                // Show timer mode for duration/hold exercises
                counterMode.classList.add('hidden');
                timerMode.classList.remove('hidden');
                initTimerMode();
            } else {
                // Show counter mode for reps exercises
                counterMode.classList.remove('hidden');
                timerMode.classList.add('hidden');
                document.getElementById('counterDisplay').textContent = '0';
            }

            showView('logger');
        }

        /**
         * Update the sets progress display based on current session data.
         */
        function updateSetsProgress() {
            if (!currentExercise || !currentSession) return;

            const isSidePattern = currentExercise.pattern === 'side';
            const targetSets = currentExercise.current_sets || 0;

            if (isSidePattern) {
                // Count sets per side
                const leftSets = currentSession.sets.filter(s => s.side === 'left').length;
                const rightSets = currentSession.sets.filter(s => s.side === 'right').length;
                document.getElementById('setsProgressLeft').textContent = `${leftSets}/${targetSets}`;
                document.getElementById('setsProgressRight').textContent = `${rightSets}/${targetSets}`;
            } else {
                // Count total sets
                const totalSets = currentSession.sets.length;
                document.getElementById('setsProgressBothText').textContent = `${totalSets}/${targetSets}`;
            }
        }

        /**
         * Update the target dose display.
         */
        function updateTargetDisplay() {
            if (!currentExercise) return;

            const reps = currentExercise.current_reps || 0;
            const holdSeconds = currentExercise.seconds_per_rep || 0;
            const durationSeconds = currentExercise.seconds_per_set || 0;
            const distance = currentExercise.distance_feet || 0;

            const hasDuration = currentExercise.pattern_modifiers?.includes('duration_seconds') || currentExercise.dosage_type === 'duration';
            const hasHold = currentExercise.pattern_modifiers?.includes('hold_seconds') || currentExercise.dosage_type === 'hold';
            const hasDistance = currentExercise.pattern_modifiers?.includes('distance_feet') || currentExercise.dosage_type === 'distance';

            let targetText;
            if (hasDistance && distance > 0) {
                targetText = `${distance} feet`;
            } else if (hasDuration && durationSeconds > 0) {
                targetText = `${durationSeconds} seconds`;
            } else if (hasHold && holdSeconds > 0 && reps > 0) {
                targetText = `${reps} reps √ó ${holdSeconds}s hold`;
            } else if (reps > 0) {
                targetText = `${reps} reps`;
            } else {
                targetText = '--';
            }

            document.getElementById('targetDoseDisplay').textContent = targetText;
        }

        /**
         * Get the last used form parameters for this exercise from history.
         */
        function getLastFormParams(exerciseId) {
            const logs = allHistory.filter(log => log.exercise_id === exerciseId);
            if (logs.length === 0) return null;

            // Sort by date descending to get most recent
            const sortedLogs = logs.sort((a, b) => new Date(b.performed_at) - new Date(a.performed_at));
            const lastLog = sortedLogs[0];

            // Get form_data from the most recent set
            if (lastLog.sets && lastLog.sets.length > 0) {
                const lastSet = lastLog.sets[lastLog.sets.length - 1];
                return lastSet.form_data || null;
            }
            return null;
        }

        // Counter functions
        function increaseCounter() {
            const display = document.getElementById('counterDisplay');
            const current = parseInt(display.textContent);
            const newValue = current + 1;
            display.textContent = newValue;

            // Voice announcements at milestones (matching old app)
            if (currentExercise && currentExercise.current_reps) {
                const repsLeft = currentExercise.current_reps - newValue;

                if (repsLeft === 5) {
                    speakText('5 reps left');
                } else if (repsLeft === 3) {
                    speakText('3 reps left');
                } else if (repsLeft === 1) {
                    speakText('Last rep');
                } else if (repsLeft === 0) {
                    playCompletionSound();
                    speakText('Set complete');
                }
            }
        }

        function decreaseCounter() {
            const display = document.getElementById('counterDisplay');
            const current = parseInt(display.textContent);
            if (current > 0) {
                display.textContent = current - 1;
            }
        }

        /**
         * Timer state for hold/duration exercises.
         * iOS Safari requires user interaction to enable audio, so beeps and voice are initialized on first start.
         */
        let timerState = {
            intervalId: null,
            startTime: null,
            elapsedMs: 0,
            isRunning: false,
            currentRep: 1,
            targetSeconds: 10,
            totalReps: 1,
            lastAnnouncedSecond: null
        };

        /**
         * Initialize timer mode for hold or duration exercises.
         * Called when selecting an exercise with duration_seconds or hold_seconds pattern modifier.
         */
        function initTimerMode() {
            // Determine if this is hold (per-rep timer) or duration (single long timer)
            const hasHold = currentExercise.pattern_modifiers?.includes('hold_seconds')
                || currentExercise.dosage_type === 'hold';
            const hasDuration = currentExercise.pattern_modifiers?.includes('duration_seconds')
                || currentExercise.dosage_type === 'duration';

            if (hasHold) {
                // Hold = timer per rep (e.g., 10 reps √ó 10 seconds each)
                timerState.targetSeconds = currentExercise.seconds_per_rep || 10;
                timerState.totalReps = currentExercise.current_reps || 1;
                timerState.currentRep = 1;
                document.getElementById('timerRepInfo').textContent = `Rep ${timerState.currentRep} of ${timerState.totalReps}`;
            } else if (hasDuration) {
                // Duration = single long timer (e.g., 60 seconds plank)
                timerState.targetSeconds = currentExercise.seconds_per_set || currentExercise.seconds_per_rep || 60;
                timerState.totalReps = 1;
                timerState.currentRep = 1;
                document.getElementById('timerRepInfo').textContent = `Duration Exercise`;
            }

            document.getElementById('timerTarget').textContent = `Target: ${timerState.targetSeconds} seconds`;
            // Initialize display to show target time (countdown starts from target)
            document.getElementById('timerDisplay').textContent = formatTime(timerState.targetSeconds * 1000);
            timerState.elapsedMs = 0;
            timerState.isRunning = false;
            timerState.lastAnnouncedSecond = null;
            updateTimerButton();
        }

        /**
         * Format milliseconds as MM:SS display.
         */
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        /**
         * Start or pause the timer countdown.
         * Timer counts DOWN from target to 0, with beeps/voice warnings.
         */
        function toggleTimer() {
            if (timerState.isRunning) {
                pauseTimer();
            } else {
                startTimer();
            }
        }

        function startTimer() {
            if (timerState.intervalId) {
                return;
            }
            timerState.isRunning = true;
            timerState.startTime = Date.now() - timerState.elapsedMs;

            timerState.intervalId = setInterval(() => {
                timerState.elapsedMs = Date.now() - timerState.startTime;
                const elapsedSeconds = Math.floor(timerState.elapsedMs / 1000);
                const remaining = timerState.targetSeconds - elapsedSeconds;
                const clampedRemaining = Math.max(0, remaining);

                // Display countdown (remaining time)
                const displayMs = clampedRemaining * 1000;
                document.getElementById('timerDisplay').textContent = formatTime(displayMs);

                // Beep and voice warnings when approaching zero
                // Countdown beeps at 3, 2, 1 (matching old app)
                if (clampedRemaining !== timerState.lastAnnouncedSecond) {
                    if (clampedRemaining <= 3 && clampedRemaining > 0) {
                        playBeep(600, 100);
                    }

                    if (clampedRemaining === 0) {
                        playCompletionSound();
                        pauseTimer(); // Auto-pause at target, but allow user to continue

                        // Announce reps remaining for hold exercises
                        const hasHold = currentExercise.pattern_modifiers?.includes('hold_seconds');
                        if (hasHold) {
                            const repsLeft = timerState.totalReps - timerState.currentRep;
                            if (repsLeft <= 0) {
                                speakText('Set complete');
                            } else if (repsLeft === 1) {
                                speakText('Last rep');
                            } else {
                                speakText(`${repsLeft} reps left`);
                            }

                            timerState.currentRep = Math.min(timerState.currentRep + 1, timerState.totalReps);
                            timerState.elapsedMs = 0;
                            timerState.lastAnnouncedSecond = null;
                            if (repsLeft > 0) {
                                document.getElementById('timerRepInfo').textContent = `Rep ${timerState.currentRep} of ${timerState.totalReps}`;
                            }
                            document.getElementById('timerDisplay').textContent = formatTime(timerState.targetSeconds * 1000);
                        } else {
                            speakText('Time');
                            timerState.elapsedMs = 0;
                            timerState.lastAnnouncedSecond = null;
                            document.getElementById('timerDisplay').textContent = formatTime(timerState.targetSeconds * 1000);
                        }
                    }

                    timerState.lastAnnouncedSecond = clampedRemaining;
                }
            }, 100); // Update every 100ms for smooth display

            updateTimerButton();
        }

        function pauseTimer() {
            timerState.isRunning = false;
            if (timerState.intervalId) {
                clearInterval(timerState.intervalId);
                timerState.intervalId = null;
            }
            updateTimerButton();
        }

        function resetTimer() {
            pauseTimer();
            timerState.elapsedMs = 0;
            timerState.lastAnnouncedSecond = null;
            // Reset to target time (countdown starts from target)
            document.getElementById('timerDisplay').textContent = formatTime(timerState.targetSeconds * 1000);
        }

        function updateTimerButton() {
            const btn = document.getElementById('timerStartBtn');
            btn.textContent = timerState.isRunning ? 'Pause' : 'Start';
        }

        let audioContext = null;

        function ensureAudioReady() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            } catch (error) {
                console.warn('Audio not available:', error);
                audioContext = null;
            }
        }

        /**
         * Play a simple beep sound using Web Audio API.
         * iOS Safari requires user interaction before playing audio.
         */
        function playBeep(frequency = 800, duration = 200) {
            try {
                ensureAudioReady();
                if (!audioContext) {
                    return;
                }
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = frequency;
                oscillator.type = 'square'; // More noticeable than sine

                const durationInSeconds = duration / 1000;
                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime); // Louder
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + durationInSeconds);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + durationInSeconds);
            } catch (error) {
                console.warn('Audio not available:', error);
            }
        }

        /**
         * Play triple beep completion sound.
         * Three ascending beeps to indicate successful completion.
         */
        function playCompletionSound() {
            try {
                playBeep(1000, 150);  // First beep: 1000 Hz, 150ms
                setTimeout(() => playBeep(1200, 150), 200);  // Second beep: 1200 Hz after 200ms
                setTimeout(() => playBeep(1400, 200), 400);  // Third beep: 1400 Hz after 400ms
            } catch (error) {
                console.warn('Audio not available:', error);
            }
        }

        /**
         * Speak text using Web Speech API.
         * iOS Safari supports speechSynthesis but may require user interaction to initialize.
         */
        function speakText(text) {
            try {
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 1.0;
                    utterance.pitch = 1.0;
                    utterance.volume = 1.0;
                    window.speechSynthesis.speak(utterance);
                }
            } catch (error) {
                console.warn('Speech not available:', error);
            }
        }

        /**
         * Toggle hamburger menu visibility
         * iOS-safe: Uses class-based visibility instead of display manipulation
         */
        function toggleHamburger() {
            const overlay = document.getElementById('hamburgerOverlay');
            const menu = document.getElementById('hamburgerMenu');
            overlay.classList.toggle('active');
            menu.classList.toggle('active');
        }

        /**
         * Select side for tracking (left, right, both)
         * Updates UI and stores current selection for logging
         */
        /**
         * Select which side is being worked (for pattern: "side" exercises).
         * Updates UI and stores current selection for logging.
         */
        function selectSide(side) {
            currentSide = side;

            // Update button states
            document.querySelectorAll('.side-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.side === side) {
                    btn.classList.add('active');
                }
            });

            // Update "Working [side] side" feedback label
            const label = document.getElementById('sideTrackingLabel');
            if (label) {
                label.textContent = `Working ${side} side`;
            }
        }

        /**
         * Show visual feedback when a set is logged
         * iOS-safe: Uses CSS transitions for smooth animation
         */
        function showLogFeedback() {
            const feedback = document.getElementById('logFeedback');
            feedback.classList.add('show');

            setTimeout(() => {
                feedback.classList.remove('show');
            }, 800);
        }

        /**
         * Sign out the current user
         */
        async function signOut() {
            try {
                await supabaseClient.auth.signOut();
                // Auth state listener will handle UI updates
            } catch (error) {
                console.error('Sign out error:', error);
                showToast('Failed to sign out: ' + error.message, 'error');
            }
        }

        /**
         * Reload the page
         */
        function reloadPage() {
            window.location.reload();
        }

        /**
         * Show debug information about offline queue
         */
        function showDebugInfo() {
            const queueData = JSON.stringify(offlineQueue, null, 2);
            const currentExerciseSummary = currentExercise
                ? JSON.stringify({
                    id: currentExercise.id,
                    name: currentExercise.canonical_name,
                    pattern: currentExercise.pattern,
                    pattern_modifiers: currentExercise.pattern_modifiers,
                    form_parameters_required: currentExercise.form_parameters_required,
                    dosage_type: currentExercise.dosage_type,
                    current_sets: currentExercise.current_sets,
                    current_reps: currentExercise.current_reps
                }, null, 2)
                : 'None selected';
            console.log('Offline Queue:', offlineQueue);
            console.log('Current Exercise Summary:', currentExerciseSummary);

            // Create a modal-like debug display
            const debugInfo = `
Queue Length: ${offlineQueue.length}
Auth Token: ${authToken ? 'Present' : 'Missing'}
Current User: ${currentUser?.email || 'None'}
Exercises Loaded: ${allExercises.length}
Current Exercise:
${currentExerciseSummary}

Queued Sessions:
${queueData}
            `.trim();

            // Show in alert for now (can be improved with a modal)
            alert(debugInfo);

            // Also copy first session to clipboard if available
            if (offlineQueue.length > 0) {
                const firstSession = JSON.stringify(offlineQueue[0], null, 2);
                console.log('First queued session:', firstSession);
                showToast('Debug info logged to console', '', 3000);
            }
        }

        // Track the side selected in Log Set modal
        let logSetSelectedSide = null;

        /**
         * Open "Log Set" modal for manual entry.
         * Pre-fills with TARGET dose (not counter value) for manual logging.
         * Shows form parameters prefilled with last used values.
         */
        function showLogSetModal() {
            if (!currentExercise) return;

            const modal = document.getElementById('logSetModal');
            const input = document.getElementById('logSetInput');
            const label = document.getElementById('logSetInputLabel');

            const hasDuration = currentExercise.pattern_modifiers?.includes('duration_seconds') || currentExercise.dosage_type === 'duration';
            const hasHold = currentExercise.pattern_modifiers?.includes('hold_seconds') || currentExercise.dosage_type === 'hold';

            if (hasDuration) {
                // Duration: prefill with target seconds
                input.value = currentExercise.seconds_per_set || currentExercise.seconds_per_rep || 0;
                label.textContent = 'Seconds performed';
            } else if (hasHold) {
                // Hold: prefill with target reps (timer handles the hold time)
                input.value = currentExercise.current_reps || 0;
                label.textContent = 'Reps performed';
            } else {
                // Reps: prefill with target reps
                input.value = currentExercise.current_reps || 0;
                label.textContent = 'Reps performed';
            }

            // Show/hide side selector
            const isSidePattern = currentExercise.pattern === 'side';
            const sideContainer = document.getElementById('logSetSideContainer');
            if (isSidePattern) {
                sideContainer.classList.remove('hidden');
                logSetSelectedSide = currentSide || 'right';
                updateLogSetSideDisplay();
            } else {
                sideContainer.classList.add('hidden');
                logSetSelectedSide = null;
            }

            // Populate form parameters with last used values
            renderFormParameterFields({
                containerId: 'formParamsContainer',
                fieldsId: 'formParamsFields',
                prefix: 'log',
                side: logSetSelectedSide
            });

            modal.classList.remove('hidden');
            input.focus();
        }

        /**
         * Select side in Log Set modal.
         */
        function selectLogSetSide(side) {
            logSetSelectedSide = side;
            updateLogSetSideDisplay();
            renderFormParameterFields({
                containerId: 'formParamsContainer',
                fieldsId: 'formParamsFields',
                prefix: 'log',
                side: logSetSelectedSide
            });
        }

        /**
         * Update Log Set modal side button display.
         */
        function updateLogSetSideDisplay() {
            const leftBtn = document.querySelector('[data-action="log-set-select-side"][data-side="left"]');
            const rightBtn = document.querySelector('[data-action="log-set-select-side"][data-side="right"]');

            if (!leftBtn || !rightBtn) return;

            const targetSets = currentExercise?.current_sets || 0;
            const leftSets = currentSession?.sets.filter(s => s.side === 'left').length || 0;
            const rightSets = currentSession?.sets.filter(s => s.side === 'right').length || 0;

            // Update progress text
            document.getElementById('logSetLeftProgress').textContent = `${leftSets}/${targetSets} sets`;
            document.getElementById('logSetRightProgress').textContent = `${rightSets}/${targetSets} sets`;

            // Update button styles
            if (logSetSelectedSide === 'left') {
                leftBtn.style.border = '2px solid #007AFF';
                leftBtn.style.background = '#007AFF';
                rightBtn.style.border = '2px solid #555';
                rightBtn.style.background = '#2a2a2a';
            } else {
                rightBtn.style.border = '2px solid #007AFF';
                rightBtn.style.background = '#007AFF';
                leftBtn.style.border = '2px solid #555';
                leftBtn.style.background = '#2a2a2a';
            }
        }

        /**
         * Show "Next Set" modal to confirm logging counter/timer value.
         * Shows what will be logged with Cancel/Edit/Log & Next buttons.
         */
        function showNextSetModal() {
            if (!currentExercise || !currentSession) return;

            const counterMode = document.getElementById('counterMode');
            const isTimerMode = counterMode.classList.contains('hidden');

            let logValue, targetValue, unit;
            const hasDuration = currentExercise.pattern_modifiers?.includes('duration_seconds') || currentExercise.dosage_type === 'duration';
            const hasHold = currentExercise.pattern_modifiers?.includes('hold_seconds') || currentExercise.dosage_type === 'hold';

            if (isTimerMode) {
                if (hasDuration) {
                    logValue = Math.floor(timerState.elapsedMs / 1000);
                    targetValue = currentExercise.seconds_per_set || currentExercise.seconds_per_rep || 0;
                    unit = 's';
                } else if (hasHold) {
                    logValue = timerState.currentRep;
                    targetValue = timerState.totalReps;
                    unit = ' reps';
                } else {
                    logValue = Math.floor(timerState.elapsedMs / 1000);
                    targetValue = currentExercise.seconds_per_rep || 0;
                    unit = 's';
                }
            } else {
                logValue = parseInt(document.getElementById('counterDisplay').textContent) || 0;
                targetValue = currentExercise.current_reps || 0;
                unit = ' reps';
            }

            // Build summary
            document.getElementById('nextSetSummary').textContent = `${logValue}${unit} (target ${targetValue}${unit})`;

            // Show form parameters that will be logged
            renderFormParameterFields({
                containerId: 'nextSetParamsContainer',
                fieldsId: 'nextSetParamsFields',
                prefix: 'next',
                side: currentSide
            });

            // Show side info for sided exercises
            const sideDisplay = document.getElementById('nextSetSideDisplay');
            const isSidePattern = currentExercise.pattern === 'side';
            if (isSidePattern && currentSide) {
                sideDisplay.textContent = `Side: ${currentSide.charAt(0).toUpperCase() + currentSide.slice(1)}`;
                sideDisplay.classList.remove('hidden');
            } else {
                sideDisplay.classList.add('hidden');
            }

            document.getElementById('nextSetModal').classList.remove('hidden');
        }

        function closeNextSetModal() {
            document.getElementById('nextSetModal').classList.add('hidden');
        }

        /**
         * Edit button in Next Set modal - opens Log Set modal for editing.
         */
        function editNextSet() {
            closeNextSetModal();
            showLogSetModal();
        }

        /**
         * Confirm and log the set from Next Set modal.
         */
        function confirmNextSet() {
            const counterMode = document.getElementById('counterMode');
            const isTimerMode = counterMode.classList.contains('hidden');

            let reps = null;
            let seconds = null;

            const hasDuration = currentExercise.pattern_modifiers?.includes('duration_seconds') || currentExercise.dosage_type === 'duration';
            const hasHold = currentExercise.pattern_modifiers?.includes('hold_seconds') || currentExercise.dosage_type === 'hold';

            if (isTimerMode) {
                if (hasDuration) {
                    reps = 1;
                    seconds = Math.floor(timerState.elapsedMs / 1000);
                } else if (hasHold) {
                    reps = timerState.currentRep;
                    seconds = timerState.targetSeconds;
                }
                resetTimer();
            } else {
                reps = parseInt(document.getElementById('counterDisplay').textContent) || 0;
            }

            if (reps === 0 && !seconds) {
                showToast('Please perform at least one rep', 'error');
                closeNextSetModal();
                return;
            }

            const formData = collectFormParameters('nextSetParamsContainer');

            const set = {
                set_number: currentSession.sets.length + 1,
                reps: reps,
                seconds: seconds,
                distance_feet: null,
                side: currentSide,
                form_data: formData.length > 0 ? formData : null,
                manual_log: false,
                partial_rep: false,
                performed_at: new Date().toISOString()
            };

            currentSession.sets.push(set);

            // Reset timer rep counter for next set (hold exercises)
            if (isTimerMode && hasHold) {
                timerState.currentRep = 1;
                document.getElementById('timerRepInfo').textContent = `Rep ${timerState.currentRep} of ${timerState.totalReps}`;
            }

            // Update sets progress display
            updateSetsProgress();

            // Reset counter for next set
            document.getElementById('counterDisplay').textContent = '0';

            // Voice comparison to last time
            announceProgressComparison(set);

            closeNextSetModal();
            showLogFeedback();
        }

        /**
         * Go back to previous set (undo last logged set).
         */
        function previousSet() {
            if (!currentSession || currentSession.sets.length === 0) {
                showToast('No sets to undo', 'error');
                return;
            }

            const removedSet = currentSession.sets.pop();
            updateSetsProgress();
            showToast(`Set ${removedSet.set_number} removed`, 'success');
        }

        /**
         * Announce progress comparison to last session.
         * "X more/less reps than last time"
         */
        function announceProgressComparison(currentSet) {
            if (!currentExercise) return;

            // Find previous session for this exercise
            const prevLogs = allHistory.filter(log =>
                log.exercise_id === currentExercise.id || log.exercise_name === currentExercise.canonical_name
            ).sort((a, b) => new Date(b.performed_at) - new Date(a.performed_at));

            if (prevLogs.length === 0) return;

            const prevLog = prevLogs[0];
            if (!prevLog.sets || prevLog.sets.length === 0) return;

            // Find matching set (same set number and side if applicable)
            const matchingSet = prevLog.sets.find(s => {
                if (currentExercise.pattern === 'side') {
                    return s.set_number === currentSet.set_number && s.side === currentSet.side;
                }
                return s.set_number === currentSet.set_number;
            });

            if (!matchingSet) return;

            const prevReps = matchingSet.reps || 0;
            const currReps = currentSet.reps || 0;
            const diff = currReps - prevReps;

            if (diff > 0) {
                setTimeout(() => speakText(`${diff} more rep${diff > 1 ? 's' : ''} than last time`), 1500);
            } else if (diff < 0 && Math.abs(diff) > 2) {
                setTimeout(() => speakText(`${Math.abs(diff)} fewer reps than last time`), 1500);
            }
        }

        /**
         * Get historical values for a parameter from this exercise.
         */
        function getHistoricalParamValues(exerciseId, paramName, side = null) {
            const values = new Set();

            const exerciseLogs = allHistory.filter(log => log.exercise_id === exerciseId);
            exerciseLogs.forEach(log => {
                (log.sets || []).forEach(set => {
                    if (side && set.side !== side) return;

                    if (set.form_data && Array.isArray(set.form_data)) {
                        const param = set.form_data.find(p => p.parameter_name === paramName);
                        if (param && param.parameter_value !== undefined && param.parameter_value !== null) {
                            const fullValue = param.parameter_unit
                                ? `${param.parameter_value} ${param.parameter_unit}`
                                : param.parameter_value;
                            values.add(fullValue);
                        }
                    }
                });
            });

            return Array.from(values).sort();
        }

        /**
         * Get ALL historical values for a parameter across ALL exercises (global).
         * Used to populate smart dropdowns with all previously logged values.
         *
         * Parameters are MUTABLE - dropdown shows ALL values ever logged for that parameter
         * across all exercises, not just the current exercise. This allows parameter values
         * to evolve over time (e.g., new band colors, new surface types).
         *
         * form_data is normalized: [{parameter_name, parameter_value, parameter_unit}, ...]
         */
        function getGlobalHistoricalParamValues(paramName) {
            const values = new Set();

            allHistory.forEach(log => {
                (log.sets || []).forEach(set => {
                    // form_data is an array of {parameter_name, parameter_value, parameter_unit}
                    if (set.form_data && Array.isArray(set.form_data)) {
                        const param = set.form_data.find(p => p.parameter_name === paramName);
                        if (param) {
                            // Combine value + unit if unit exists (e.g., "15 lb")
                            const fullValue = param.parameter_unit
                                ? `${param.parameter_value} ${param.parameter_unit}`
                                : param.parameter_value;
                            values.add(fullValue);
                        }
                    }
                });
            });

            return Array.from(values).sort();
        }

        /**
         * Get the last used value for a parameter (most recent).
         * Returns combined "value unit" string (e.g., "15 lb") or just value.
         */
        function getLastUsedParamValue(exerciseId, paramName, side = null) {
            if (currentSession && currentSession.exerciseId === exerciseId) {
                const sessionSets = [...(currentSession.sets || [])].reverse();
                for (const set of sessionSets) {
                    if (side && set.side !== side) continue;

                    if (set.form_data && Array.isArray(set.form_data)) {
                        const param = set.form_data.find(p => p.parameter_name === paramName);
                        if (param) {
                            return param.parameter_unit
                                ? `${param.parameter_value} ${param.parameter_unit}`
                                : param.parameter_value;
                        }
                    }
                }
            }

            const exerciseLogs = allHistory.filter(log => log.exercise_id === exerciseId);

            // Sort by date descending (most recent first)
            exerciseLogs.sort((a, b) => new Date(b.performed_at) - new Date(a.performed_at));

            for (const log of exerciseLogs) {
                for (const set of (log.sets || [])) {
                    if (side && set.side !== side) continue;

                    // form_data is an array of {parameter_name, parameter_value, parameter_unit}
                    if (set.form_data && Array.isArray(set.form_data)) {
                        const param = set.form_data.find(p => p.parameter_name === paramName);
                        if (param) {
                            // Combine value + unit if unit exists
                            return param.parameter_unit
                                ? `${param.parameter_value} ${param.parameter_unit}`
                                : param.parameter_value;
                        }
                    }
                }
            }

            return null;
        }

        /**
         * Render form parameter fields based on exercise requirements.
         * Weight and distance are special (int + unit), others are smart dropdowns.
         */
        function renderFormParameterFields({ containerId, fieldsId, prefix, side = null }) {
            const formParams = currentExercise?.form_parameters_required || [];
            const container = document.getElementById(containerId);
            const fieldsDiv = document.getElementById(fieldsId);

            if (!container || !fieldsDiv) return;

            if (formParams.length === 0) {
                fieldsDiv.innerHTML = '';
                container.classList.add('hidden');
                return;
            }

            const html = formParams.map(param => {
                if (param === 'weight') {
                    const lastValue = getLastUsedParamValue(currentExercise.id, param, side);
                    const [weightNum, weightUnit] = lastValue ? lastValue.split(' ') : ['', 'lb'];

                    return `
                        <div style="margin-bottom: 12px;">
                            <label style="font-size: 13px; margin-bottom: 4px; display: block;">Weight</label>
                            <div style="display: flex; gap: 8px;">
                                <input type="number" class="modal-input" id="${prefix}-weight" placeholder="Weight" min="0" step="1" value="${weightNum || ''}" style="flex: 1; margin: 0;" data-param="weight">
                                <select class="modal-select" id="${prefix}-weight-unit" style="width: 80px; margin: 0;" data-param-unit="weight">
                                    <option value="lb" ${weightUnit === 'lb' ? 'selected' : ''}>lb</option>
                                    <option value="kg" ${weightUnit === 'kg' ? 'selected' : ''}>kg</option>
                                </select>
                            </div>
                        </div>
                    `;
                }

                if (param === 'distance') {
                    const lastValue = getLastUsedParamValue(currentExercise.id, param, side);
                    const [distNum, distUnit] = lastValue ? lastValue.split(' ') : ['', 'ft'];

                    return `
                        <div style="margin-bottom: 12px;">
                            <label style="font-size: 13px; margin-bottom: 4px; display: block;">Distance</label>
                            <div style="display: flex; gap: 8px;">
                                <input type="number" class="modal-input" id="${prefix}-distance" placeholder="Distance" min="0" step="1" value="${distNum || ''}" style="flex: 1; margin: 0;" data-param="distance">
                                <select class="modal-select" id="${prefix}-distance-unit" style="width: 80px; margin: 0;" data-param-unit="distance">
                                    <option value="ft" ${distUnit === 'ft' ? 'selected' : ''}>ft</option>
                                    <option value="in" ${distUnit === 'in' ? 'selected' : ''}>in</option>
                                    <option value="cm" ${distUnit === 'cm' ? 'selected' : ''}>cm</option>
                                    <option value="deg" ${distUnit === 'deg' ? 'selected' : ''}>deg</option>
                                </select>
                            </div>
                        </div>
                    `;
                }

                const historicalValues = getHistoricalParamValues(currentExercise.id, param, side);
                const globalValues = getGlobalHistoricalParamValues(param);
                const lastUsed = getLastUsedParamValue(currentExercise.id, param, side);
                const label = param.replace(/_/g, ' ');
                const mergedValues = new Set([...historicalValues, ...globalValues]);
                if (lastUsed) mergedValues.add(lastUsed);

                const options = Array.from(mergedValues).sort().map(value => {
                    const selected = value === lastUsed ? 'selected' : '';
                    return `<option value="${escapeHtml(value)}" ${selected}>${escapeHtml(value)}</option>`;
                }).join('');

                return `
                    <div style="margin-bottom: 12px;">
                        <label style="font-size: 13px; margin-bottom: 4px; display: block;">${label}</label>
                        <select class="modal-select param-select" id="${prefix}-param-${param}" data-param="${param}">
                            ${!lastUsed ? `<option value="">Select ${label}...</option>` : ''}
                            ${options}
                            <option value="${CUSTOM_PARAM_VALUE}">Other...</option>
                        </select>
                        <input type="text" class="modal-input" id="${prefix}-param-${param}-custom" placeholder="Enter ${label}" style="display: none; margin-top: 8px;" data-param="${param}">
                    </div>
                `;
            }).join('');

            fieldsDiv.innerHTML = html;
            container.classList.remove('hidden');
        }

        /**
         * Collect form parameters from a container.
         */
        function collectFormParameters(containerId) {
            const container = document.getElementById(containerId);
            if (!container || container.classList.contains('hidden')) {
                return [];
            }

            const formData = [];

            const weightInput = container.querySelector('input[data-param="weight"]');
            if (weightInput && weightInput.value) {
                const unit = container.querySelector('select[data-param-unit="weight"]')?.value || 'lb';
                formData.push({
                    parameter_name: 'weight',
                    parameter_value: weightInput.value,
                    parameter_unit: unit
                });
            }

            const distanceInput = container.querySelector('input[data-param="distance"]');
            if (distanceInput && distanceInput.value) {
                const unit = container.querySelector('select[data-param-unit="distance"]')?.value || 'ft';
                formData.push({
                    parameter_name: 'distance',
                    parameter_value: distanceInput.value,
                    parameter_unit: unit
                });
            }

            container.querySelectorAll('.param-select').forEach(select => {
                const paramName = select.dataset.param;
                if (!paramName) return;

                let paramValue = null;

                if (select.value === CUSTOM_PARAM_VALUE) {
                    const customInput = document.getElementById(`${select.id}-custom`);
                    if (customInput && customInput.value.trim()) {
                        paramValue = customInput.value.trim();
                    }
                } else if (select.value && select.value.trim() !== '') {
                    paramValue = select.value;
                }

                if (paramValue) {
                    formData.push({
                        parameter_name: paramName,
                        parameter_value: paramValue,
                        parameter_unit: null
                    });
                }
            });

            return formData;
        }

        /**
         * iOS-safe event delegation for param select "Other" option.
         */
        document.addEventListener('change', (event) => {
            if (!event.target.classList.contains('param-select')) return;

            const customInput = document.getElementById(`${event.target.id}-custom`);
            if (!customInput) return;

            if (event.target.value === CUSTOM_PARAM_VALUE) {
                customInput.style.display = 'block';
                customInput.focus();
            } else {
                customInput.style.display = 'none';
                customInput.value = '';
            }
        });

        function closeLogSetModal() {
            document.getElementById('logSetModal').classList.add('hidden');
        }

        /**
         * Save the set from the modal (user reviewed/edited the value).
         * Collects form parameters (weight, band resistance, etc.) if present.
         */
        function saveLoggedSet() {
            const counterMode = document.getElementById('counterMode');
            const isTimerMode = counterMode.classList.contains('hidden');
            const input = document.getElementById('logSetInput');
            const value = parseInt(input.value) || 0;

            if (value === 0) {
                showToast('Please enter a value greater than 0', 'error');
                return;
            }

            let reps = null;
            let seconds = null;

            if (isTimerMode) {
                // Timer mode: check if this is hold (per-rep) or duration (single timer)
                const hasHold = currentExercise.pattern_modifiers?.includes('hold_seconds');

                if (hasHold) {
                    // Hold exercise: track reps, create set only when all reps complete
                    timerState.currentRep++;  // Increment rep count

                    if (timerState.currentRep > timerState.totalReps) {
                        // All reps complete - create the set
                        reps = timerState.totalReps;  // Total reps performed
                        seconds = timerState.targetSeconds;  // Seconds per rep
                        // Don't add to currentSession.sets here - will be done below
                    } else {
                        // More reps to go - reset timer for next rep
                        resetTimer();
                        document.getElementById('timerRepInfo').textContent = `Rep ${timerState.currentRep} of ${timerState.totalReps}`;
                        closeLogSetModal();
                        showToast(`Rep ${timerState.currentRep - 1} complete`, 'success', 2000);
                        return;  // Don't create set yet
                    }
                } else {
                    // Duration exercise: single set with just time
                    reps = 1;  // Always 1 rep for duration
                    seconds = value;
                }

                // Reset timer for next set
                resetTimer();
            } else {
                reps = value;
                // Reset counter for next set
                document.getElementById('counterDisplay').textContent = '0';
            }

            const formData = collectFormParameters('formParamsContainer');

            const set = {
                set_number: currentSession.sets.length + 1,
                reps: reps,  // Always populated (never null)
                seconds: seconds,
                distance_feet: null, // TODO: Add distance mode
                side: logSetSelectedSide || currentSide,
                form_data: formData.length > 0 ? formData : null, // Normalized array
                manual_log: false,
                partial_rep: false,
                performed_at: new Date().toISOString()
            };

            currentSession.sets.push(set);

            // Reset timer rep counter for next set (hold exercises)
            if (isTimerMode && currentExercise.pattern_modifiers?.includes('hold_seconds')) {
                timerState.currentRep = 1;
                document.getElementById('timerRepInfo').textContent = `Rep ${timerState.currentRep} of ${timerState.totalReps}`;
            }

            // Update sets progress display
            updateSetsProgress();

            // Reset counter for next set
            document.getElementById('counterDisplay').textContent = '0';

            // Voice comparison to last time
            announceProgressComparison(set);

            // Close modal and show feedback
            closeLogSetModal();
            showLogFeedback();
        }

        // Finish session
        function finishSession() {
            if (currentSession.sets.length === 0) {
                showToast('Please log at least one set before finishing', 'error');
                return;
            }

            // Show notes modal
            document.getElementById('notesModal').classList.remove('hidden');
        }

        function closeNotesModal() {
            document.getElementById('notesModal').classList.add('hidden');
        }

        // ============================================================================
        // MESSAGES FUNCTIONALITY
        // ============================================================================

        let lastReadMessageTime = localStorage.getItem('lastReadMessageTime') || new Date(0).toISOString();

        async function showMessagesModal() {
            if (!currentUser) {
                showToast('Please sign in to view messages', 'error');
                return;
            }

            toggleHamburger(); // Close menu
            document.getElementById('messagesModal').classList.remove('hidden');
            await loadMessages();

            // Mark messages as read
            lastReadMessageTime = new Date().toISOString();
            localStorage.setItem('lastReadMessageTime', lastReadMessageTime);

            // Hide badge
            const badge = document.getElementById('messagesBadge');
            if (badge) badge.classList.add('hidden');
        }

        function closeMessagesModal() {
            document.getElementById('messagesModal').classList.add('hidden');
        }

        async function loadMessages() {
            if (!currentUser || !authToken) {
                console.log('[Messages] No current user, cannot load messages');
                return;
            }

            const messagesList = document.getElementById('messagesList');
            messagesList.innerHTML = '<div style="text-align: center; color: #666; padding: 2rem;">Loading messages...</div>';

            try {
                const response = await fetch('/api/logs?type=messages', {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch messages');
                }

                const { messages } = await response.json();

                if (messages.length === 0) {
                    messagesList.innerHTML = '<div style="text-align: center; color: #666; padding: 2rem;">No messages yet. Send a message to your PT!</div>';
                    return;
                }

                // Render messages
                let html = '';
                messages.forEach(msg => {
                    const isFromPatient = msg.sender_id === currentUser.id;
                    const createdAt = new Date(msg.created_at);
                    const timeAgo = formatTimeAgo(createdAt);

                    // Check if message can be undone (within 1 hour)
                    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
                    const canUndo = isFromPatient && createdAt > oneHourAgo;

                    html += `
                        <div style="
                            padding: 12px;
                            margin-bottom: 8px;
                            border-radius: 12px;
                            border-left: 4px solid ${isFromPatient ? '#28a745' : '#007bff'};
                            background: ${isFromPatient ? '#f0fff0' : '#f0f7ff'};
                        ">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                <span style="font-weight: 600; font-size: 13px; color: ${isFromPatient ? '#28a745' : '#007bff'};">
                                    ${isFromPatient ? 'You' : 'PT'}
                                </span>
                                <span style="font-size: 11px; color: #888;">${timeAgo}</span>
                            </div>
                            <div style="font-size: 14px; color: #333; white-space: pre-wrap;">${escapeHtml(msg.body)}</div>
                            <div style="margin-top: 8px; display: flex; gap: 8px;">
                                <button data-action="archive-message" data-id="${msg.id}" style="background: transparent; border: none; color: #888; cursor: pointer; padding: 4px 8px; font-size: 11px;">Hide</button>
                                ${canUndo ? `<button data-action="undo-send-message" data-id="${msg.id}" style="background: transparent; border: none; color: #dc3545; cursor: pointer; padding: 4px 8px; font-size: 11px;">Undo Send</button>` : ''}
                            </div>
                        </div>
                    `;
                });

                messagesList.innerHTML = html;

            } catch (error) {
                console.error('Error loading messages:', error);
                messagesList.innerHTML = '<div style="text-align: center; color: #dc3545; padding: 2rem;">Failed to load messages</div>';
            }
        }

        async function sendMessage() {
            const textEl = document.getElementById('newMessageText');
            const text = textEl.value.trim();

            if (!text) {
                showToast('Please enter a message', 'error');
                return;
            }

            if (!currentUser || !authToken) {
                showToast('Please sign in to send messages', 'error');
                return;
            }

            try {
                if (!therapistId) {
                    showToast('No therapist assigned. Cannot send message.', 'error');
                    return;
                }

                const response = await fetch('/api/logs?type=messages', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        recipient_id: therapistId,
                        body: text
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to send message');
                }

                textEl.value = '';
                await loadMessages();
                showToast('Message sent');

            } catch (error) {
                console.error('Error sending message:', error);
                showToast('Failed to send message', 'error');
            }
        }

        async function archiveMessage(messageId) {
            if (!authToken) return;

            try {
                const response = await fetch(`/api/logs?type=messages&id=${messageId}`, {
                    method: 'PATCH',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ archived: true })
                });

                if (!response.ok) {
                    throw new Error('Failed to archive message');
                }

                await loadMessages();

            } catch (error) {
                console.error('Error archiving message:', error);
                showToast('Failed to hide message', 'error');
            }
        }

        async function undoSendMessage(messageId) {
            if (!authToken) return;

            if (!confirm('Delete this message? It will be removed for both you and your PT.')) {
                return;
            }

            try {
                const response = await fetch(`/api/logs?type=messages&id=${messageId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete message');
                }

                await loadMessages();
                showToast('Message deleted');

            } catch (error) {
                console.error('Error deleting message:', error);
                showToast('Failed to delete message', 'error');
            }
        }

        async function checkForNewMessages() {
            if (!currentUser || !authToken) return;

            try {
                const response = await fetch('/api/logs?type=messages', {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                if (!response.ok) return;

                const { messages } = await response.json();

                // Count unread messages (received after lastReadMessageTime)
                const unreadCount = messages.filter(msg => {
                    const isFromOther = msg.sender_id !== currentUser.id;
                    const isNew = new Date(msg.created_at) > new Date(lastReadMessageTime);
                    return isFromOther && isNew;
                }).length;

                const badge = document.getElementById('messagesBadge');
                if (badge) {
                    if (unreadCount > 0) {
                        badge.textContent = unreadCount;
                        badge.classList.remove('hidden');
                    } else {
                        badge.classList.add('hidden');
                    }
                }

            } catch (error) {
                console.error('Error checking for new messages:', error);
            }
        }

        // ============================================================================
        // EDIT SESSION FUNCTIONALITY
        // ============================================================================

        let editingLog = null; // Currently editing log

        /**
         * Open the Edit Session modal for a specific log entry.
         */
        function openEditSessionModal(logId) {
            editingLog = allHistory.find(log => log.id === logId);
            if (!editingLog) {
                showToast('Session not found', 'error');
                return;
            }

            // Find exercise info
            const exercise = allExercises.find(ex => ex.id === editingLog.exercise_id);
            const isSided = exercise?.pattern === 'side';

            // Populate exercise info
            document.getElementById('editSessionExerciseName').textContent = editingLog.exercise_name;
            document.getElementById('editSessionExerciseType').textContent = isSided ? 'üîÑ Sided' : '';

            // Populate date
            const date = new Date(editingLog.performed_at);
            const dateInput = document.getElementById('editSessionDate');
            // Format for datetime-local input
            const localDate = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
            dateInput.value = localDate.toISOString().slice(0, 16);

            // Populate notes
            document.getElementById('editSessionNotes').value = editingLog.notes || '';

            // Render sets
            renderEditSessionSets(editingLog.sets || [], isSided, exercise);

            document.getElementById('editSessionModal').classList.remove('hidden');
        }

        /**
         * Render the sets list in the Edit Session modal.
         */
        function renderEditSessionSets(sets, isSided, exercise) {
            const container = document.getElementById('editSessionSetsList');
            const formParams = exercise?.form_parameters_required || [];

            if (sets.length === 0) {
                container.innerHTML = '<div style="color: #888; font-style: italic;">No sets logged</div>';
                return;
            }

            const html = sets.map((set, index) => {
                // Build form params display
                let paramsHtml = '';
                if (formParams.length > 0 && set.form_data && set.form_data.length > 0) {
                    paramsHtml = set.form_data.map(p => `
                        <div style="display: flex; gap: 8px; margin-top: 8px;">
                            <label style="flex: 1; font-size: 0.85rem; color: #888;">${p.parameter_name}</label>
                            <input type="text" class="edit-set-param" data-set="${index}" data-param="${p.parameter_name}"
                                value="${p.parameter_value}${p.parameter_unit ? ' ' + p.parameter_unit : ''}"
                                style="flex: 2; padding: 6px 10px; border: 1px solid #555; border-radius: 4px; background: #2a2a2a; color: #fff; font-size: 0.9rem;">
                        </div>
                    `).join('');
                }

                return `
                    <div class="edit-session-set" style="background: #1a1a1a; border-radius: 8px; padding: 12px; margin-bottom: 12px; border: 1px solid #333;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-weight: 600;">Set ${index + 1}</span>
                            <button type="button" class="btn" style="background: transparent; color: #dc3545; padding: 4px 12px; font-size: 0.85rem;" data-action="delete-edit-session-set" data-set-index="${index}">Delete</button>
                        </div>
                        <div style="display: flex; gap: 12px;">
                            <div style="flex: 1;">
                                <label style="font-size: 0.85rem; color: #888; display: block; margin-bottom: 4px;">Reps</label>
                                <input type="number" class="edit-set-reps" data-set="${index}" value="${set.reps || 0}"
                                    style="width: 100%; padding: 10px; border: 1px solid #555; border-radius: 4px; background: #2a2a2a; color: #fff; font-size: 1rem;">
                            </div>
                            ${isSided ? `
                            <div style="flex: 1;">
                                <label style="font-size: 0.85rem; color: #888; display: block; margin-bottom: 4px;">Side</label>
                                <select class="edit-set-side" data-set="${index}"
                                    style="width: 100%; padding: 10px; border: 1px solid #555; border-radius: 4px; background: #2a2a2a; color: #fff; font-size: 1rem;">
                                    <option value="left" ${set.side === 'left' ? 'selected' : ''}>Left</option>
                                    <option value="right" ${set.side === 'right' ? 'selected' : ''}>Right</option>
                                </select>
                            </div>
                            ` : ''}
                        </div>
                        ${paramsHtml}
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        /**
         * Add a new set to the editing session.
         */
        function addEditSessionSet() {
            if (!editingLog) return;

            const exercise = allExercises.find(ex => ex.id === editingLog.exercise_id);
            const isSided = exercise?.pattern === 'side';

            // Create new set with default values
            const newSet = {
                set_number: (editingLog.sets?.length || 0) + 1,
                reps: exercise?.current_reps || 10,
                seconds: null,
                side: isSided ? 'right' : null,
                form_data: null,
                performed_at: new Date().toISOString()
            };

            if (!editingLog.sets) editingLog.sets = [];
            editingLog.sets.push(newSet);

            renderEditSessionSets(editingLog.sets, isSided, exercise);
        }

        /**
         * Delete a set from the editing session.
         */
        function deleteEditSessionSet(setIndex) {
            if (!editingLog || !editingLog.sets) return;

            editingLog.sets.splice(setIndex, 1);

            // Renumber sets
            editingLog.sets.forEach((set, i) => set.set_number = i + 1);

            const exercise = allExercises.find(ex => ex.id === editingLog.exercise_id);
            const isSided = exercise?.pattern === 'side';
            renderEditSessionSets(editingLog.sets, isSided, exercise);
        }

        function closeEditSessionModal() {
            document.getElementById('editSessionModal').classList.add('hidden');
            editingLog = null;
        }

        /**
         * Save edited session to the API.
         */
        async function saveEditSession() {
            if (!editingLog) return;

            // Collect updated values from form
            const dateInput = document.getElementById('editSessionDate');
            const notesInput = document.getElementById('editSessionNotes');

            // Update sets from form inputs
            document.querySelectorAll('.edit-set-reps').forEach(input => {
                const setIndex = parseInt(input.dataset.set);
                if (editingLog.sets[setIndex]) {
                    editingLog.sets[setIndex].reps = parseInt(input.value) || 0;
                }
            });

            document.querySelectorAll('.edit-set-side').forEach(select => {
                const setIndex = parseInt(select.dataset.set);
                if (editingLog.sets[setIndex]) {
                    editingLog.sets[setIndex].side = select.value;
                }
            });

            // Update form parameters
            document.querySelectorAll('.edit-set-param').forEach(input => {
                const setIndex = parseInt(input.dataset.set);
                const paramName = input.dataset.param;
                if (editingLog.sets[setIndex] && editingLog.sets[setIndex].form_data) {
                    const param = editingLog.sets[setIndex].form_data.find(p => p.parameter_name === paramName);
                    if (param) {
                        // Parse value and unit if present
                        const parts = input.value.trim().split(/\s+/);
                        param.parameter_value = parts[0] || input.value;
                        if (parts.length > 1) {
                            param.parameter_unit = parts.slice(1).join(' ');
                        }
                    }
                }
            });

            try {
                const response = await fetchWithAuth(`/api/logs/${editingLog.id}`, {
                    method: 'PATCH',
                    body: JSON.stringify({
                        performed_at: new Date(dateInput.value).toISOString(),
                        notes: notesInput.value || null,
                        sets: editingLog.sets
                    })
                });

                showToast('Session updated', 'success');
                closeEditSessionModal();
                await loadHistory();

            } catch (error) {
                console.error('Error updating session:', error);
                showToast('Failed to update session', 'error');
            }
        }

        /**
         * Delete the entire session.
         */
        async function deleteSession() {
            if (!editingLog) return;

            if (!confirm('Are you sure you want to delete this entire session? This cannot be undone.')) {
                return;
            }

            try {
                await fetchWithAuth(`/api/logs/${editingLog.id}`, {
                    method: 'DELETE'
                });

                showToast('Session deleted', 'success');
                closeEditSessionModal();
                await loadHistory();

            } catch (error) {
                console.error('Error deleting session:', error);
                showToast('Failed to delete session', 'error');
            }
        }

        function formatTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return 'just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;

            return formatDateWithZone(date);
        }

        function formatDateTimeWithZone(date, options = {}) {
            const baseOptions = { timeZoneName: 'short', ...options };
            try {
                return new Intl.DateTimeFormat(undefined, baseOptions).format(date);
            } catch (error) {
                return new Intl.DateTimeFormat('en-US', {
                    ...baseOptions,
                    timeZone: 'America/New_York'
                }).format(date);
            }
        }

        function formatDateWithZone(date, options = {}) {
            return formatDateTimeWithZone(date, {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                ...options
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Save the current session and attempt immediate sync.
         * If sync fails, session is queued in localStorage for later retry.
         */
        async function saveSession(notes) {
            const hasNotes = notes && notes.trim().length > 0;
            currentSession.notes = hasNotes ? notes.trim() : null;

            // Add to offline queue
            offlineQueue.push(currentSession);
            saveOfflineQueue();
            updateSyncBadge();

            // Try to sync immediately if online
            let syncSucceeded = false;
            try {
                await syncOfflineQueue();
                syncSucceeded = (offlineQueue.length === 0); // Check if queue is empty after sync
            } catch (error) {
                console.error('Sync failed, session queued for later:', error);
            }

            closeNotesModal();
            document.getElementById('sessionNotes').value = '';
            currentSession = null;
            currentExercise = null;
            showView('picker');

            // Show toast with note status
            const noteStatus = hasNotes ? 'with notes' : 'no notes';
            showToast(`Saved (${noteStatus})`);
        }

        // Offline queue management
        function loadOfflineQueue() {
            const stored = localStorage.getItem('pt_offline_queue');
            if (stored) {
                try {
                    const rawQueue = JSON.parse(stored);

                    /**
                     * MIGRATION CODE - CAN BE REMOVED AFTER ALL USERS MIGRATED (est. 2026-03)
                     *
                     * Migrates old session format to new format.
                     * Old bug: Hold exercises created multiple sets (one per rep) with reps=null.
                     * Fix: Collapse into single set with correct rep count.
                     *
                     * This migration preserves all clinical data that was logged before the fix.
                     * Once all users have migrated their offline queues, this code can be safely removed.
                     */
                    offlineQueue = rawQueue.map((session, sessionIdx) => {
                        // Check if this is an old format session (missing set_number)
                        if (session.sets && session.sets.length > 0) {
                            const firstSet = session.sets[0];

                            // Old format: has "timestamp" instead of "performed_at", missing "set_number"
                            if (firstSet.timestamp && !firstSet.set_number) {
                                console.log('Migrating old format session:', session.sessionId);

                                // Check if this is a hold exercise (multiple sets with reps: null, seconds: X)
                                // This was the bug - each hold created a separate set
                                const allSetsHaveNullRepsAndSeconds = session.sets.every(s =>
                                    (s.reps === null || s.reps === undefined) &&
                                    (s.seconds !== null && s.seconds !== undefined && s.seconds > 0)
                                );

                                if (allSetsHaveNullRepsAndSeconds) {
                                    // COLLAPSE: multiple sets ‚Üí 1 set with reps = count
                                    const holdSeconds = session.sets[0].seconds;
                                    const totalReps = session.sets.length;

                                    console.log(`Collapsing ${totalReps} hold sets into 1 set (${totalReps} reps √ó ${holdSeconds}s)`);

                                    const migratedSets = [{
                                        set_number: 1,
                                        reps: totalReps,
                                        seconds: holdSeconds,
                                        distance_feet: null,
                                        side: session.sets[0].side || null,
                                        form_data: null,
                                        manual_log: false,
                                        partial_rep: false,
                                        performed_at: session.sets[0].timestamp || session.date
                                    }];

                                    return {
                                        ...session,
                                        sets: migratedSets
                                    };
                                } else {
                                    // Normal migration: just add new fields
                                    const migratedSets = session.sets.map((set, idx) => ({
                                        set_number: idx + 1,
                                        reps: set.reps || null,
                                        seconds: set.seconds || null,
                                        distance_feet: null,
                                        side: set.side || null,
                                        form_data: null,
                                        manual_log: false,
                                        partial_rep: false,
                                        performed_at: set.timestamp || session.date
                                    }));

                                    return {
                                        ...session,
                                        sets: migratedSets
                                    };
                                }
                            }
                        }
                        return session; // Return unchanged if already in new format
                    });

                    // Save migrated queue
                    if (JSON.stringify(rawQueue) !== JSON.stringify(offlineQueue)) {
                        saveOfflineQueue();
                        console.log('Migrated old sessions to new format');
                    }
                    // END MIGRATION CODE - Can be removed after all users migrated (est. 2026-03)
                } catch (e) {
                    console.error('Error loading offline queue:', e);
                    offlineQueue = [];
                }
            }
        }

        function saveOfflineQueue() {
            localStorage.setItem('pt_offline_queue', JSON.stringify(offlineQueue));
        }

        function updateSyncBadge() {
            const badge = document.getElementById('syncBadge');
            if (offlineQueue.length > 0) {
                badge.textContent = `${offlineQueue.length} unsynced`;
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        }

        async function syncOfflineQueue() {
            if (offlineQueue.length === 0) {
                showToast('Nothing to sync!', '');
                return;
            }

            let successCount = 0;
            let failCount = 0;

            for (const session of [...offlineQueue]) {
                try {
                    // Use stored activity type, or fallback to guessing from data
                    let activityType = session.activityType || 'reps';
                    if (!session.activityType && session.sets && session.sets.length > 0) {
                        // Fallback for old sessions without activityType
                        const firstSet = session.sets[0];
                        if (firstSet.distance_feet != null && firstSet.distance_feet > 0) {
                            activityType = 'distance';
                        } else if (firstSet.seconds != null && firstSet.seconds > 0) {
                            activityType = (firstSet.reps != null && firstSet.reps > 0) ? 'hold' : 'duration';
                        }
                    }

                    const apiSession = {
                        exercise_id: session.exerciseId || null,
                        exercise_name: session.exerciseName,
                        activity_type: activityType,
                        notes: session.notes || null,
                        performed_at: session.date,
                        client_mutation_id: session.sessionId,
                        sets: session.sets.map(set => ({
                            set_number: set.set_number,
                            reps: set.reps || null,
                            seconds: set.seconds || null,
                            distance_feet: set.distance_feet || null,
                            side: set.side || null,
                            form_data: set.form_data || null,
                            manual_log: set.manual_log || false,
                            partial_rep: set.partial_rep || false,
                            performed_at: set.performed_at || session.date
                        }))
                    };

                    const response = await fetchWithAuth('/api/logs', {
                        method: 'POST',
                        body: JSON.stringify(apiSession)
                    });

                    // Success or duplicate - remove from queue
                    offlineQueue = offlineQueue.filter(s => s.sessionId !== session.sessionId);
                    successCount++;

                } catch (error) {
                    console.error('Failed to sync session:', session.sessionId, error);

                    // Handle 409 duplicate as success (session already exists in DB)
                    if (error.message && error.message.includes('409')) {
                        offlineQueue = offlineQueue.filter(s => s.sessionId !== session.sessionId);
                        successCount++;
                        console.log('Removed duplicate session from queue:', session.sessionId);
                    } else {
                        // Show detailed error in toast for debugging
                        showToast(`Sync error: ${error.message || error}`, 'error', 5000);
                        failCount++;
                    }
                }
            }

            saveOfflineQueue();
            updateSyncBadge();

            if (failCount === 0) {
                showToast(`‚úì Synced ${successCount} sessions successfully!`, 'success');
            } else {
                showToast(`Synced ${successCount} sessions. ${failCount} failed (will retry later).`, 'error');
            }

            // Reload history
            await loadHistory();
        }

        // View management
        function showView(viewName) {
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));

            if (viewName === 'picker') {
                document.getElementById('pickerView').classList.add('active');
                document.querySelector('[data-view="picker"]').classList.add('active');
            } else if (viewName === 'logger') {
                document.getElementById('loggerView').classList.add('active');
            } else if (viewName === 'history') {
                document.getElementById('historyView').classList.add('active');
                document.querySelector('[data-view="history"]').classList.add('active');
            }
        }

        /**
         * Show a toast notification (brief message that fades away).
         * Better UX than blocking alerts.
         * @param {string} message - The message to display
         * @param {string} type - 'success', 'error', or default (neutral)
         * @param {number} duration - How long to show in ms (default 3000)
         */
        function showToast(message, type = '', duration = 3000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;

            container.appendChild(toast);

            // Trigger animation
            setTimeout(() => toast.classList.add('show'), 10);

            // Remove after duration
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => container.removeChild(toast), 300);
            }, duration);
        }

        // Search
        function handleSearch(query) {
            if (!query.trim()) {
                renderExerciseList(allExercises);
                return;
            }

            const lowerQuery = query.toLowerCase();
            const filtered = allExercises.filter(ex =>
                ex.canonical_name.toLowerCase().includes(lowerQuery) ||
                ex.description.toLowerCase().includes(lowerQuery)
            );

            renderExerciseList(filtered);
        }

        // Event handlers
        function bindEventHandlers() {
            document.body.addEventListener('pointerup', () => {
                ensureAudioReady();
            }, { once: true });

            // Auth form
            document.getElementById('authForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                const email = document.getElementById('emailInput').value;
                const password = document.getElementById('passwordInput').value;
                const errorEl = document.getElementById('authError');

                try {
                    await signIn(email, password);
                    errorEl.textContent = '';
                } catch (error) {
                    errorEl.textContent = error.message;
                }
            });

            // Search
            document.getElementById('searchInput').addEventListener('input', (e) => {
                handleSearch(e.target.value);
            });

            // Notes form
            document.getElementById('notesForm').addEventListener('submit', (e) => {
                e.preventDefault();
                const notes = document.getElementById('sessionNotes').value;
                saveSession(notes);
                document.getElementById('sessionNotes').value = '';
            });

            /**
             * Bind iOS-safe pointer event handlers to elements with data-action attributes.
             *
             * iOS Safari/PWA does not reliably trigger onclick handlers on dynamically created elements.
             * This function binds pointerup events (which work consistently on iOS touch and desktop mouse)
             * and keyboard events for accessibility.
             */
            document.body.addEventListener('pointerup', (e) => {
                const target = e.target.closest('[data-action]');
                if (!target) return;

                const action = target.dataset.action;

                switch (action) {
                    case 'show-view':
                        showView(target.dataset.view);
                        break;
                    case 'select-exercise':
                        selectExercise(target.dataset.id);
                        break;
                    case 'counter-tap':
                    case 'counter-increase':
                        increaseCounter();
                        break;
                    case 'counter-decrease':
                        decreaseCounter();
                        break;
                    case 'timer-start-pause':
                        toggleTimer();
                        break;
                    case 'timer-reset':
                        resetTimer();
                        break;
                    case 'previous-set':
                        previousSet();
                        break;
                    case 'show-log-set-modal':
                        showLogSetModal();
                        break;
                    case 'show-next-set-modal':
                        showNextSetModal();
                        break;
                    case 'close-next-set-modal':
                        closeNextSetModal();
                        break;
                    case 'edit-next-set':
                        editNextSet();
                        break;
                    case 'confirm-next-set':
                        confirmNextSet();
                        break;
                    case 'finish-session':
                        finishSession();
                        break;
                    case 'back-to-picker':
                        currentSession = null;
                        currentExercise = null;
                        showView('picker');
                        break;
                    case 'close-log-set-modal':
                        closeLogSetModal();
                        break;
                    case 'save-logged-set':
                        saveLoggedSet();
                        break;
                    case 'log-set-select-side':
                        selectLogSetSide(target.dataset.side);
                        break;
                    case 'close-notes-modal':
                        closeNotesModal();
                        break;
                    case 'cancel-session':
                        if (confirm('Cancel without saving?')) {
                            closeNotesModal();
                            currentSession = null;
                            currentExercise = null;
                            document.getElementById('sessionNotes').value = '';
                            showView('picker');
                        }
                        break;
                    case 'show-messages':
                        showMessagesModal();
                        break;
                    case 'close-messages-modal':
                        closeMessagesModal();
                        break;
                    case 'send-message':
                        sendMessage();
                        break;
                    case 'archive-message':
                        archiveMessage(target.dataset.id);
                        break;
                    case 'undo-send-message':
                        undoSendMessage(target.dataset.id);
                        break;
                    case 'manual-sync':
                        toggleHamburger(); // Close menu
                        syncOfflineQueue();
                        break;
                    case 'show-debug':
                        toggleHamburger(); // Close menu
                        showDebugInfo();
                        break;
                    case 'toggle-hamburger':
                        toggleHamburger();
                        break;
                    case 'select-side':
                        selectSide(target.dataset.side);
                        break;
                    case 'sign-out':
                        toggleHamburger(); // Close menu
                        signOut();
                        break;
                    case 'reload':
                        reloadPage();
                        break;
                    case 'edit-session':
                        openEditSessionModal(target.dataset.logId);
                        break;
                    case 'close-edit-session-modal':
                        closeEditSessionModal();
                        break;
                    case 'save-edit-session':
                        saveEditSession();
                        break;
                    case 'delete-session':
                        deleteSession();
                        break;
                    case 'add-edit-session-set':
                        addEditSessionSet();
                        break;
                    case 'delete-edit-session-set':
                        deleteEditSessionSet(parseInt(target.dataset.setIndex));
                        break;
                }
            });
        }

        // Utility functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function generateSessionId() {
            return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }

        // Start the app
        init();
    </script>
</body>
</html>
