<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PT Tracker</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" type="image/svg+xml" href="/icons/icon.svg">
    <link rel="apple-touch-icon" href="/icons/icon.svg">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="PT Tracker">
    <link rel="stylesheet" href="/css/main.css">
    <style>
        :root {
            color-scheme: light;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: #f5f5f5;
            overflow-x: hidden;
            touch-action: manipulation; /* Prevent iOS double-tap zoom */
        }

        /* Utility Classes */
        .hidden {
            display: none !important;
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--toast-bg, #333);
            color: var(--toast-text, white);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10001;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            max-width: 90%;
            text-align: center;
            font-size: 1rem;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .toast.error {
            background: var(--toast-error-bg, #dc3545);
        }

        .toast.success {
            background: var(--toast-success-bg, #28a745);
        }

        /* Auth Modal */
        .auth-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .auth-modal.hidden {
            display: none;
        }

        .auth-content {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            max-width: 400px;
            width: 90%;
        }

        .auth-content h2 {
            margin: 0 0 1.5rem 0;
        }

        .auth-form input {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }

        .auth-form button {
            width: 100%;
            padding: 0.75rem;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
        }

        .auth-form button:active {
            background: #0056b3;
        }

        .auth-error {
            color: #d32f2f;
            margin-top: 1rem;
            font-size: 14px;
        }

        /* Header */
        .header {
            background: white;
            padding: 1rem;
            border-bottom: 2px solid #007bff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            margin: 0;
            font-size: 1.5rem;
            color: #007bff;
        }

        .header-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        /* Patient Info Banner (for therapists viewing patient data) */
        .patient-banner {
            background: #e3f2fd;
            color: #1565c0;
            padding: 0.75rem 1rem;
            text-align: center;
            font-size: 0.95rem;
            border-bottom: 1px solid #bbdefb;
        }

        .patient-banner.hidden {
            display: none;
        }

        .connectivity-indicator {
            font-size: 16px;
            position: relative;
            margin-right: 0.5rem;
        }

        .connectivity-indicator.offline::after {
            content: 'üö´';
            position: absolute;
            top: -2px;
            left: -2px;
            font-size: 20px;
            opacity: 0.9;
        }

        .sync-badge {
            background: #ffc107;
            color: #000;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }

        .sync-badge.hidden {
            display: none;
        }

        .messages-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            background: #dc3545;
            color: white;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 10px;
            font-weight: bold;
            min-width: 16px;
            text-align: center;
        }

        .messages-badge.hidden {
            display: none;
        }

        .btn {
            padding: 0.5rem 1rem;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px; /* Apple HIG minimum touch target */
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-success {
            background: #28a745;
        }

        .btn:active {
            opacity: 0.8;
        }

        /* Hamburger Menu */
        .hamburger-btn {
            background: transparent;
            border: none;
            font-size: 22px;
            cursor: pointer;
            padding: 4px 8px;
            touch-action: manipulation;
        }

        .hamburger-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9998;
        }

        .hamburger-overlay.active {
            display: block;
        }

        .hamburger-menu {
            display: none;
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 280px;
            background: white;
            z-index: 9999;
            box-shadow: -2px 0 8px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
        }

        .hamburger-menu.active {
            display: block;
        }

        .hamburger-header {
            padding: 20px;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .hamburger-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .hamburger-close {
            background: transparent;
            border: none;
            color: #007bff;
            font-size: 16px;
            cursor: pointer;
            padding: 8px;
        }

        .hamburger-item {
            padding: 16px 20px;
            border-bottom: 1px solid #ddd;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            text-decoration: none;
            color: inherit;
            touch-action: manipulation;
        }

        .hamburger-item:active {
            background: #f0f0f0;
        }

        .hamburger-icon {
            font-size: 20px;
            width: 24px;
            text-align: center;
        }

        .user-info {
            padding: 1rem;
            background: #f8f9fa;
            border-bottom: 1px solid #ddd;
        }

        .user-email {
            font-size: 14px;
            color: #333;
            word-break: break-all;
        }

        .user-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
        }

        /* Side Tracking */
        .side-tracking {
            background: white;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .side-tracking-label {
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: #666;
        }

        .side-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .side-btn {
            flex: 1;
            padding: 0.75rem;
            background: white;
            border: 2px solid #007bff;
            color: #007bff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px;
        }

        .side-btn.active {
            background: #007bff;
            color: white;
        }

        .side-btn:active {
            opacity: 0.8;
        }

        /* Visual Feedback */
        .log-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(40, 167, 69, 0.95);
            color: white;
            padding: 2rem;
            border-radius: 12px;
            font-size: 3rem;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .log-feedback.show {
            opacity: 1;
        }

        /* Exercise Picker View */
        .view {
            display: none;
            padding: 1rem;
        }

        .view.active {
            display: block;
        }

        .search-container {
            margin-bottom: 1rem;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }

        .exercise-card {
            background: white;
            padding: 1rem;
            margin-bottom: 0.5rem;
            border-radius: 4px;
            border: 1px solid #ddd;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            position: relative;
        }

        .exercise-card:active {
            background: #f0f0f0;
        }

        /* Details button - top right of exercise card */
        .details-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: transparent;
            border: none;
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .details-btn:active {
            background: rgba(0, 0, 0, 0.1);
        }

        /* Pill badges for muscles, pattern, etc */
        .pill {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 500;
        }

        /* Detail section spacing in modal */
        .detail-section {
            margin-bottom: 16px;
        }

        .detail-section-title {
            font-weight: 600;
            margin-bottom: 8px;
        }

        .detail-section-content {
            font-size: 14px;
            color: #666;
        }

        .detail-pills {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .detail-list {
            margin: 0;
            padding-left: 20px;
            font-size: 13px;
            color: #666;
        }

        .detail-list li {
            margin-bottom: 6px;
        }

        .exercise-name {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 0.25rem;
        }

        .exercise-dosage {
            font-size: 0.9rem;
            color: #666;
        }

        .exercise-adherence {
            font-size: 0.8rem;
            font-weight: 600;
            margin-top: 4px;
        }

        .exercise-adherence.green { color: #34C759; }
        .exercise-adherence.orange { color: #FF9500; }
        .exercise-adherence.red { color: #FF3B30; }
        .exercise-adherence.gray { color: #8E8E93; }

        .exercise-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
        }

        .exercise-tag {
            font-size: 0.7rem;
            background: #e0e0e0;
            color: #555;
            padding: 2px 8px;
            border-radius: 12px;
        }

        /* Control Buttons Row */
        .control-buttons {
            display: flex;
            gap: 8px;
            margin-top: 1rem;
            padding: 0 1rem;
        }

        .control-btn {
            flex: 1;
            padding: 14px 12px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            touch-action: manipulation;
        }

        .control-btn-secondary {
            background: #6c757d;
            color: white;
        }

        .control-btn-primary {
            background: #007AFF;
            color: white;
        }

        .control-btn-success {
            background: #34C759;
            color: white;
        }

        .control-btn:active {
            opacity: 0.8;
        }

        /* Logger View */
        .logger-header {
            background: white;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .logger-exercise-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .logger-dosage {
            font-size: 0.9rem;
            color: #666;
        }

        .counter-container {
            background: white;
            padding: 2rem 1rem;
            margin-bottom: 1rem;
            border-radius: 4px;
            border: 1px solid #ddd;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .counter-label {
            font-size: 1rem;
            color: #666;
            margin-bottom: 1.5rem;
        }

        /**
         * Big tappable circle for counting reps.
         * iOS Safari optimized: Large touch target, smooth feedback.
         */
        .counter-display {
            width: min(320px, 85vw);
            height: min(320px, 85vw);
            border-radius: 50%;
            background: var(--counter-bg, white);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 72px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            font-weight: 700;
            color: var(--counter-color, #007bff);
            box-shadow: 0 4px 20px rgba(0, 122, 255, 0.3);
            margin-bottom: 30px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            /* iOS Safari touch fixes for large tap target */
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }

        .counter-display:active {
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(0, 122, 255, 0.2);
        }

        .counter-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 0.5rem;
        }

        .counter-btn {
            padding: 0.5rem 1.5rem;
            border-radius: 8px;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px;
            color: white;
        }

        .counter-btn-minus {
            background: #dc3545;
        }

        .counter-btn-plus {
            background: #28a745;
        }

        .counter-btn:active {
            opacity: 0.8;
        }

        /* Timer Mode */
        .timer-container {
            background: white;
            padding: 2rem 1rem;
            margin-bottom: 1rem;
            border-radius: 4px;
            border: 1px solid #ddd;
            text-align: center;
        }

        .timer-info {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 0.5rem;
        }

        .timer-display {
            font-size: 4rem;
            font-weight: bold;
            color: var(--timer-color, #007bff);
            margin: 1rem 0;
            font-variant-numeric: tabular-nums;
        }

        .timer-target {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 1.5rem;
        }

        .timer-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .timer-btn {
            padding: 0.75rem 2rem;
            border-radius: 4px;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px;
        }

        .timer-btn-start {
            background: #28a745;
            color: white;
        }

        .timer-btn-reset {
            background: #6c757d;
            color: white;
        }

        .timer-btn:active {
            opacity: 0.8;
        }

        .set-info {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        .set-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .log-set-btn {
            width: 100%;
            padding: 1rem;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 0.5rem;
        }

        .log-set-btn:active {
            background: #218838;
        }

        .finish-session-btn {
            width: 100%;
            padding: 1rem;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
        }

        .finish-session-btn:active {
            background: #0056b3;
        }

        /* History View */
        .session-card {
            background: white;
            padding: 1rem;
            margin-bottom: 0.5rem;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .session-date {
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .session-exercise {
            font-size: 0.9rem;
            color: #666;
        }

        .session-sets {
            font-size: 0.85rem;
            color: #999;
            margin-top: 0.25rem;
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            overflow-y: auto;
        }

        .modal.hidden {
            display: none;
        }

        .modal-content {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .modal-header h2 {
            margin: 0;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 2rem;
            height: 2rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .modal-input,
        .modal-select {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 17px; /* Prevent iOS zoom on focus */
            margin-bottom: 12px;
            font-family: inherit;
            background: #f2f2f7;
            color: #111;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            -webkit-appearance: none;
            -webkit-tap-highlight-color: transparent;
        }

        .modal-input:focus,
        .modal-select:focus {
            outline: none;
            box-shadow: 0 0 0 2px #007AFF;
        }

        input[type="number"],
        input[type="text"],
        textarea,
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.25rem;
            font-weight: 500;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 17px; /* >= 16px prevents iOS zoom */
        }

        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }

        .form-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1.5rem;
        }

        .form-actions button {
            flex: 1;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #666;
        }

        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: #666;
        }

        .nav-tabs {
            display: flex;
            background: white;
            border-bottom: 1px solid #ddd;
        }

        .nav-tab {
            flex: 1;
            padding: 1rem;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            border-bottom: 2px solid transparent;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px;
        }

        .nav-tab.active {
            border-bottom-color: #007bff;
            color: #007bff;
            font-weight: bold;
        }

        .nav-tab:active {
            background: #f0f0f0;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                color-scheme: dark;
                --toast-bg: #1f2430;
                --toast-text: #f5f5f5;
                --toast-error-bg: #ff5a5f;
                --toast-success-bg: #3ddc84;
                --counter-bg: #1b1f27;
                --counter-color: #7bb1ff;
                --timer-color: #7bb1ff;
            }

            body {
                background: #0f1115;
                color: #f5f5f5;
            }

            .auth-modal {
                background: rgba(0, 0, 0, 0.85);
            }

            .auth-content,
            .header,
            .hamburger-menu,
            .side-tracking,
            .exercise-card,
            .logger-header,
            .counter-container,
            .timer-container,
            .session-card,
            .modal-content,
            .nav-tabs,
            .set-info {
                background: #1c1f26;
                border-color: #2a2f3a;
            }

            .header {
                border-bottom-color: #4c8dff;
            }

            .header h1,
            .hamburger-close,
            .nav-tab.active {
                color: #4c8dff;
            }

            .sync-badge {
                background: #3a3f4b;
                color: #f5f5f5;
            }

            .auth-form input,
            .search-input,
            .form-group input,
            .form-group select,
            .form-group textarea {
                background: #1b1f27;
                border-color: #2a2f3a;
                color: #f5f5f5;
            }

            .hamburger-header,
            .hamburger-item,
            .user-info,
            .nav-tabs {
                border-color: #2a2f3a;
            }

            .user-info {
                background: #1b1f27;
            }

            .user-email {
                color: #f5f5f5;
            }

            .user-label {
                color: #b5b5b5;
            }

            .hamburger-item:active,
            .exercise-card:active,
            .nav-tab:active {
                background: #232836;
            }

            .side-btn {
                background: #1c1f26;
                border-color: #4c8dff;
                color: #8fb8ff;
            }

            .side-btn.active {
                background: #4c8dff;
                color: #0f1115;
            }

            .side-tracking-label,
            .exercise-dosage,
            .logger-dosage,
            .counter-label,
            .timer-info,
            .timer-target,
            .session-exercise,
            .session-sets,
            .loading,
            .empty-state {
                color: #b5b5b5;
            }

            .modal {
                background: rgba(0, 0, 0, 0.7);
            }

            #formParamsContainer,
            #nextSetParamsContainer {
                background: rgba(76, 141, 255, 0.12) !important;
            }

            #formParamsContainer > div,
            #nextSetParamsContainer > div {
                color: #d5d5d5;
            }

            .exercise-tag {
                background: #3a3f4b;
                color: #b5b5b5;
            }

            .control-btn-secondary {
                background: #4a4f5c;
            }
        }

        /* ‚îÄ‚îÄ‚îÄ Pocket Mode ‚îÄ‚îÄ‚îÄ */
        /* Full-screen eyes-free overlay for counter/timer exercises. */
        .pocket-overlay {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .pocket-overlay.active {
            display: flex;
        }
        .pocket-close {
            position: absolute;
            top: 1rem;
            left: 1rem;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            border: none;
            color: #fff;
            font-size: 1.3rem;
            line-height: 44px;
            text-align: center;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            cursor: pointer;
        }
        .pocket-pad {
            width: min(88vw, 380px);
            background: #fff;
            border-radius: 24px;
            padding: 2rem 1.5rem;
            text-align: center;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }
        .pocket-label {
            font-size: clamp(56px, 18vw, 80px);
            font-weight: 700;
            color: #1a1a2e;
            line-height: 1.1;
            margin: 0.25rem 0;
        }
        .pocket-meta {
            font-size: 1rem;
            color: #555;
            margin-top: 0.5rem;
        }
        .pocket-hint {
            font-size: 0.82rem;
            color: #999;
            margin-top: 0.75rem;
        }
        .pocket-mode-btn {
            width: 100%;
            margin-top: 0.5rem;
            padding: 0.7rem 1rem;
            background: #3a3f4c;
            color: #ccc;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- Auth Modal -->
    <div id="authModal" class="auth-modal">
        <div class="auth-content">
            <h2>PT Tracker Sign In</h2>
            <form id="authForm" class="auth-form">
                <input
                    type="email"
                    id="emailInput"
                    placeholder="Email"
                    required
                    autocomplete="email"
                >
                <input
                    type="password"
                    id="passwordInput"
                    placeholder="Password"
                    required
                    autocomplete="current-password"
                >
                <button type="submit">Sign In</button>
                <div id="authError" class="auth-error"></div>
                <a href="#" id="forgotPasswordLink" style="display: block; text-align: center; margin-top: 1rem; color: #007bff; font-size: 14px;">Forgot password?</a>
            </form>
        </div>
    </div>

    <!-- Forgot Password Modal -->
    <div id="forgotPasswordModal" class="auth-modal hidden">
        <div class="auth-content">
            <h2>Reset Password</h2>
            <p style="margin-bottom: 1rem; color: #666; font-size: 14px;">Enter your email and we'll send you a reset link.</p>
            <form id="forgotPasswordForm" class="auth-form">
                <input type="email" id="resetEmailInput" placeholder="Email" required autocomplete="email">
                <button type="submit">Send Reset Link</button>
                <div id="resetError" class="auth-error"></div>
                <a href="#" id="backToLoginLink" style="display: block; text-align: center; margin-top: 1rem; color: #007bff; font-size: 14px;">Back to sign in</a>
            </form>
        </div>
    </div>

    <!-- Set New Password Modal -->
    <div id="newPasswordModal" class="auth-modal hidden">
        <div class="auth-content">
            <h2>Set New Password</h2>
            <form id="newPasswordForm" class="auth-form">
                <input type="password" id="newPasswordInput" placeholder="New password" required minlength="6" autocomplete="new-password">
                <input type="password" id="confirmPasswordInput" placeholder="Confirm password" required minlength="6" autocomplete="new-password">
                <button type="submit">Update Password</button>
                <div id="newPasswordError" class="auth-error"></div>
            </form>
        </div>
    </div>

    <!-- Header -->
    <div class="header">
        <h1>PT Tracker</h1>
        <div class="header-actions">
            <span id="connectivityIndicator" class="connectivity-indicator" title="Online">üõú</span>
            <span id="syncBadge" class="sync-badge hidden">0 unsynced</span>
            <button class="hamburger-btn" data-action="toggle-hamburger">‚ò∞</button>
        </div>
    </div>

    <!-- Patient Info Banner (shown when therapist is viewing patient data) -->
    <div id="patientBanner" class="patient-banner hidden">
        Viewing exercises for: <strong id="patientName">-</strong>
    </div>

    <!-- Hamburger Menu -->
    <div class="hamburger-overlay" id="hamburgerOverlay" data-action="toggle-hamburger"></div>
    <div class="hamburger-menu" id="hamburgerMenu">
        <div class="hamburger-header">
            <h3>Menu</h3>
            <button class="hamburger-close" data-action="toggle-hamburger">Close</button>
        </div>
        <div class="user-info">
            <div class="user-label">Signed in as</div>
            <div class="user-email" id="userEmail">-</div>
        </div>
        <div>
            <div class="hamburger-item" data-action="show-messages">
                <span class="hamburger-icon" style="position: relative;">
                    üí¨
                    <span id="messagesBadge" class="messages-badge hidden"></span>
                </span>
                <span>Messages</span>
            </div>
            <a href="pt_editor.html" class="hamburger-item" id="ptEditorLink">
                <span class="hamburger-icon">‚úèÔ∏è</span>
                <span>Exercise Editor</span>
            </a>
            <a href="pt_view.html" class="hamburger-item">
                <span class="hamburger-icon">üìä</span>
                <span>View History</span>
            </a>
            <a href="rehab_coverage.html" class="hamburger-item">
                <span class="hamburger-icon">üìà</span>
                <span>Coverage Analysis</span>
            </a>
            <div class="hamburger-item" data-action="manual-sync">
                <span class="hamburger-icon">üîÑ</span>
                <span>Sync Now</span>
            </div>
            <div class="hamburger-item" data-action="show-debug">
                <span class="hamburger-icon">üêõ</span>
                <span>Show Debug Info</span>
            </div>
            <div class="hamburger-item" data-action="reload">
                <span class="hamburger-icon">üîÑ</span>
                <span>Reload</span>
            </div>
            <div class="hamburger-item" data-action="sign-out">
                <span class="hamburger-icon">üö™</span>
                <span>Sign Out</span>
            </div>
        </div>
    </div>

    <!-- Navigation Tabs -->
    <div class="nav-tabs">
        <button class="nav-tab active" data-action="show-view" data-view="picker">Exercises</button>
        <button class="nav-tab" data-action="show-view" data-view="history">History</button>
    </div>

    <!-- Exercise Picker View -->
    <div id="pickerView" class="view active">
        <div class="search-container">
            <input
                type="text"
                id="searchInput"
                class="search-input"
                placeholder="Search exercises..."
            >
        </div>
        <div id="exerciseList">
            <div class="loading">Loading exercises...</div>
        </div>
    </div>

    <!-- Exercise Details Modal -->
    <div class="modal hidden" id="exercise-details-modal" data-action="closeExerciseDetailsModal" data-require-self="true">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="exercise-details-title">Exercise Details</h2>
                <button class="close-btn" data-action="closeExerciseDetailsModal">&times;</button>
            </div>
            <div id="exercise-details-content"></div>
        </div>
    </div>

    <!-- Logger View -->
    <div id="loggerView" class="view">
        <div class="logger-header">
            <div class="logger-exercise-name" id="loggerExerciseName"></div>
            <div class="logger-dosage" id="loggerDosage"></div>
        </div>

        <div class="side-tracking">
            <div class="side-tracking-label" id="sideTrackingLabel">Working right side</div>
            <div class="side-buttons">
                <button class="side-btn" data-action="select-side" data-side="left">üëà Left</button>
                <button class="side-btn active" data-action="select-side" data-side="right">üëâ Right</button>
            </div>
        </div>

        <!-- Counter Mode (for reps) -->
        <div id="counterMode" class="counter-container">
            <div class="counter-label" id="counterLabel">Reps</div>
            <!-- Big tappable circle - tap to increment reps -->
            <div class="counter-display" id="counterDisplay" data-action="counter-tap">0</div>
            <div class="counter-controls">
                <button class="counter-btn counter-btn-minus" data-action="counter-decrease">‚àí Undo</button>
            </div>
        </div>

        <!-- Timer Mode (for hold/duration exercises) -->
        <div id="timerMode" class="timer-container hidden">
            <div class="timer-info" id="timerRepInfo">Rep 1 of 10</div>
            <div class="timer-display" id="timerDisplay">00:00</div>
            <div class="timer-target" id="timerTarget">Target: 10 seconds</div>
            <div class="timer-controls">
                <button class="timer-btn timer-btn-start" data-action="timer-start-pause" id="timerStartBtn">Start</button>
                <button class="timer-btn timer-btn-reset" data-action="timer-reset">Reset</button>
            </div>
        </div>

        <div class="set-info">
            <!-- Non-sided progress -->
            <div id="setsProgressBoth" class="set-info-row">
                <span>Sets:</span>
                <span id="setsProgressBothText">0/0</span>
            </div>
            <!-- Sided progress (hidden for non-sided exercises) -->
            <div id="setsProgressSided" class="hidden">
                <div class="set-info-row">
                    <span>üëà Left:</span>
                    <span id="setsProgressLeft">0/0</span>
                </div>
                <div class="set-info-row">
                    <span>üëâ Right:</span>
                    <span id="setsProgressRight">0/0</span>
                </div>
            </div>
            <!-- Target info -->
            <div class="set-info-row" style="margin-top: 4px; font-size: 0.85rem; color: #888;">
                <span>Target:</span>
                <span id="targetDoseDisplay">--</span>
            </div>
        </div>

        <!-- Control Buttons (always visible) -->
        <div class="control-buttons">
            <button class="control-btn control-btn-secondary" data-action="previous-set">Previous</button>
            <button class="control-btn control-btn-primary" data-action="show-log-set-modal">Log Set</button>
            <button class="control-btn control-btn-success" data-action="show-next-set-modal">Next Set</button>
        </div>

        <button class="finish-session-btn" data-action="finish-session" style="margin-top: 1rem;">Done</button>
        <button class="pocket-mode-btn" data-action="toggle-pocket-mode">Pocket Mode</button>
        <button class="btn btn-secondary" style="width: 100%; margin-top: 0.5rem;" data-action="back-to-picker">‚Üê Back to Exercises</button>
    </div>

    <!-- History View -->
    <div id="historyView" class="view">
        <div id="historyList">
            <div class="loading">Loading history...</div>
        </div>
    </div>

    <!-- Log Set Modal (for manual entry/review) -->
    <div id="logSetModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Log Set</h2>
                <button class="close-btn" data-action="close-log-set-modal">&times;</button>
            </div>
            <div class="form-group">
                <label id="logSetInputLabel" for="logSetInput">Reps performed</label>
                <input type="number" id="logSetInput" min="0" step="1" class="modal-input">
            </div>
            <!-- Hold time input (shown for hold_seconds exercises) -->
            <div id="logSetTimeContainer" class="form-group hidden">
                <label id="logSetTimeLabel" for="logSetTimeInput">Seconds per rep</label>
                <input type="number" id="logSetTimeInput" min="0" step="1" class="modal-input">
            </div>
            <!-- Form Parameters (weight, band resistance, etc.) -->
            <div id="formParamsContainer" class="hidden" style="background: rgba(0,122,255,0.05); padding: 12px; border-radius: 8px; margin: 12px 0;">
                <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px; color: #333;">Form Parameters:</div>
                <div id="formParamsFields"></div>
            </div>
            <!-- Side selector for Log Set modal -->
            <div id="logSetSideContainer" class="hidden" style="margin: 12px 0;">
                <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px; text-align: center;">üìç SELECT SIDE FOR THIS SET:</div>
                <div style="display: flex; gap: 12px;">
                    <div class="side-select-btn" data-action="log-set-select-side" data-side="left" style="flex: 1; padding: 12px; border-radius: 8px; border: 2px solid #555; background: #2a2a2a; text-align: center; cursor: pointer;">
                        <div style="font-size: 20px;">üëà</div>
                        <div style="font-weight: 600;">LEFT</div>
                        <div id="logSetLeftProgress" style="font-size: 12px; color: #888;">0/0 sets</div>
                    </div>
                    <div class="side-select-btn" data-action="log-set-select-side" data-side="right" style="flex: 1; padding: 12px; border-radius: 8px; border: 2px solid #007AFF; background: #007AFF; text-align: center; cursor: pointer;">
                        <div style="font-size: 20px;">üëâ</div>
                        <div style="font-weight: 600;">RIGHT</div>
                        <div id="logSetRightProgress" style="font-size: 12px; color: rgba(255,255,255,0.8);">0/0 sets</div>
                    </div>
                </div>
            </div>
            <div class="form-actions">
                <button type="button" class="btn btn-secondary" data-action="close-log-set-modal">Cancel</button>
                <button type="button" class="btn" data-action="save-logged-set">Save Set</button>
            </div>
        </div>
    </div>

    <!-- Next Set Modal (confirmation before logging) -->
    <div id="nextSetModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Next Set</h2>
                <button class="close-btn" data-action="close-next-set-modal">&times;</button>
            </div>
            <div style="margin-bottom: 16px;">
                <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Logging:</div>
                <div id="nextSetSummary" style="font-size: 15px; color: #888;"></div>
            </div>
            <!-- Form parameters display -->
            <div id="nextSetParamsContainer" class="hidden" style="background: rgba(0,122,255,0.05); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px;">Parameters:</div>
                <div id="nextSetParamsFields"></div>
            </div>
            <!-- Side display for sided exercises -->
            <div id="nextSetSideDisplay" class="hidden" style="margin-bottom: 16px; font-size: 14px; color: #888;"></div>
            <div class="form-actions" style="display: flex; gap: 8px;">
                <button type="button" class="btn btn-secondary" style="flex: 1;" data-action="close-next-set-modal">Cancel</button>
                <button type="button" class="btn" style="flex: 1; background: #007AFF;" data-action="edit-next-set">Edit</button>
                <button type="button" class="btn" style="flex: 1; background: #34C759;" data-action="confirm-next-set">Log & Next</button>
            </div>
        </div>
    </div>

    <!-- Session Notes Modal -->
    <div id="notesModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Notes (Optional)</h2>
                <button class="close-btn" data-action="close-notes-modal">&times;</button>
            </div>
            <form id="notesForm">
                <div class="form-group">
                    <textarea id="sessionNotes" placeholder="How did it feel? Any pain? Progress notes..."></textarea>
                </div>
                <!-- Backdate button + datetime picker -->
                <div style="margin-bottom: 16px;">
                    <button type="button" class="btn btn-secondary" data-action="toggle-backdate" style="width: 100%; font-size: 0.9rem; padding: 10px;">
                        Change Date/Time
                    </button>
                    <div id="backdateContainer" class="hidden" style="margin-top: 10px;">
                        <input type="datetime-local" id="backdateInput" style="width: 100%; padding: 10px; border: 1px solid #555; border-radius: 6px; font-size: 1rem;">
                        <div id="backdateWarning" class="hidden" style="margin-top: 8px; padding: 10px; background: rgba(255,165,0,0.15); border-radius: 6px; font-size: 0.85rem; color: #e8a020;">
                            Date/time changed from now. Session will be logged at the selected time.
                        </div>
                    </div>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" data-action="cancel-session">Cancel</button>
                    <button type="submit" class="btn">Save & Finish</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Messages Modal -->
    <div id="messagesModal" class="modal hidden">
        <div class="modal-content" style="max-height: 80vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <h2>Messages</h2>
                <button class="close-btn" data-action="close-messages-modal">&times;</button>
            </div>
            <div id="messagesList" style="flex: 1; overflow-y: auto; padding: 1rem 0; min-height: 200px;">
                <!-- Messages loaded here -->
            </div>
            <div style="border-top: 1px solid #ddd; padding-top: 1rem;">
                <textarea id="newMessageText" placeholder="Write a message to your PT..." style="width: 100%; min-height: 80px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-family: inherit; font-size: 16px; resize: vertical; margin-bottom: 12px;"></textarea>
                <div id="notifyToggleRow" style="display:flex; align-items:center; gap:8px; margin:0 0 12px; font-size:15px; color:#555;">
                    <input type="checkbox" id="emailNotifyToggle" data-action="toggle-email-notify" style="cursor:pointer; width:18px; height:18px; flex-shrink:0;">
                    <label for="emailNotifyToggle" style="cursor:pointer;">Notify me by email when I receive messages</label>
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" data-action="close-messages-modal">Cancel</button>
                    <button type="button" class="btn" data-action="send-message">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Session Modal -->
    <div id="editSessionModal" class="modal hidden">
        <div class="modal-content" style="max-height: 85vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <h2>Edit Session</h2>
                <button class="close-btn" data-action="close-edit-session-modal">&times;</button>
            </div>
            <div style="flex: 1; overflow-y: auto; padding: 0 0 1rem 0;">
                <!-- Exercise info -->
                <div id="editSessionExerciseInfo" style="background: rgba(0,122,255,0.1); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    <div id="editSessionExerciseName" style="font-weight: 600; font-size: 1.1rem;"></div>
                    <div id="editSessionExerciseType" style="font-size: 0.85rem; color: #888; margin-top: 4px;"></div>
                </div>

                <!-- Date -->
                <div class="form-group" style="margin-bottom: 16px;">
                    <label style="font-weight: 600; display: block; margin-bottom: 6px;">Date & Time</label>
                    <input type="datetime-local" id="editSessionDate" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 1rem;">
                </div>

                <!-- Sets -->
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Sets</div>
                    <div id="editSessionSetsList"></div>
                    <button type="button" class="btn btn-secondary" style="margin-top: 8px; font-size: 0.9rem; padding: 8px 16px;" data-action="add-edit-session-set">+ Add Set</button>
                </div>

                <!-- Notes -->
                <div class="form-group" style="margin-bottom: 16px;">
                    <label style="font-weight: 600; display: block; margin-bottom: 6px;">Notes</label>
                    <textarea id="editSessionNotes" placeholder="Session notes..." style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-family: inherit; resize: vertical;"></textarea>
                </div>

                <!-- Delete Session Button -->
                <button type="button" class="btn" style="width: 100%; background: #dc3545; padding: 14px; font-size: 1rem; margin-top: 8px;" data-action="delete-session">üóëÔ∏è Delete Session</button>
            </div>

            <div style="border-top: 1px solid #ddd; padding-top: 1rem;">
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" data-action="close-edit-session-modal">Cancel</button>
                    <button type="button" class="btn" data-action="save-edit-session">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Visual Feedback -->
    <div id="logFeedback" class="log-feedback">‚úì</div>

    <!-- Toast Container -->
    <div id="toastContainer"></div>

    <!-- Supabase Client -->
    <script src="/js/vendor/supabase.min.js"></script>

    <!-- Offline Manager - IndexedDB Cache -->
    <script type="module">
        import { offlineManager } from '/js/offline.js';
        window.offlineManager = offlineManager;
    </script>

    <script>
        // Supabase initialization
        let supabaseClient = null;

        // State
        let currentUser = null;
        let authToken = null;
        let refreshToken = null;
        let currentUserProfileId = null;
        let therapistId = null; // Patient's assigned therapist for messaging
        let viewingPatientId = null; // Patient whose data we're viewing (for therapists)
        let currentEmailNotifyEnabled = true; // Mirrors users.email_notifications_enabled for toggle UI
        let allExercises = [];
        let allHistory = []; // All activity logs for smart dropdowns
        let currentExercise = null;
        let currentSession = null;
        let offlineQueue = [];
        let currentSide = 'right'; // Default side: right
        const CUSTOM_PARAM_VALUE = '__custom__'; // Special value for "Other" option
        let isOnline = navigator.onLine; // Track online status
        let lastSyncTime = null; // Last successful sync timestamp

        async function loadSupabaseConfig() {
            const response = await fetch('/api/env');

            if (!response.ok) {
                throw new Error('Failed to load Supabase configuration.');
            }

            return response.json();
        }

        // Initialize app
        async function init() {
            const { supabaseUrl, supabaseAnonKey } = await loadSupabaseConfig();
            supabaseClient = window.supabase.createClient(supabaseUrl, supabaseAnonKey);

            // Initialize offline manager (IndexedDB cache)
            await initOfflineManager();

            // Set up online/offline listeners for auto-sync
            setupConnectivityListeners();

            // Check auth state
            const { data: { session } } = await supabaseClient.auth.getSession();

            if (session) {
                currentUser = session.user;
                authToken = session.access_token;
                refreshToken = session.refresh_token;
                document.getElementById('userEmail').textContent = currentUser?.email || '-';
                hideAuthModal();
                updateEditorLink();
                await loadData();
                checkForNewMessages();
                // Poll for new messages every 30 seconds
                setInterval(checkForNewMessages, 30000);
            } else {
                showAuthModal();
                updateEditorLink();
            }

            // Auth state listener
            supabaseClient.auth.onAuthStateChange(async (event, session) => {
                if (event === 'PASSWORD_RECOVERY') {
                    // User clicked password reset link - show new password form
                    hideAuthModal();
                    hideForgotPasswordModal();
                    showNewPasswordModal();
                } else if (event === 'SIGNED_IN') {
                    currentUser = session.user;
                    authToken = session.access_token;
                    refreshToken = session.refresh_token;
                    hideAuthModal();
                    hideNewPasswordModal();
                    updateEditorLink();
                    await loadData();
                    checkForNewMessages();
                } else if (event === 'SIGNED_OUT') {
                    currentUser = null;
                    authToken = null;
                    refreshToken = null;
                    currentUserProfileId = null;
                    therapistId = null;
                    showAuthModal();
                    updateEditorLink();
                }
            });

            // Load offline queue from localStorage
            loadOfflineQueue();
            updateSyncBadge();

            // Bind event handlers
            bindEventHandlers();
            updateEditorLink();
        }

        /**
         * Initialize the OfflineManager (IndexedDB cache).
         * Wait briefly for module to load, then init the database.
         */
        async function initOfflineManager() {
            // Wait for module to load (it's loaded async via type="module")
            let attempts = 0;
            while (!window.offlineManager && attempts < 20) {
                await new Promise(r => setTimeout(r, 50));
                attempts++;
            }

            if (window.offlineManager) {
                try {
                    await window.offlineManager.init();
                    console.log('OfflineManager initialized');
                    updateSyncStatusUI();
                } catch (error) {
                    console.warn('Failed to initialize OfflineManager:', error);
                }
            } else {
                console.warn('OfflineManager module not available');
            }
        }

        /**
         * Set up online/offline event listeners for auto-sync.
         * When coming back online, automatically sync pending queue and refresh cache.
         */
        function setupConnectivityListeners() {
            window.addEventListener('online', async () => {
                isOnline = true;
                updateSyncStatusUI();

                // Auto-sync when coming back online
                if (authToken && viewingPatientId) {
                    // First sync any pending offline queue items
                    if (offlineQueue.length > 0) {
                        showToast('Syncing...', '', 2000);
                        try {
                            await syncOfflineQueue();
                        } catch (error) {
                            // Sync failed, will retry later
                        }
                    }

                    // Only refresh UI if user is on the main picker view
                    // Don't interrupt active exercise logging or history browsing
                    const isOnPickerView = document.getElementById('pickerView')?.classList.contains('active');
                    if (isOnPickerView) {
                        // Reload fresh data and re-render
                        await loadData();
                    } else {
                        // Just hydrate cache silently for next time
                        await hydrateOfflineCache();
                    }
                }
            });

            window.addEventListener('offline', () => {
                isOnline = false;
                updateSyncStatusUI();
                showToast('Offline - changes will sync later', '', 3000);
            });
        }

        /**
         * Hydrate IndexedDB cache from server APIs.
         * Called after login and when coming back online.
         */
        async function hydrateOfflineCache() {
            if (!window.offlineManager || !authToken || !viewingPatientId) return;

            try {
                const result = await window.offlineManager.hydrateCache(authToken, viewingPatientId);
                if (result.success) {
                    lastSyncTime = new Date().toISOString();
                    updateSyncStatusUI();
                    console.log('Offline cache hydrated successfully');
                }
            } catch (error) {
                console.warn('Failed to hydrate offline cache:', error);
            }
        }

        /**
         * Update the sync status UI elements:
         * - Connectivity indicator (wifi icon with slash when offline)
         * - Sync badge (shows unsynced count)
         */
        function updateSyncStatusUI() {
            // Update connectivity indicator
            const indicator = document.getElementById('connectivityIndicator');
            if (indicator) {
                if (isOnline) {
                    indicator.classList.remove('offline');
                    indicator.title = 'Online';
                } else {
                    indicator.classList.add('offline');
                    indicator.title = 'Offline';
                }
            }

            // Update sync badge
            const badge = document.getElementById('syncBadge');
            if (!badge) return;

            if (offlineQueue.length > 0) {
                badge.textContent = `${offlineQueue.length} unsynced`;
                badge.classList.remove('hidden');
                badge.style.background = '#dc3545'; // Red for pending items
            } else {
                badge.classList.add('hidden');
            }
        }

        // Auth functions
        function showAuthModal() {
            document.getElementById('authModal').classList.remove('hidden');
        }

        function hideAuthModal() {
            document.getElementById('authModal').classList.add('hidden');
        }

        function showForgotPasswordModal() {
            document.getElementById('authModal').classList.add('hidden');
            document.getElementById('forgotPasswordModal').classList.remove('hidden');
        }

        function hideForgotPasswordModal() {
            document.getElementById('forgotPasswordModal').classList.add('hidden');
        }

        function showNewPasswordModal() {
            document.getElementById('newPasswordModal').classList.remove('hidden');
        }

        function hideNewPasswordModal() {
            document.getElementById('newPasswordModal').classList.add('hidden');
        }

        async function requestPasswordReset(email) {
            const { error } = await supabaseClient.auth.resetPasswordForEmail(email, {
                redirectTo: window.location.origin + '/reset-password.html'
            });
            return { error };
        }

        async function updatePassword(newPassword) {
            const { error } = await supabaseClient.auth.updateUser({ password: newPassword });
            return { error };
        }

        async function signIn(email, password) {
            const { data, error } = await supabaseClient.auth.signInWithPassword({
                email,
                password
            });

            if (error) {
                throw error;
            }

            return data;
        }

        function updateEditorLink() {
            const editorLink = document.getElementById('ptEditorLink');
            if (!editorLink) return;

            const params = new URLSearchParams();
            if (authToken && refreshToken) {
                params.set('access_token', authToken);
                params.set('refresh_token', refreshToken);
                try {
                    localStorage.setItem('pt_editor_auth', JSON.stringify({
                        access_token: authToken,
                        refresh_token: refreshToken
                    }));
                } catch (error) {
                    // Ignore storage errors
                }
            } else {
                try {
                    localStorage.removeItem('pt_editor_auth');
                } catch (error) {
                    // Ignore storage errors
                }
            }

            const query = params.toString();
            editorLink.href = query ? `pt_editor.html?${query}` : 'pt_editor.html';
        }

        // Data loading
        async function loadData() {
            try {
                document.getElementById('exerciseList').innerHTML = '<div class="loading">Loading exercises...</div>';

                // Get current user profile and determine which patient to view
                viewingPatientId = null; // Reset global
                try {
                    const usersResult = await fetchWithAuth('/api/users');
                    const users = usersResult.users || [];
                    // Match by auth_id (Supabase auth user ID) or email
                    const me = users.find(u => u.auth_id === currentUser.id || u.email === currentUser.email);
                    currentUserProfileId = me?.id ?? null;

                    if (!me) {
                        console.warn('Could not find current user in users list');
                        throw new Error('User not found');
                    }

                    // Sync email notification toggle state from user profile
                    currentEmailNotifyEnabled = me.email_notifications_enabled !== false;
                    const notifyToggle = document.getElementById('emailNotifyToggle');
                    if (notifyToggle) notifyToggle.checked = currentEmailNotifyEnabled;

                    // Helper to get display name
                    const getDisplayName = (user) => {
                        if (user.first_name || user.last_name) {
                            return [user.first_name, user.last_name].filter(Boolean).join(' ');
                        }
                        return user.email?.split('@')[0] || 'Unknown';
                    };

                    // Determine which patient's data to view based on role
                    let viewingPatient = null;

                    if (me.role === 'patient') {
                        // Patient viewing own data
                        viewingPatient = me;
                        if (me.therapist_id) {
                            therapistId = me.therapist_id;
                        }
                    } else if (me.role === 'therapist') {
                        // Therapist viewing their patient's data
                        const patients = users.filter(u => u.therapist_id === me.id);
                        if (patients.length > 0) {
                            viewingPatient = patients[0];
                            therapistId = me.id;
                        } else {
                            throw new Error('No patients assigned to this therapist');
                        }
                    } else if (me.role === 'admin') {
                        // Admin viewing - if admin has therapist_id, they're also a patient
                        if (me.therapist_id) {
                            viewingPatient = me;
                            therapistId = me.therapist_id;
                        } else {
                            // Pure admin - find any patient
                            const patients = users.filter(u => u.therapist_id);
                            if (patients.length > 0) {
                                viewingPatient = patients[0];
                            }
                        }
                    }

                    if (viewingPatient) {
                        viewingPatientId = viewingPatient.id;

                        // Show patient banner for therapists viewing patient data
                        if (me.role === 'therapist') {
                            const banner = document.getElementById('patientBanner');
                            const nameEl = document.getElementById('patientName');
                            if (banner && nameEl) {
                                nameEl.textContent = getDisplayName(viewingPatient);
                                banner.classList.remove('hidden');
                            }
                        }
                    }

                    console.log('User role:', me.role, '| Viewing patient:', viewingPatientId);
                } catch (e) {
                    console.warn('Could not resolve user profile:', e);
                    throw e;
                }

                if (!viewingPatientId) {
                    throw new Error('Could not determine patient ID');
                }

                // OFFLINE-ONLY CACHE: Only use IndexedDB cache when offline
                // When online, always fetch fresh data (cache is just for offline resilience)
                if (!navigator.onLine && window.offlineManager) {
                    try {
                        const cachedPrograms = await window.offlineManager.getCachedPrograms(viewingPatientId);
                        if (cachedPrograms && cachedPrograms.length > 0) {
                            allExercises = transformProgramsToExercises(cachedPrograms);
                            const cachedLogs = await window.offlineManager.getCachedLogs(viewingPatientId);
                            allHistory = cachedLogs || [];
                            renderExerciseList(allExercises);
                            renderHistory(allHistory);
                            showToast('Offline mode', '', 2000);
                            loadOfflineQueue();
                            updateSyncBadge();
                            return;
                        }
                    } catch (cacheError) {
                        // Cache read failed
                    }
                    throw new Error('Offline and no cached data available');
                }
                const result = await fetchWithAuth(`/api/programs?patient_id=${viewingPatientId}`);
                const programs = result.programs || [];

                // Transform programs into exercise format with dosage data
                allExercises = programs.map(program => {
                    const exercise = program.exercises || {};
                    return {
                        // Exercise library fields
                        id: exercise.id,
                        canonical_name: exercise.canonical_name,
                        description: exercise.description,
                        pt_category: exercise.pt_category,
                        pattern: exercise.pattern,
                        pattern_modifiers: exercise.pattern_modifiers,
                        archived: exercise.archived,

                        // Patient dosage fields from patient_programs
                        current_sets: program.current_sets ?? program.sets,
                        current_reps: program.current_reps ?? program.reps_per_set,
                        seconds_per_rep: program.seconds_per_rep,
                        seconds_per_set: program.seconds_per_set,
                        dosage_type: program.dosage_type,
                        distance_feet: program.distance_feet,
                        side: program.side,

                        // Full nested data for reference
                        equipment: exercise.equipment,
                        primary_muscles: exercise.primary_muscles,
                        secondary_muscles: exercise.secondary_muscles,
                        form_parameters_required: exercise.form_parameters_required,
                        guidance: exercise.guidance,
                        roles: exercise.roles
                    };
                });

                // Load history FIRST so adherence data is available when rendering
                await loadHistory();
                renderExerciseList(allExercises);

                // Hydrate offline cache in background (fire-and-forget)
                hydrateOfflineCache();

            } catch (error) {
                // API failed - try IndexedDB cache as fallback
                if (window.offlineManager) {
                    try {
                        const cachedPrograms = await window.offlineManager.getCachedPrograms(viewingPatientId);
                        if (cachedPrograms && cachedPrograms.length > 0) {
                            allExercises = transformProgramsToExercises(cachedPrograms);
                            const cachedLogs = await window.offlineManager.getCachedLogs(viewingPatientId);
                            allHistory = cachedLogs || [];
                            renderExerciseList(allExercises);
                            renderHistory(allHistory);
                            showToast('Using cached data', '', 3000);
                            loadOfflineQueue();
                            updateSyncBadge();
                            return;
                        }
                    } catch (cacheError) {
                        // Cache also failed
                    }
                }

                document.getElementById('exerciseList').innerHTML =
                    '<div class="empty-state">Failed to load exercises. Check your connection.</div>';
            }
        }

        /**
         * Transform program data from API/cache into exercise format.
         * Used by both online and offline loading paths.
         */
        function transformProgramsToExercises(programs) {
            return programs.map(program => {
                const exercise = program.exercises || {};
                return {
                    // Exercise library fields
                    id: exercise.id,
                    canonical_name: exercise.canonical_name,
                    description: exercise.description,
                    pt_category: exercise.pt_category,
                    pattern: exercise.pattern,
                    pattern_modifiers: exercise.pattern_modifiers,
                    archived: exercise.archived,

                    // Patient dosage fields from patient_programs
                    current_sets: program.current_sets ?? program.sets,
                    current_reps: program.current_reps ?? program.reps_per_set,
                    seconds_per_rep: program.seconds_per_rep,
                    seconds_per_set: program.seconds_per_set,
                    dosage_type: program.dosage_type,
                    distance_feet: program.distance_feet,
                    side: program.side,

                    // Full nested data for reference
                    equipment: exercise.equipment,
                    primary_muscles: exercise.primary_muscles,
                    secondary_muscles: exercise.secondary_muscles,
                    form_parameters_required: exercise.form_parameters_required,
                    guidance: exercise.guidance,
                    roles: exercise.roles
                };
            });
        }

        async function loadHistory() {
            try {
                // Use viewingPatientId if set (for therapists viewing patient data)
                const patientParam = viewingPatientId ? `&patient_id=${viewingPatientId}` : '';
                const result = await fetchWithAuth(`/api/logs?include_all=true&limit=1000${patientParam}`);
                const logs = result.logs || [];
                allHistory = logs; // Store for form parameter dropdowns
                renderHistory(logs);
            } catch (error) {
                console.error('Failed to load history:', error);
                allHistory = [];
                document.getElementById('historyList').innerHTML =
                    '<div class="empty-state">Failed to load history.</div>';
            }
        }

        async function fetchWithAuth(url, options = {}) {
            const headers = {
                'Content-Type': 'application/json',
                ...options.headers
            };

            if (authToken) {
                headers['Authorization'] = `Bearer ${authToken}`;
            }

            const response = await fetch(url, {
                ...options,
                headers
            });

            if (!response.ok) {
                // Read once to avoid "Body is disturbed or locked" errors.
                const responseText = await response.text();
                let errorDetail = responseText;

                if (responseText) {
                    try {
                        const errorBody = JSON.parse(responseText);
                        errorDetail = errorBody.error || errorBody.message || JSON.stringify(errorBody);
                    } catch (e) {
                        // Keep raw response text for non-JSON errors.
                    }
                }

                throw new Error(`API error ${response.status}: ${errorDetail || response.statusText}`);
            }

            return response.json();
        }

        /**
         * Format dosage display string based on exercise type and pattern modifiers.
         * Examples: "3 √ó 10 reps", "3 √ó 30 sec", "20 feet", "3 √ó 10 sec hold"
         */
        function formatDosage(exercise) {
            const sets = exercise.current_sets || 0;
            const reps = exercise.current_reps || 0;
            const holdSeconds = exercise.seconds_per_rep || 0;
            const durationSeconds = exercise.seconds_per_set || 0;
            const distance = exercise.distance_feet || 0;
            const dosageType = exercise.dosage_type;

            const hasDuration = exercise.pattern_modifiers?.includes('duration_seconds') || dosageType === 'duration';
            const hasHold = exercise.pattern_modifiers?.includes('hold_seconds') || dosageType === 'hold';
            const hasDistance = exercise.pattern_modifiers?.includes('distance_feet') || dosageType === 'distance';

            if (hasDistance && distance > 0) {
                return `${distance} feet`;
            } else if (hasDuration && durationSeconds > 0) {
                return `${sets} √ó ${durationSeconds} sec`;
            } else if (hasHold && holdSeconds > 0 && reps > 0) {
                return `${sets} √ó ${reps} reps (${holdSeconds} sec hold)`;
            } else if (reps > 0) {
                return `${sets} √ó ${reps} reps`;
            } else {
                return exercise.pt_category || '';
            }
        }

        /**
         * Calculate days between two dates (local timezone).
         */
        function getDaysDiff(date1, date2) {
            const d1 = new Date(date1);
            const d2 = new Date(date2);
            d1.setHours(0, 0, 0, 0);
            d2.setHours(0, 0, 0, 0);
            const diffTime = Math.abs(d1 - d2);
            return Math.floor(diffTime / (1000 * 60 * 60 * 24));
        }

        /**
         * Get adherence info for an exercise from history.
         * Returns { daysSince, totalSessions, colorClass, icon }
         */
        function getAdherenceInfo(exerciseId, exerciseName) {
            const logs = allHistory.filter(log =>
                log.exercise_id === exerciseId || log.exercise_name === exerciseName
            );

            const totalSessions = logs.length;

            if (totalSessions === 0) {
                return { daysSince: null, totalSessions: 0, colorClass: 'gray', icon: '‚óã', text: 'Never done' };
            }

            // Find most recent log
            const sortedLogs = logs.sort((a, b) => new Date(b.performed_at) - new Date(a.performed_at));
            const lastLog = sortedLogs[0];
            const daysSince = getDaysDiff(new Date(), new Date(lastLog.performed_at));

            let colorClass, icon, text;
            if (daysSince === 0) {
                colorClass = 'green';
                icon = '‚úì';
                text = 'Done today';
            } else if (daysSince <= 3) {
                colorClass = 'green';
                icon = '';
                text = `${daysSince} day${daysSince > 1 ? 's' : ''} ago`;
            } else if (daysSince <= 7) {
                colorClass = 'orange';
                icon = '‚ö†Ô∏è ';
                text = `${daysSince} days ago`;
            } else {
                colorClass = 'red';
                icon = '‚ùó ';
                text = `${daysSince} days ago`;
            }

            return { daysSince, totalSessions, colorClass, icon, text };
        }

        // Render functions
        function renderExerciseList(exercises) {
            const listEl = document.getElementById('exerciseList');

            if (exercises.length === 0) {
                listEl.innerHTML = '<div class="empty-state">No exercises found.</div>';
                return;
            }

            const html = exercises
                .filter(ex => !ex.archived)
                .map(ex => {
                    const adherence = getAdherenceInfo(ex.id, ex.canonical_name);
                    const adherenceHtml = `<div class="exercise-adherence ${adherence.colorClass}">${adherence.icon}${adherence.text}${adherence.totalSessions > 0 ? ` ¬∑ ${adherence.totalSessions} session${adherence.totalSessions > 1 ? 's' : ''} total` : ''}</div>`;

                    // Category tag
                    const tagHtml = ex.pt_category ? `<div class="exercise-tags"><span class="exercise-tag">${escapeHtml(ex.pt_category)}</span></div>` : '';

                    return `
                        <div class="exercise-card" data-action="select-exercise" data-id="${ex.id}">
                            <button class="details-btn" data-action="showExerciseDetails" data-id="${ex.id}" data-stop-propagation="true">‚ÑπÔ∏è</button>
                            <div class="exercise-name">${escapeHtml(ex.canonical_name)}</div>
                            <div class="exercise-dosage">${escapeHtml(formatDosage(ex))}</div>
                            ${adherenceHtml}
                            ${tagHtml}
                        </div>
                    `;
                }).join('');

            listEl.innerHTML = html || '<div class="empty-state">No active exercises.</div>';
        }

        function renderHistory(logs) {
            const listEl = document.getElementById('historyList');

            if (logs.length === 0) {
                listEl.innerHTML = '<div class="empty-state">No history yet. Start logging exercises!</div>';
                return;
            }

            const html = logs.map(log => {
                const date = new Date(log.performed_at);
                const dateStr = formatDateTimeWithZone(date, {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit'
                });
                const setsCount = log.sets ? log.sets.length : 0;

                // Build sets summary with reps/seconds/distance and side
                // Format: "10r √ó 5s (L)" for hold, "30s" for duration, "10r (R)" for sided reps
                const setsSummary = log.sets ? log.sets.map(s => {
                    let parts = [];
                    if (s.reps) parts.push(`${s.reps}r`);
                    if (s.seconds) parts.push(`${s.seconds}s`);
                    if (s.distance_feet) parts.push(`${s.distance_feet}ft`);
                    let summary = parts.join(' √ó ');
                    // Add side indicator for sided exercises
                    if (s.side) {
                        summary += ` (${s.side === 'left' ? 'L' : 'R'})`;
                    }
                    return summary;
                }).filter(Boolean).join(', ') : '';

                // Extract form parameters from the first set (typically same across sets)
                let formParamsHtml = '';
                if (log.sets && log.sets.length > 0 && log.sets[0].form_data && log.sets[0].form_data.length > 0) {
                    const params = log.sets[0].form_data.map(p =>
                        `${p.parameter_value}${p.parameter_unit ? ' ' + p.parameter_unit : ''}`
                    ).join(', ');
                    formParamsHtml = `<div class="session-params" style="font-size: 0.85rem; color: #888; margin-top: 2px;">${params}</div>`;
                }

                const notesInlineHtml = log.notes ? `
                    <div style="font-size: 0.85rem; color: #666; margin-top: 6px; font-style: italic;">"${escapeHtml(log.notes)}"</div>
                ` : '';

                return `
                    <div class="session-card" data-action="edit-session" data-log-id="${log.id}" style="cursor: pointer;">
                        <div class="session-date">${dateStr}</div>
                        <div class="session-exercise">${escapeHtml(log.exercise_name)}</div>
                        <div class="session-sets">${setsCount} sets: ${setsSummary}</div>
                        ${formParamsHtml}
                        ${notesInlineHtml}
                    </div>
                `;
            }).join('');

            listEl.innerHTML = html;
        }

        /**
         * Show exercise details modal with guidance, muscles, equipment info.
         * Uses data-action pattern for iOS Safari/PWA compatibility.
         */
        function showExerciseDetails(exerciseId) {
            const exercise = allExercises.find(ex => ex.id === exerciseId);
            if (!exercise) {
                showToast('Exercise not found', 'error');
                return;
            }

            document.getElementById('exercise-details-title').textContent = exercise.canonical_name;

            // Build detail HTML following pt_tracker.html pattern
            let detailHtml = '';

            // Description
            if (exercise.description) {
                detailHtml += `
                    <div class="detail-section">
                        <div class="detail-section-title">Description</div>
                        <div class="detail-section-content">${escapeHtml(exercise.description)}</div>
                    </div>
                `;
            }

            // Pattern
            if (exercise.pattern) {
                const isSided = exercise.pattern === 'side';
                const patternText = isSided ? '‚ÜîÔ∏è Sided Exercise (work left and right separately)' : '‚¨õ Bilateral Exercise (both sides together)';
                const patternColor = isSided ? '#FF9500' : '#007AFF';
                detailHtml += `
                    <div class="detail-section">
                        <div class="detail-section-title">Pattern</div>
                        <div class="detail-pills">
                            <span class="pill" style="background: ${patternColor}; color: white;">${patternText}</span>
                        </div>
                    </div>
                `;
            }

            // Primary Muscles
            if (exercise.primary_muscles && exercise.primary_muscles.length > 0) {
                detailHtml += `
                    <div class="detail-section">
                        <div class="detail-section-title">Primary Muscles</div>
                        <div class="detail-pills">
                            ${exercise.primary_muscles.map(m => `<span class="pill" style="background: rgba(0,122,255,0.1); color: #007AFF;">${escapeHtml(m)}</span>`).join('')}
                        </div>
                    </div>
                `;
            }

            // Secondary Muscles
            if (exercise.secondary_muscles && exercise.secondary_muscles.length > 0) {
                detailHtml += `
                    <div class="detail-section">
                        <div class="detail-section-title">Secondary Muscles</div>
                        <div class="detail-pills">
                            ${exercise.secondary_muscles.map(m => `<span class="pill" style="background: rgba(0,122,255,0.05); color: #666;">${escapeHtml(m)}</span>`).join('')}
                        </div>
                    </div>
                `;
            }

            // Equipment Required
            if (exercise.equipment && exercise.equipment.required && exercise.equipment.required.length > 0) {
                detailHtml += `
                    <div class="detail-section">
                        <div class="detail-section-title">Equipment Required</div>
                        <div class="detail-section-content">${exercise.equipment.required.map(e => escapeHtml(e)).join(', ')}</div>
                    </div>
                `;
            }

            // Optional Equipment
            if (exercise.equipment && exercise.equipment.optional && exercise.equipment.optional.length > 0) {
                detailHtml += `
                    <div class="detail-section">
                        <div class="detail-section-title">Optional Equipment</div>
                        <div class="detail-section-content">${exercise.equipment.optional.map(e => escapeHtml(e)).join(', ')}</div>
                    </div>
                `;
            }

            // Guidance sections
            if (exercise.guidance) {
                // External Cues
                if (exercise.guidance.external_cues && exercise.guidance.external_cues.length > 0) {
                    detailHtml += `
                        <div class="detail-section">
                            <div class="detail-section-title">üëÄ External Cues</div>
                            <ul class="detail-list">
                                ${exercise.guidance.external_cues.map(cue => `<li>${escapeHtml(cue)}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                }

                // Motor Cues
                if (exercise.guidance.motor_cues && exercise.guidance.motor_cues.length > 0) {
                    detailHtml += `
                        <div class="detail-section">
                            <div class="detail-section-title">üí™ Motor Cues</div>
                            <ul class="detail-list">
                                ${exercise.guidance.motor_cues.map(cue => `<li>${escapeHtml(cue)}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                }

                // Compensation Warnings
                if (exercise.guidance.compensation_warnings && exercise.guidance.compensation_warnings.length > 0) {
                    detailHtml += `
                        <div class="detail-section">
                            <div class="detail-section-title" style="color: #FF9500;">‚ö†Ô∏è Compensation Warnings</div>
                            <ul class="detail-list">
                                ${exercise.guidance.compensation_warnings.map(w => `<li>${escapeHtml(w)}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                }

                // Safety Flags
                if (exercise.guidance.safety_flags && exercise.guidance.safety_flags.length > 0) {
                    detailHtml += `
                        <div class="detail-section">
                            <div class="detail-section-title" style="color: #FF3B30;">üõë Safety Flags</div>
                            <ul class="detail-list" style="color: #FF3B30;">
                                ${exercise.guidance.safety_flags.map(f => `<li>${escapeHtml(f)}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                }
            }

            // If no details available
            if (!detailHtml) {
                detailHtml = '<div class="detail-section-content">No additional details available for this exercise.</div>';
            }

            document.getElementById('exercise-details-content').innerHTML = detailHtml;
            document.getElementById('exercise-details-modal').classList.remove('hidden');
        }

        /**
         * Close the exercise details modal.
         */
        function closeExerciseDetailsModal() {
            document.getElementById('exercise-details-modal').classList.add('hidden');
        }

        // Exercise selection
        function selectExercise(exerciseId) {
            currentExercise = allExercises.find(ex => ex.id === exerciseId);
            if (!currentExercise) {
                showToast('Exercise not found', 'error');
                return;
            }

            // Determine activity type from pattern modifiers
            let activityType = 'reps'; // default
            if (currentExercise.pattern_modifiers && currentExercise.pattern_modifiers.length > 0) {
                if (currentExercise.pattern_modifiers.includes('distance_feet')) {
                    activityType = 'distance';
                } else if (currentExercise.pattern_modifiers.includes('hold_seconds')) {
                    activityType = 'hold';
                } else if (currentExercise.pattern_modifiers.includes('duration_seconds')) {
                    activityType = 'duration';
                }
            } else if (currentExercise.dosage_type) {
                activityType = currentExercise.dosage_type;
            }

            // Initialize new session
            currentSession = {
                sessionId: generateSessionId(),
                exerciseId: currentExercise.id,
                exerciseName: currentExercise.canonical_name,
                activityType: activityType,
                sets: [],
                date: new Date().toISOString()
            };

            // Setup logger view
            document.getElementById('loggerExerciseName').textContent = currentExercise.canonical_name;
            document.getElementById('loggerDosage').textContent = formatDosage(currentExercise);

            // Handle side tracking visibility - only show for pattern: "side"
            const sideTracking = document.querySelector('.side-tracking');
            const isSidePattern = currentExercise.pattern === 'side';

            if (isSidePattern) {
                // Show side selector and reset to default
                sideTracking.classList.remove('hidden');
                currentSide = 'right';
                selectSide('right');
                // Show sided progress, hide both progress
                document.getElementById('setsProgressBoth').classList.add('hidden');
                document.getElementById('setsProgressSided').classList.remove('hidden');
            } else {
                // Hide side selector for bilateral (both) exercises
                sideTracking.classList.add('hidden');
                currentSide = null; // No side tracking for bilateral
                // Show both progress, hide sided progress
                document.getElementById('setsProgressBoth').classList.remove('hidden');
                document.getElementById('setsProgressSided').classList.add('hidden');
            }

            // Update sets progress display
            updateSetsProgress();

            // Update target display
            updateTargetDisplay();

            // Determine which mode to show: timer mode or counter mode
            const hasTimerModifier = currentExercise.pattern_modifiers?.includes('duration_seconds') ||
                                      currentExercise.pattern_modifiers?.includes('hold_seconds') ||
                                      ['duration', 'hold'].includes(currentExercise.dosage_type);

            const counterMode = document.getElementById('counterMode');
            const timerMode = document.getElementById('timerMode');

            if (hasTimerModifier) {
                // Show timer mode for duration/hold exercises
                counterMode.classList.add('hidden');
                timerMode.classList.remove('hidden');
                initTimerMode();
            } else {
                // Show counter mode for reps exercises
                counterMode.classList.remove('hidden');
                timerMode.classList.add('hidden');
                document.getElementById('counterDisplay').textContent = '0';
            }

            showView('logger');
        }

        /**
         * Update the sets progress display based on current session data.
         */
        function updateSetsProgress() {
            if (!currentExercise || !currentSession) return;

            const isSidePattern = currentExercise.pattern === 'side';
            const targetSets = currentExercise.current_sets || 0;

            let allComplete = false;

            if (isSidePattern) {
                // Count sets per side
                const leftSets = currentSession.sets.filter(s => s.side === 'left').length;
                const rightSets = currentSession.sets.filter(s => s.side === 'right').length;
                document.getElementById('setsProgressLeft').textContent = `${leftSets}/${targetSets}`;
                document.getElementById('setsProgressRight').textContent = `${rightSets}/${targetSets}`;
                allComplete = targetSets > 0 && leftSets >= targetSets && rightSets >= targetSets;
            } else {
                // Count total sets
                const totalSets = currentSession.sets.length;
                document.getElementById('setsProgressBothText').textContent = `${totalSets}/${targetSets}`;
                allComplete = targetSets > 0 && totalSets >= targetSets;
            }

            // Announce when all sets are complete (only once per exercise)
            if (allComplete && !currentSession.allSetsAnnouncedComplete) {
                currentSession.allSetsAnnouncedComplete = true;
                setTimeout(() => speakText('All sets complete'), 500);
            }
        }

        /**
         * Update the target dose display.
         */
        function updateTargetDisplay() {
            if (!currentExercise) return;

            const reps = currentExercise.current_reps || 0;
            const holdSeconds = currentExercise.seconds_per_rep || 0;
            const durationSeconds = currentExercise.seconds_per_set || 0;
            const distance = currentExercise.distance_feet || 0;

            const hasDuration = currentExercise.pattern_modifiers?.includes('duration_seconds') || currentExercise.dosage_type === 'duration';
            const hasHold = currentExercise.pattern_modifiers?.includes('hold_seconds') || currentExercise.dosage_type === 'hold';
            const hasDistance = currentExercise.pattern_modifiers?.includes('distance_feet') || currentExercise.dosage_type === 'distance';

            let targetText;
            if (hasDistance && distance > 0) {
                targetText = `${distance} feet`;
            } else if (hasDuration && durationSeconds > 0) {
                targetText = `${durationSeconds} seconds`;
            } else if (hasHold && holdSeconds > 0 && reps > 0) {
                targetText = `${reps} reps √ó ${holdSeconds}s hold`;
            } else if (reps > 0) {
                targetText = `${reps} reps`;
            } else {
                targetText = '--';
            }

            document.getElementById('targetDoseDisplay').textContent = targetText;
        }

        /**
         * Get the last used form parameters for this exercise from history.
         */
        function getLastFormParams(exerciseId) {
            const logs = allHistory.filter(log => log.exercise_id === exerciseId);
            if (logs.length === 0) return null;

            // Sort by date descending to get most recent
            const sortedLogs = logs.sort((a, b) => new Date(b.performed_at) - new Date(a.performed_at));
            const lastLog = sortedLogs[0];

            // Get form_data from the most recent set
            if (lastLog.sets && lastLog.sets.length > 0) {
                const lastSet = lastLog.sets[lastLog.sets.length - 1];
                return lastSet.form_data || null;
            }
            return null;
        }

        // Counter functions
        function increaseCounter() {
            const display = document.getElementById('counterDisplay');
            const current = parseInt(display.textContent);
            const newValue = current + 1;
            display.textContent = newValue;

            // Soft tick on every tap ‚Äî provides eyes-free rep feedback on iOS where
            // navigator.vibrate (haptic) is not supported.
            playBeep(440, 80, 0.25);

            // Voice announcements at milestones (matching old app)
            if (currentExercise && currentExercise.current_reps) {
                const repsLeft = currentExercise.current_reps - newValue;

                if (repsLeft === 5) {
                    speakText('5 reps left');
                } else if (repsLeft === 3) {
                    speakText('3 reps left');
                } else if (repsLeft === 1) {
                    speakText('Last rep');
                } else if (repsLeft === 0) {
                    playCompletionSound();
                    speakText('Set complete');
                }
            }
        }

        function decreaseCounter() {
            const display = document.getElementById('counterDisplay');
            const current = parseInt(display.textContent);
            if (current > 0) {
                display.textContent = current - 1;
            }
        }

        /**
         * Timer state for hold/duration exercises.
         * iOS Safari requires user interaction to enable audio, so beeps and voice are initialized on first start.
         */
        let timerState = {
            intervalId: null,
            startTime: null,
            elapsedMs: 0,
            isRunning: false,
            currentRep: 1,
            targetSeconds: 10,
            totalReps: 1,
            lastAnnouncedSecond: null
        };

        /**
         * Initialize timer mode for hold or duration exercises.
         * Called when selecting an exercise with duration_seconds or hold_seconds pattern modifier.
         */
        function initTimerMode() {
            // Determine if this is hold (per-rep timer) or duration (single long timer)
            const hasHold = currentExercise.pattern_modifiers?.includes('hold_seconds')
                || currentExercise.dosage_type === 'hold';
            const hasDuration = currentExercise.pattern_modifiers?.includes('duration_seconds')
                || currentExercise.dosage_type === 'duration';

            if (hasHold) {
                // Hold = timer per rep (e.g., 10 reps √ó 10 seconds each)
                timerState.targetSeconds = currentExercise.seconds_per_rep || 10;
                timerState.totalReps = currentExercise.current_reps || 1;
                timerState.currentRep = 1;
                document.getElementById('timerRepInfo').textContent = `Rep ${timerState.currentRep} of ${timerState.totalReps}`;
            } else if (hasDuration) {
                // Duration = single long timer (e.g., 60 seconds plank)
                timerState.targetSeconds = currentExercise.seconds_per_set || currentExercise.seconds_per_rep || 60;
                timerState.totalReps = 1;
                timerState.currentRep = 1;
                document.getElementById('timerRepInfo').textContent = `Duration Exercise`;
            }

            document.getElementById('timerTarget').textContent = `Target: ${timerState.targetSeconds} seconds`;
            // Initialize display to show target time (countdown starts from target)
            document.getElementById('timerDisplay').textContent = formatTime(timerState.targetSeconds * 1000);
            timerState.elapsedMs = 0;
            timerState.isRunning = false;
            timerState.lastAnnouncedSecond = null;
            updateTimerButton();
        }

        /**
         * Format milliseconds as MM:SS display.
         */
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        /**
         * Start or pause the timer countdown.
         * Timer counts DOWN from target to 0, with beeps/voice warnings.
         */
        function toggleTimer() {
            if (timerState.isRunning) {
                pauseTimer();
            } else {
                startTimer();
            }
        }

        function startTimer() {
            if (timerState.intervalId) {
                return;
            }
            timerState.isRunning = true;
            timerState.startTime = Date.now() - timerState.elapsedMs;

            if (timerState.targetSeconds > 10) {
                speakText('Start');
            }

            timerState.intervalId = setInterval(() => {
                timerState.elapsedMs = Date.now() - timerState.startTime;
                const elapsedSeconds = Math.floor(timerState.elapsedMs / 1000);
                const remaining = timerState.targetSeconds - elapsedSeconds;
                const clampedRemaining = Math.max(0, remaining);

                // Display countdown (remaining time)
                const displayMs = clampedRemaining * 1000;
                document.getElementById('timerDisplay').textContent = formatTime(displayMs);

                // Beep and voice warnings when approaching zero
                // Countdown beeps at 3, 2, 1 (matching old app)
                if (clampedRemaining !== timerState.lastAnnouncedSecond) {
                    if (clampedRemaining <= 3 && clampedRemaining > 0) {
                        playBeep(600, 100);
                    }

                    if (clampedRemaining === 0) {
                        playCompletionSound();
                        pauseTimer(false); // Auto-pause at target, but allow user to continue

                        // Announce reps remaining for hold exercises.
                        // Must mirror initTimerMode() detection ‚Äî check both modifier and dosage_type
                        // so exercises identified via dosage_type='hold' get correct rep tracking.
                        const hasHold = currentExercise.pattern_modifiers?.includes('hold_seconds')
                            || currentExercise.dosage_type === 'hold';
                        if (hasHold) {
                            const repsLeft = timerState.totalReps - timerState.currentRep;
                            // Mirror counter milestones (5/3/1/0) ‚Äî announce only at key
                            // thresholds so hold and counter mode speech behavior is consistent.
                            if (repsLeft <= 0) {
                                speakText('Set complete');
                            } else if (repsLeft === 1) {
                                speakText('Last rep');
                            } else if (repsLeft === 3) {
                                speakText('3 reps left');
                            } else if (repsLeft === 5) {
                                speakText('5 reps left');
                            }
                            // repsLeft at 2, 4, 6, 7, 8+ ‚Üí silent (same as counter mode)

                            timerState.currentRep = Math.min(timerState.currentRep + 1, timerState.totalReps);
                            timerState.elapsedMs = 0;
                            timerState.lastAnnouncedSecond = null;
                            if (repsLeft > 0) {
                                document.getElementById('timerRepInfo').textContent = `Rep ${timerState.currentRep} of ${timerState.totalReps}`;
                            }
                            document.getElementById('timerDisplay').textContent = formatTime(timerState.targetSeconds * 1000);
                        } else {
                            // Duration exercise completed - keep elapsedMs at target time
                            // so confirmNextSet() captures the actual elapsed seconds
                            speakText('Set complete');
                            timerState.elapsedMs = timerState.targetSeconds * 1000;
                            timerState.lastAnnouncedSecond = null;
                            document.getElementById('timerDisplay').textContent = formatTime(0);
                        }
                    }

                    timerState.lastAnnouncedSecond = clampedRemaining;
                }
            }, 100); // Update every 100ms for smooth display

            updateTimerButton();
        }

        function pauseTimer(announce = true) {
            timerState.isRunning = false;
            if (timerState.intervalId) {
                clearInterval(timerState.intervalId);
                timerState.intervalId = null;
            }
            if (announce && timerState.targetSeconds > 10) {
                speakText('Pause');
            }
            updateTimerButton();
        }

        function resetTimer() {
            pauseTimer(false);
            timerState.elapsedMs = 0;
            timerState.lastAnnouncedSecond = null;
            // Reset to target time (countdown starts from target)
            document.getElementById('timerDisplay').textContent = formatTime(timerState.targetSeconds * 1000);
        }

        function updateTimerButton() {
            const btn = document.getElementById('timerStartBtn');
            btn.textContent = timerState.isRunning ? 'Pause' : 'Start';
        }

        let audioContext = null;

        function ensureAudioReady() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            } catch (error) {
                console.warn('Audio not available:', error);
                audioContext = null;
            }
        }

        /**
         * Play a simple beep sound using Web Audio API.
         * iOS Safari requires user interaction before playing audio.
         */
        function playBeep(frequency = 800, duration = 200, gain = 0.5) {
            try {
                ensureAudioReady();
                if (!audioContext) {
                    return;
                }
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = frequency;
                oscillator.type = 'square'; // More noticeable than sine

                const durationInSeconds = duration / 1000;
                gainNode.gain.setValueAtTime(gain, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + durationInSeconds);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + durationInSeconds);
            } catch (error) {
                console.warn('Audio not available:', error);
            }
        }

        /**
         * Play triple beep completion sound.
         * Three ascending beeps to indicate successful completion.
         */
        function playCompletionSound() {
            try {
                playBeep(1000, 150);  // First beep: 1000 Hz, 150ms
                setTimeout(() => playBeep(1200, 150), 200);  // Second beep: 1200 Hz after 200ms
                setTimeout(() => playBeep(1400, 200), 400);  // Third beep: 1400 Hz after 400ms
            } catch (error) {
                console.warn('Audio not available:', error);
            }
        }

        /**
         * Speak text using Web Speech API.
         * iOS Safari supports speechSynthesis but may require user interaction to initialize.
         */
        function speakText(text) {
            try {
                if ('speechSynthesis' in window) {
                    // Cancel any queued utterances before speaking ‚Äî prevents iOS speech
                    // synthesis from freezing when multiple announcements stack rapidly.
                    window.speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 1.0;
                    utterance.pitch = 1.0;
                    utterance.volume = 1.0;
                    window.speechSynthesis.speak(utterance);
                }
            } catch (error) {
                console.warn('Speech not available:', error);
            }
        }

        // ‚îÄ‚îÄ‚îÄ Pocket Mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        /** Interval ID for pocket overlay periodic refresh while active. */
        let pocketRefreshInterval = null;
        /** Timer ID for long-press detection on the pocket pad. */
        let pocketLongPressTimer = null;
        /** True while a long-press action is in flight (suppresses the tap-end as a regular tap). */
        let pocketLongPressActive = false;

        /**
         * Open or close the pocket mode overlay.
         * Pocket mode is only meaningful while an exercise session is active.
         * @param {boolean} [forceState] - true to open, false to close; if omitted, toggles current state.
         */
        function togglePocketMode(forceState) {
            const overlay = document.getElementById('pocketOverlay');
            const isActive = overlay.classList.contains('active');
            const shouldActivate = forceState !== undefined ? forceState : !isActive;

            if (shouldActivate) {
                if (!currentExercise) return; // no exercise in progress
                overlay.classList.add('active');
                updatePocketOverlay();
                setupPocketLongPress();
                // Refresh overlay every 200ms so the countdown stays in sync during timer mode
                pocketRefreshInterval = setInterval(updatePocketOverlay, 200);
            } else {
                overlay.classList.remove('active');
                cleanupPocketLongPress();
                clearInterval(pocketRefreshInterval);
                pocketRefreshInterval = null;
            }
        }

        /**
         * Return true when the exercise is currently in timer mode (hold or duration).
         * Detects mode by checking whether #timerMode is visible.
         * @returns {boolean}
         */
        function isPocketTimerMode() {
            const timerMode = document.getElementById('timerMode');
            return timerMode && !timerMode.classList.contains('hidden');
        }

        /**
         * Refresh the pocket overlay label and meta text to reflect the current exercise state.
         * - Counter mode: shows rep count + sets/reps remaining.
         * - Timer mode: mirrors the #timerDisplay countdown + rep/run-state info.
         */
        function updatePocketOverlay() {
            const labelEl = document.getElementById('pocketLabel');
            const metaEl = document.getElementById('pocketMeta');
            const hintEl = document.getElementById('pocketHint');
            if (!labelEl || !metaEl || !hintEl || !currentExercise || !currentSession) return;

            const setsCompleted = currentSession.sets.length;
            const targetSets = currentExercise.current_sets || 0;
            const setsLeft = Math.max(0, targetSets - setsCompleted);

            if (isPocketTimerMode()) {
                // Timer mode: mirror the existing #timerDisplay (updated by setInterval in startTimer)
                const timerDisplayEl = document.getElementById('timerDisplay');
                labelEl.textContent = timerDisplayEl ? timerDisplayEl.textContent : '00:00';
                const repInfo = `Rep ${timerState.currentRep} of ${timerState.totalReps}`;
                const runState = timerState.isRunning ? 'Running' : 'Paused';
                metaEl.textContent = `${repInfo} ¬∑ Sets left: ${setsLeft} ¬∑ ${runState}`;
                hintEl.textContent = timerState.isRunning
                    ? 'Tap to pause ¬∑ Hold for partial'
                    : 'Tap to start';
            } else {
                // Counter mode: show current tap count and reps remaining
                const counterDisplayEl = document.getElementById('counterDisplay');
                const currentReps = counterDisplayEl ? (parseInt(counterDisplayEl.textContent) || 0) : 0;
                const targetReps = currentExercise.current_reps || 0;
                const repsLeft = Math.max(0, targetReps - currentReps);
                labelEl.textContent = String(currentReps);
                metaEl.textContent = `Sets left: ${setsLeft} ¬∑ Reps left: ${repsLeft}`;
                hintEl.textContent = 'Tap to count';
            }
        }

        /**
         * Handle a tap on the pocket pad.
         * Counter mode: calls increaseCounter().
         * Timer mode: toggles the timer (start/pause).
         * Ignored when a long-press action just fired (pocketLongPressActive).
         */
        function handlePocketTap() {
            if (pocketLongPressActive) {
                // Long-press already handled this touch; discard as regular tap
                pocketLongPressActive = false;
                return;
            }
            ensureAudioReady();
            if (isPocketTimerMode()) {
                toggleTimer();
            } else {
                increaseCounter();
            }
            updatePocketOverlay();
        }

        /**
         * Attach touchstart/touchend/touchcancel listeners to the pocket pad for long-press detection.
         * Long-press (700ms) only applies to timer exercises ‚Äî it logs a partial rep and advances.
         */
        function setupPocketLongPress() {
            const pad = document.querySelector('.pocket-pad');
            if (!pad) return;
            pad.addEventListener('touchstart', handlePocketPressStart, { passive: true });
            pad.addEventListener('touchend', handlePocketPressEnd, { passive: true });
            pad.addEventListener('touchcancel', handlePocketPressCancel, { passive: true });
        }

        /** Remove long-press listeners and clear any pending timer. */
        function cleanupPocketLongPress() {
            const pad = document.querySelector('.pocket-pad');
            if (pad) {
                pad.removeEventListener('touchstart', handlePocketPressStart);
                pad.removeEventListener('touchend', handlePocketPressEnd);
                pad.removeEventListener('touchcancel', handlePocketPressCancel);
            }
            clearTimeout(pocketLongPressTimer);
            pocketLongPressTimer = null;
            pocketLongPressActive = false;
        }

        /** Start the 700ms long-press countdown. Only arms for timer-mode exercises. */
        function handlePocketPressStart() {
            if (!isPocketTimerMode()) return;
            pocketLongPressActive = false;
            pocketLongPressTimer = setTimeout(() => {
                pocketLongPressActive = true;
                pocketLogPartialRep();
                updatePocketOverlay();
                // Distinct beep to confirm partial-rep log
                playBeep(500, 150, 0.4);
            }, 700);
        }

        /** Finger lifted before 700ms ‚Äî cancel the long-press, regular tap will fire via pointerup. */
        function handlePocketPressEnd() {
            clearTimeout(pocketLongPressTimer);
            pocketLongPressTimer = null;
        }

        /** Touch cancelled (e.g. scroll) ‚Äî cancel the long-press without firing tap. */
        function handlePocketPressCancel() {
            clearTimeout(pocketLongPressTimer);
            pocketLongPressTimer = null;
            pocketLongPressActive = false;
        }

        /**
         * Log a partial hold rep: pause the timer and advance to the next rep,
         * accepting whatever elapsed time was completed.
         * Only applies to hold exercises (dosage_type='hold' or hold_seconds modifier).
         */
        function pocketLogPartialRep() {
            if (!isPocketTimerMode()) return;
            // Pause if running so the interval doesn't keep ticking
            if (timerState.isRunning) {
                pauseTimer(false);
            }
            const hasHold = currentExercise.pattern_modifiers?.includes('hold_seconds')
                || currentExercise.dosage_type === 'hold';
            if (hasHold && timerState.currentRep < timerState.totalReps) {
                timerState.currentRep++;
                timerState.elapsedMs = 0;
                timerState.lastAnnouncedSecond = null;
                document.getElementById('timerRepInfo').textContent
                    = `Rep ${timerState.currentRep} of ${timerState.totalReps}`;
                document.getElementById('timerDisplay').textContent
                    = formatTime(timerState.targetSeconds * 1000);
            }
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        /**
         * Toggle hamburger menu visibility
         * iOS-safe: Uses class-based visibility instead of display manipulation
         */
        function toggleHamburger() {
            const overlay = document.getElementById('hamburgerOverlay');
            const menu = document.getElementById('hamburgerMenu');
            overlay.classList.toggle('active');
            menu.classList.toggle('active');
        }

        /**
         * Select side for tracking (left, right, both)
         * Updates UI and stores current selection for logging
         */
        /**
         * Select which side is being worked (for pattern: "side" exercises).
         * Updates UI and stores current selection for logging.
         */
        function selectSide(side) {
            currentSide = side;

            // Update button states
            document.querySelectorAll('.side-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.side === side) {
                    btn.classList.add('active');
                }
            });

            // Update "Working [side] side" feedback label
            const label = document.getElementById('sideTrackingLabel');
            if (label) {
                label.textContent = `Working ${side} side`;
            }

            // Voice announcement for side switch
            speakText(`Working ${side} side`);
        }

        /**
         * Show visual feedback when a set is logged
         * iOS-safe: Uses CSS transitions for smooth animation
         */
        function showLogFeedback() {
            const feedback = document.getElementById('logFeedback');
            feedback.classList.add('show');

            setTimeout(() => {
                feedback.classList.remove('show');
            }, 800);
        }

        /**
         * Sign out the current user
         */
        async function signOut() {
            try {
                await supabaseClient.auth.signOut();
                // Auth state listener will handle UI updates
            } catch (error) {
                console.error('Sign out error:', error);
                showToast('Failed to sign out: ' + error.message, 'error');
            }
        }

        /**
         * Reload the page
         */
        function reloadPage() {
            window.location.reload();
        }

        /**
         * Show debug information about offline queue
         */
        function showDebugInfo() {
            const queueData = JSON.stringify(offlineQueue, null, 2);
            const currentExerciseSummary = currentExercise
                ? JSON.stringify({
                    id: currentExercise.id,
                    name: currentExercise.canonical_name,
                    pattern: currentExercise.pattern,
                    pattern_modifiers: currentExercise.pattern_modifiers,
                    form_parameters_required: currentExercise.form_parameters_required,
                    dosage_type: currentExercise.dosage_type,
                    current_sets: currentExercise.current_sets,
                    current_reps: currentExercise.current_reps
                }, null, 2)
                : 'None selected';
            console.log('Offline Queue:', offlineQueue);
            console.log('Current Exercise Summary:', currentExerciseSummary);

            // Create a modal-like debug display
            const debugInfo = `
Queue Length: ${offlineQueue.length}
Auth Token: ${authToken ? 'Present' : 'Missing'}
Current User: ${currentUser?.email || 'None'}
Exercises Loaded: ${allExercises.length}
Current Exercise:
${currentExerciseSummary}

Queued Sessions:
${queueData}
            `.trim();

            // Show in alert for now (can be improved with a modal)
            alert(debugInfo);

            // Also copy first session to clipboard if available
            if (offlineQueue.length > 0) {
                const firstSession = JSON.stringify(offlineQueue[0], null, 2);
                console.log('First queued session:', firstSession);
                showToast('Debug info logged to console', '', 3000);
            }
        }

        // Track the side selected in Log Set modal
        let logSetSelectedSide = null;

        /**
         * Open "Log Set" modal for manual entry.
         * Pre-fills with TARGET dose (not counter value) for manual logging.
         * Shows form parameters prefilled with last used values.
         * For hold_seconds exercises, shows both reps and time inputs.
         */
        function showLogSetModal() {
            if (!currentExercise) return;

            const modal = document.getElementById('logSetModal');
            const input = document.getElementById('logSetInput');
            const label = document.getElementById('logSetInputLabel');
            const timeContainer = document.getElementById('logSetTimeContainer');
            const timeInput = document.getElementById('logSetTimeInput');

            const hasDuration = currentExercise.pattern_modifiers?.includes('duration_seconds') || currentExercise.dosage_type === 'duration';
            const hasHold = currentExercise.pattern_modifiers?.includes('hold_seconds') || currentExercise.dosage_type === 'hold';

            if (hasDuration) {
                // Duration: prefill with target seconds, hide time input
                input.value = currentExercise.seconds_per_set || currentExercise.seconds_per_rep || 0;
                label.textContent = 'Seconds performed';
                timeContainer.classList.add('hidden');
            } else if (hasHold) {
                // Hold: show both reps and time inputs for manual SET logging
                input.value = currentExercise.current_reps || 0;
                label.textContent = 'Reps performed';
                // Show time input and prefill with target hold time
                timeContainer.classList.remove('hidden');
                timeInput.value = currentExercise.seconds_per_rep || 0;
            } else {
                // Reps: prefill with target reps, hide time input
                input.value = currentExercise.current_reps || 0;
                label.textContent = 'Reps performed';
                timeContainer.classList.add('hidden');
            }

            // Show/hide side selector
            const isSidePattern = currentExercise.pattern === 'side';
            const sideContainer = document.getElementById('logSetSideContainer');
            if (isSidePattern) {
                sideContainer.classList.remove('hidden');
                logSetSelectedSide = currentSide || 'right';
                updateLogSetSideDisplay();
            } else {
                sideContainer.classList.add('hidden');
                logSetSelectedSide = null;
            }

            // Populate form parameters with last used values
            renderFormParameterFields({
                containerId: 'formParamsContainer',
                fieldsId: 'formParamsFields',
                prefix: 'log',
                side: logSetSelectedSide
            });

            modal.classList.remove('hidden');
            input.focus();
        }

        /**
         * Select side in Log Set modal.
         */
        function selectLogSetSide(side) {
            logSetSelectedSide = side;
            updateLogSetSideDisplay();
            renderFormParameterFields({
                containerId: 'formParamsContainer',
                fieldsId: 'formParamsFields',
                prefix: 'log',
                side: logSetSelectedSide
            });
        }

        /**
         * Update Log Set modal side button display.
         */
        function updateLogSetSideDisplay() {
            const leftBtn = document.querySelector('[data-action="log-set-select-side"][data-side="left"]');
            const rightBtn = document.querySelector('[data-action="log-set-select-side"][data-side="right"]');

            if (!leftBtn || !rightBtn) return;

            const targetSets = currentExercise?.current_sets || 0;
            const leftSets = currentSession?.sets.filter(s => s.side === 'left').length || 0;
            const rightSets = currentSession?.sets.filter(s => s.side === 'right').length || 0;

            // Update progress text
            document.getElementById('logSetLeftProgress').textContent = `${leftSets}/${targetSets} sets`;
            document.getElementById('logSetRightProgress').textContent = `${rightSets}/${targetSets} sets`;

            // Update button styles
            if (logSetSelectedSide === 'left') {
                leftBtn.style.border = '2px solid #007AFF';
                leftBtn.style.background = '#007AFF';
                rightBtn.style.border = '2px solid #555';
                rightBtn.style.background = '#2a2a2a';
            } else {
                rightBtn.style.border = '2px solid #007AFF';
                rightBtn.style.background = '#007AFF';
                leftBtn.style.border = '2px solid #555';
                leftBtn.style.background = '#2a2a2a';
            }
        }

        /**
         * Show "Next Set" modal to confirm logging counter/timer value.
         * Shows what will be logged with Cancel/Edit/Log & Next buttons.
         */
        function showNextSetModal() {
            if (!currentExercise || !currentSession) return;

            const counterMode = document.getElementById('counterMode');
            const isTimerMode = counterMode.classList.contains('hidden');

            let logValue, targetValue, unit;
            const hasDuration = currentExercise.pattern_modifiers?.includes('duration_seconds') || currentExercise.dosage_type === 'duration';
            const hasHold = currentExercise.pattern_modifiers?.includes('hold_seconds') || currentExercise.dosage_type === 'hold';

            if (isTimerMode) {
                if (hasDuration) {
                    logValue = Math.floor(timerState.elapsedMs / 1000);
                    targetValue = currentExercise.seconds_per_set || currentExercise.seconds_per_rep || 0;
                    unit = 's';
                } else if (hasHold) {
                    logValue = timerState.currentRep;
                    targetValue = timerState.totalReps;
                    unit = ' reps';
                } else {
                    logValue = Math.floor(timerState.elapsedMs / 1000);
                    targetValue = currentExercise.seconds_per_rep || 0;
                    unit = 's';
                }
            } else {
                logValue = parseInt(document.getElementById('counterDisplay').textContent) || 0;
                targetValue = currentExercise.current_reps || 0;
                unit = ' reps';
            }

            // Build summary
            document.getElementById('nextSetSummary').textContent = `${logValue}${unit} (target ${targetValue}${unit})`;

            // Show form parameters that will be logged
            renderFormParameterFields({
                containerId: 'nextSetParamsContainer',
                fieldsId: 'nextSetParamsFields',
                prefix: 'next',
                side: currentSide
            });

            // Show side info for sided exercises
            const sideDisplay = document.getElementById('nextSetSideDisplay');
            const isSidePattern = currentExercise.pattern === 'side';
            if (isSidePattern && currentSide) {
                sideDisplay.textContent = `Side: ${currentSide.charAt(0).toUpperCase() + currentSide.slice(1)}`;
                sideDisplay.classList.remove('hidden');
            } else {
                sideDisplay.classList.add('hidden');
            }

            document.getElementById('nextSetModal').classList.remove('hidden');
        }

        function closeNextSetModal() {
            document.getElementById('nextSetModal').classList.add('hidden');
        }

        /**
         * Edit button in Next Set modal - opens Log Set modal for editing.
         */
        function editNextSet() {
            closeNextSetModal();
            showLogSetModal();
        }

        /**
         * Confirm and log the set from Next Set modal.
         */
        function confirmNextSet() {
            const counterMode = document.getElementById('counterMode');
            const isTimerMode = counterMode.classList.contains('hidden');

            let reps = null;
            let seconds = null;

            const hasDuration = currentExercise.pattern_modifiers?.includes('duration_seconds') || currentExercise.dosage_type === 'duration';
            const hasHold = currentExercise.pattern_modifiers?.includes('hold_seconds') || currentExercise.dosage_type === 'hold';

            if (isTimerMode) {
                if (hasDuration) {
                    reps = 1;
                    seconds = Math.floor(timerState.elapsedMs / 1000);
                } else if (hasHold) {
                    reps = timerState.currentRep;
                    seconds = timerState.targetSeconds;
                }
                resetTimer();
            } else {
                reps = parseInt(document.getElementById('counterDisplay').textContent) || 0;
            }

            if (reps === 0 && !seconds) {
                showToast('Please perform at least one rep', 'error');
                closeNextSetModal();
                return;
            }

            const formData = collectFormParameters('nextSetParamsContainer');

            const set = {
                set_number: currentSession.sets.length + 1,
                reps: reps,
                seconds: seconds,
                distance_feet: null,
                side: currentSide,
                form_data: formData.length > 0 ? formData : null,
                manual_log: false,
                partial_rep: false,
                performed_at: new Date().toISOString()
            };

            currentSession.sets.push(set);

            // Reset timer rep counter for next set (hold exercises)
            if (isTimerMode && hasHold) {
                timerState.currentRep = 1;
                document.getElementById('timerRepInfo').textContent = `Rep ${timerState.currentRep} of ${timerState.totalReps}`;
            }

            // Update sets progress display
            updateSetsProgress();

            // Reset counter for next set
            document.getElementById('counterDisplay').textContent = '0';

            // Voice comparison to last time
            announceProgressComparison(set);

            closeNextSetModal();
            showLogFeedback();
        }

        /**
         * Go back to previous set (undo last logged set).
         */
        function previousSet() {
            if (!currentSession || currentSession.sets.length === 0) {
                showToast('No sets to undo', 'error');
                return;
            }

            const removedSet = currentSession.sets.pop();
            updateSetsProgress();
            showToast(`Set ${removedSet.set_number} removed`, 'success');
        }

        /**
         * Announce progress comparison to last session.
         * "X more/less reps than last time"
         */
        function announceProgressComparison(currentSet) {
            if (!currentExercise) return;

            // Find previous session for this exercise
            const prevLogs = allHistory.filter(log =>
                log.exercise_id === currentExercise.id || log.exercise_name === currentExercise.canonical_name
            ).sort((a, b) => new Date(b.performed_at) - new Date(a.performed_at));

            if (prevLogs.length === 0) return;

            const prevLog = prevLogs[0];
            if (!prevLog.sets || prevLog.sets.length === 0) return;

            // Find matching set (same set number and side if applicable)
            const matchingSet = prevLog.sets.find(s => {
                if (currentExercise.pattern === 'side') {
                    return s.set_number === currentSet.set_number && s.side === currentSet.side;
                }
                return s.set_number === currentSet.set_number;
            });

            if (!matchingSet) return;

            const prevReps = matchingSet.reps || 0;
            const currReps = currentSet.reps || 0;
            const diff = currReps - prevReps;

            if (diff > 0) {
                setTimeout(() => speakText(`${diff} more rep${diff > 1 ? 's' : ''} than last time`), 1500);
            } else if (diff < 0 && Math.abs(diff) > 2) {
                setTimeout(() => speakText(`${Math.abs(diff)} fewer reps than last time`), 1500);
            }
        }

        /**
         * Get historical values for a parameter from this exercise.
         */
        function getHistoricalParamValues(exerciseId, paramName, side = null) {
            const values = new Set();

            const exerciseLogs = allHistory.filter(log => log.exercise_id === exerciseId);
            exerciseLogs.forEach(log => {
                (log.sets || []).forEach(set => {
                    if (side && set.side !== side) return;

                    if (set.form_data && Array.isArray(set.form_data)) {
                        const param = set.form_data.find(p => p.parameter_name === paramName);
                        if (param && param.parameter_value !== undefined && param.parameter_value !== null) {
                            const fullValue = param.parameter_unit
                                ? `${param.parameter_value} ${param.parameter_unit}`
                                : param.parameter_value;
                            values.add(fullValue);
                        }
                    }
                });
            });

            return Array.from(values).sort();
        }

        /**
         * Get ALL historical values for a parameter across ALL exercises (global).
         * Used to populate smart dropdowns with all previously logged values.
         *
         * Parameters are MUTABLE - dropdown shows ALL values ever logged for that parameter
         * across all exercises, not just the current exercise. This allows parameter values
         * to evolve over time (e.g., new band colors, new surface types).
         *
         * form_data is normalized: [{parameter_name, parameter_value, parameter_unit}, ...]
         */
        function getGlobalHistoricalParamValues(paramName) {
            const values = new Set();

            allHistory.forEach(log => {
                (log.sets || []).forEach(set => {
                    // form_data is an array of {parameter_name, parameter_value, parameter_unit}
                    if (set.form_data && Array.isArray(set.form_data)) {
                        const param = set.form_data.find(p => p.parameter_name === paramName);
                        if (param) {
                            // Combine value + unit if unit exists (e.g., "15 lb")
                            const fullValue = param.parameter_unit
                                ? `${param.parameter_value} ${param.parameter_unit}`
                                : param.parameter_value;
                            values.add(fullValue);
                        }
                    }
                });
            });

            return Array.from(values).sort();
        }

        /**
         * Get the last used value for a parameter (most recent).
         * Returns combined "value unit" string (e.g., "15 lb") or just value.
         */
        function getLastUsedParamValue(exerciseId, paramName, side = null) {
            if (currentSession && currentSession.exerciseId === exerciseId) {
                const sessionSets = [...(currentSession.sets || [])].reverse();
                for (const set of sessionSets) {
                    if (side && set.side !== side) continue;

                    if (set.form_data && Array.isArray(set.form_data)) {
                        const param = set.form_data.find(p => p.parameter_name === paramName);
                        if (param) {
                            return param.parameter_unit
                                ? `${param.parameter_value} ${param.parameter_unit}`
                                : param.parameter_value;
                        }
                    }
                }
            }

            const exerciseLogs = allHistory.filter(log => log.exercise_id === exerciseId);

            // Sort by date descending (most recent first)
            exerciseLogs.sort((a, b) => new Date(b.performed_at) - new Date(a.performed_at));

            for (const log of exerciseLogs) {
                for (const set of (log.sets || [])) {
                    if (side && set.side !== side) continue;

                    // form_data is an array of {parameter_name, parameter_value, parameter_unit}
                    if (set.form_data && Array.isArray(set.form_data)) {
                        const param = set.form_data.find(p => p.parameter_name === paramName);
                        if (param) {
                            // Combine value + unit if unit exists
                            return param.parameter_unit
                                ? `${param.parameter_value} ${param.parameter_unit}`
                                : param.parameter_value;
                        }
                    }
                }
            }

            return null;
        }

        /**
         * Render form parameter fields based on exercise requirements.
         * Weight and distance are special (int + unit), others are smart dropdowns.
         */
        function renderFormParameterFields({ containerId, fieldsId, prefix, side = null }) {
            const formParams = currentExercise?.form_parameters_required || [];
            const container = document.getElementById(containerId);
            const fieldsDiv = document.getElementById(fieldsId);

            if (!container || !fieldsDiv) return;

            if (formParams.length === 0) {
                fieldsDiv.innerHTML = '';
                container.classList.add('hidden');
                return;
            }

            const html = formParams.map(param => {
                if (param === 'weight') {
                    const lastValue = getLastUsedParamValue(currentExercise.id, param, side);
                    const [weightNum, weightUnit] = lastValue ? lastValue.split(' ') : ['', 'lb'];

                    return `
                        <div style="margin-bottom: 12px;">
                            <label style="font-size: 13px; margin-bottom: 4px; display: block;">Weight</label>
                            <div style="display: flex; gap: 8px;">
                                <input type="number" class="modal-input" id="${prefix}-weight" placeholder="Weight" min="0" step="1" value="${weightNum || ''}" style="flex: 1; margin: 0;" data-param="weight">
                                <select class="modal-select" id="${prefix}-weight-unit" style="width: 80px; margin: 0;" data-param-unit="weight">
                                    <option value="lb" ${weightUnit === 'lb' ? 'selected' : ''}>lb</option>
                                    <option value="kg" ${weightUnit === 'kg' ? 'selected' : ''}>kg</option>
                                </select>
                            </div>
                        </div>
                    `;
                }

                if (param === 'distance') {
                    const lastValue = getLastUsedParamValue(currentExercise.id, param, side);
                    const [distNum, distUnit] = lastValue ? lastValue.split(' ') : ['', 'ft'];

                    return `
                        <div style="margin-bottom: 12px;">
                            <label style="font-size: 13px; margin-bottom: 4px; display: block;">Distance</label>
                            <div style="display: flex; gap: 8px;">
                                <input type="number" class="modal-input" id="${prefix}-distance" placeholder="Distance" min="0" step="1" value="${distNum || ''}" style="flex: 1; margin: 0;" data-param="distance">
                                <select class="modal-select" id="${prefix}-distance-unit" style="width: 80px; margin: 0;" data-param-unit="distance">
                                    <option value="ft" ${distUnit === 'ft' ? 'selected' : ''}>ft</option>
                                    <option value="in" ${distUnit === 'in' ? 'selected' : ''}>in</option>
                                    <option value="cm" ${distUnit === 'cm' ? 'selected' : ''}>cm</option>
                                    <option value="deg" ${distUnit === 'deg' ? 'selected' : ''}>deg</option>
                                </select>
                            </div>
                        </div>
                    `;
                }

                const historicalValues = getHistoricalParamValues(currentExercise.id, param, side);
                const globalValues = getGlobalHistoricalParamValues(param);
                const lastUsed = getLastUsedParamValue(currentExercise.id, param, side);
                const label = param.replace(/_/g, ' ');
                const mergedValues = new Set([...historicalValues, ...globalValues]);
                if (lastUsed) mergedValues.add(lastUsed);

                const options = Array.from(mergedValues).sort().map(value => {
                    const selected = value === lastUsed ? 'selected' : '';
                    return `<option value="${escapeHtml(value)}" ${selected}>${escapeHtml(value)}</option>`;
                }).join('');

                return `
                    <div style="margin-bottom: 12px;">
                        <label style="font-size: 13px; margin-bottom: 4px; display: block;">${label}</label>
                        <select class="modal-select param-select" id="${prefix}-param-${param}" data-param="${param}">
                            ${!lastUsed ? `<option value="">Select ${label}...</option>` : ''}
                            ${options}
                            <option value="${CUSTOM_PARAM_VALUE}">Other...</option>
                        </select>
                        <input type="text" class="modal-input" id="${prefix}-param-${param}-custom" placeholder="Enter ${label}" style="display: none; margin-top: 8px;" data-param="${param}">
                    </div>
                `;
            }).join('');

            fieldsDiv.innerHTML = html;
            container.classList.remove('hidden');
        }

        /**
         * Collect form parameters from a container.
         */
        function collectFormParameters(containerId) {
            const container = document.getElementById(containerId);
            if (!container || container.classList.contains('hidden')) {
                return [];
            }

            const formData = [];

            const weightInput = container.querySelector('input[data-param="weight"]');
            if (weightInput && weightInput.value) {
                const unit = container.querySelector('select[data-param-unit="weight"]')?.value || 'lb';
                formData.push({
                    parameter_name: 'weight',
                    parameter_value: weightInput.value,
                    parameter_unit: unit
                });
            }

            const distanceInput = container.querySelector('input[data-param="distance"]');
            if (distanceInput && distanceInput.value) {
                const unit = container.querySelector('select[data-param-unit="distance"]')?.value || 'ft';
                formData.push({
                    parameter_name: 'distance',
                    parameter_value: distanceInput.value,
                    parameter_unit: unit
                });
            }

            container.querySelectorAll('.param-select').forEach(select => {
                const paramName = select.dataset.param;
                if (!paramName) return;

                let paramValue = null;

                if (select.value === CUSTOM_PARAM_VALUE) {
                    const customInput = document.getElementById(`${select.id}-custom`);
                    if (customInput && customInput.value.trim()) {
                        paramValue = customInput.value.trim();
                    }
                } else if (select.value && select.value.trim() !== '') {
                    paramValue = select.value;
                }

                if (paramValue) {
                    formData.push({
                        parameter_name: paramName,
                        parameter_value: paramValue,
                        parameter_unit: null
                    });
                }
            });

            return formData;
        }

        /**
         * iOS-safe event delegation for param select "Other" option.
         */
        document.addEventListener('change', (event) => {
            if (!event.target.classList.contains('param-select')) return;

            const customInput = document.getElementById(`${event.target.id}-custom`);
            if (!customInput) return;

            if (event.target.value === CUSTOM_PARAM_VALUE) {
                customInput.style.display = 'block';
                customInput.focus();
            } else {
                customInput.style.display = 'none';
                customInput.value = '';
            }
        });

        function closeLogSetModal() {
            document.getElementById('logSetModal').classList.add('hidden');
        }

        /**
         * Save the set from the modal (user reviewed/edited the value).
         * Collects form parameters (weight, band resistance, etc.) if present.
         * For hold_seconds exercises opened via LOG SET, creates a complete set
         * with reps and time from the form inputs.
         */
        function saveLoggedSet() {
            const counterMode = document.getElementById('counterMode');
            const isTimerMode = counterMode.classList.contains('hidden');
            const input = document.getElementById('logSetInput');
            const value = parseInt(input.value) || 0;
            const timeInput = document.getElementById('logSetTimeInput');
            const timeContainer = document.getElementById('logSetTimeContainer');

            if (value === 0) {
                showToast('Please enter a value greater than 0', 'error');
                return;
            }

            let reps = null;
            let seconds = null;

            const hasHold = currentExercise.pattern_modifiers?.includes('hold_seconds') || currentExercise.dosage_type === 'hold';
            const hasDuration = currentExercise.pattern_modifiers?.includes('duration_seconds') || currentExercise.dosage_type === 'duration';

            // Check if time input is visible (manual LOG SET for hold exercise)
            const isManualHoldEntry = hasHold && !timeContainer.classList.contains('hidden');

            if (isManualHoldEntry) {
                // Manual entry for hold exercise: user entered both reps and time
                // Create a complete SET directly (not rep-by-rep)
                reps = value;
                seconds = parseInt(timeInput.value) || 0;
                if (seconds === 0) {
                    showToast('Please enter seconds per rep', 'error');
                    return;
                }
                // Reset timer if it was running
                if (isTimerMode) {
                    resetTimer();
                }
            } else if (isTimerMode) {
                // Timer mode: check if this is hold (per-rep) or duration (single timer)
                if (hasHold) {
                    // Hold exercise via timer: track reps, create set only when all reps complete
                    timerState.currentRep++;  // Increment rep count

                    if (timerState.currentRep > timerState.totalReps) {
                        // All reps complete - create the set
                        reps = timerState.totalReps;  // Total reps performed
                        seconds = timerState.targetSeconds;  // Seconds per rep
                        // Don't add to currentSession.sets here - will be done below
                    } else {
                        // More reps to go - reset timer for next rep
                        resetTimer();
                        document.getElementById('timerRepInfo').textContent = `Rep ${timerState.currentRep} of ${timerState.totalReps}`;
                        closeLogSetModal();
                        showToast(`Rep ${timerState.currentRep - 1} complete`, 'success', 2000);
                        return;  // Don't create set yet
                    }
                } else if (hasDuration) {
                    // Duration exercise: single set with just time
                    reps = 1;  // Always 1 rep for duration
                    seconds = value;
                } else {
                    // Timer mode but not hold/duration - shouldn't happen but handle gracefully
                    reps = 1;
                    seconds = value;
                }

                // Reset timer for next set
                resetTimer();
            } else {
                reps = value;
                // Reset counter for next set
                document.getElementById('counterDisplay').textContent = '0';
            }

            const formData = collectFormParameters('formParamsContainer');

            // Determine if this is a manual log entry (using LOG SET button directly)
            const isManualLog = isManualHoldEntry || (!isTimerMode && !hasHold && !hasDuration);

            const set = {
                set_number: currentSession.sets.length + 1,
                reps: reps,  // Always populated (never null)
                seconds: seconds,
                distance_feet: null, // TODO: Add distance mode
                side: logSetSelectedSide || currentSide,
                form_data: formData.length > 0 ? formData : null, // Normalized array
                manual_log: isManualLog,
                partial_rep: false,
                performed_at: new Date().toISOString()
            };

            currentSession.sets.push(set);

            // Reset timer rep counter for next set (hold exercises)
            if (isTimerMode && currentExercise.pattern_modifiers?.includes('hold_seconds')) {
                timerState.currentRep = 1;
                document.getElementById('timerRepInfo').textContent = `Rep ${timerState.currentRep} of ${timerState.totalReps}`;
            }

            // Update sets progress display
            updateSetsProgress();

            // Reset counter for next set
            document.getElementById('counterDisplay').textContent = '0';

            // Voice comparison to last time
            announceProgressComparison(set);

            // Close modal and show feedback
            closeLogSetModal();
            showLogFeedback();
        }

        // Finish session
        function finishSession() {
            if (currentSession.sets.length === 0) {
                showToast('Please log at least one set before finishing', 'error');
                return;
            }

            // Show notes modal
            document.getElementById('notesModal').classList.remove('hidden');
        }

        function closeNotesModal() {
            document.getElementById('notesModal').classList.add('hidden');
            // Reset backdate UI
            document.getElementById('backdateContainer').classList.add('hidden');
            document.getElementById('backdateWarning').classList.add('hidden');
            document.getElementById('backdateInput').value = '';
        }

        function toggleBackdate() {
            const container = document.getElementById('backdateContainer');
            const input = document.getElementById('backdateInput');
            const isHidden = container.classList.contains('hidden');

            if (isHidden) {
                // Show and default to session start time (now)
                const date = new Date(currentSession.date);
                const localDate = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
                input.value = localDate.toISOString().slice(0, 16);
                container.classList.remove('hidden');
                document.getElementById('backdateWarning').classList.add('hidden');
            } else {
                container.classList.add('hidden');
                document.getElementById('backdateWarning').classList.add('hidden');
                input.value = '';
            }
        }

        // ============================================================================
        // MESSAGES FUNCTIONALITY
        // ============================================================================

        let lastReadMessageTime = localStorage.getItem('lastReadMessageTime') || new Date(0).toISOString();

        async function showMessagesModal() {
            if (!currentUser) {
                showToast('Please sign in to view messages', 'error');
                return;
            }

            toggleHamburger(); // Close menu ‚Äî frame 1: browser paints menu-close

            // Yield to browser so the menu-close paints before the modal opens.
            // Prevents menu-close + modal-open layout recalculations compressing into
            // one blocking frame (root cause of #hamburgerMenu 3,488ms INP).
            await new Promise(r => requestAnimationFrame(r));

            document.getElementById('messagesModal').classList.remove('hidden');

            // Sync notification toggle to current preference each time modal opens
            const notifyToggle = document.getElementById('emailNotifyToggle');
            if (notifyToggle) notifyToggle.checked = currentEmailNotifyEnabled;

            await loadMessages();

            // Mark messages as read (locally + server-side)
            lastReadMessageTime = new Date().toISOString();
            localStorage.setItem('lastReadMessageTime', lastReadMessageTime);
            markReceivedMessagesAsRead();

            // Hide badge
            const badge = document.getElementById('messagesBadge');
            if (badge) badge.classList.add('hidden');
        }

        async function markReceivedMessagesAsRead() {
            if (!currentUser || !authToken) return;
            try {
                const response = await fetch('/api/logs?type=messages', {
                    headers: { 'Authorization': `Bearer ${authToken}` }
                });
                if (!response.ok) return;
                const data = await response.json();
                const viewerId = currentUserProfileId || currentUser.id;
                const unread = (data.messages || []).filter(msg =>
                    msg.recipient_id === viewerId && !msg.read_by_recipient
                );
                // Fire-and-forget PATCH for each unread message
                for (const msg of unread) {
                    fetch(`/api/logs?type=messages&id=${msg.id}`, {
                        method: 'PATCH',
                        headers: {
                            'Authorization': `Bearer ${authToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ read: true })
                    }).catch(() => {}); // Best-effort, don't block UI
                }
            } catch (e) {
                // Non-critical, don't surface to user
            }
        }

        function closeMessagesModal() {
            document.getElementById('messagesModal').classList.add('hidden');
        }

        async function loadMessages() {
            if (!currentUser || !authToken) {
                console.log('[Messages] No current user, cannot load messages');
                return;
            }

            const messagesList = document.getElementById('messagesList');
            messagesList.innerHTML = '<div style="text-align: center; color: #666; padding: 2rem;">Loading messages...</div>';

            try {
                const response = await fetch('/api/logs?type=messages', {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch messages');
                }

                const data = await response.json();
                const messages = data.messages || [];

                if (messages.length === 0) {
                    messagesList.innerHTML = '<div style="text-align: center; color: #666; padding: 2rem;">No messages yet. Send a message to your PT!</div>';
                    return;
                }

                // Render messages
                let html = '';
                messages.forEach(msg => {
                    const viewerId = currentUserProfileId || currentUser.id;
                    const isFromPatient = msg.sender_id === viewerId;
                    const createdAt = new Date(msg.created_at);
                    const sentDateTime = formatMessageDateTime(createdAt);

                    // Check if message can be undone (within 1 hour)
                    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
                    const canUndo = isFromPatient && createdAt > oneHourAgo;

                    // Read receipt for sent messages
                    let readReceipt = '';
                    if (isFromPatient) {
                        if (msg.read_at) {
                            const readTime = formatMessageDateTime(new Date(msg.read_at));
                            readReceipt = `<span style="font-size: 13px; color: #28a745;">Read ${readTime}</span>`;
                        } else {
                            readReceipt = `<span style="font-size: 13px; color: #aaa;">Delivered</span>`;
                        }
                    }

                    html += `
                        <div style="
                            padding: 12px;
                            margin-bottom: 8px;
                            border-radius: 12px;
                            border-left: 4px solid ${isFromPatient ? '#28a745' : '#007bff'};
                            background: ${isFromPatient ? '#f0fff0' : '#f0f7ff'};
                        ">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                <span style="font-weight: 600; font-size: 15px; color: ${isFromPatient ? '#28a745' : '#007bff'};">
                                    ${isFromPatient ? 'You ‚Üí PT' : 'PT ‚Üí You'}
                                </span>
                                <span style="font-size: 13px; color: #888;">${sentDateTime}</span>
                            </div>
                            <div style="font-size: 16px; color: #333; white-space: pre-wrap;">${escapeHtml(msg.body)}</div>
                            <div style="margin-top: 8px; display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; gap: 8px;">
                                    <button data-action="archive-message" data-id="${msg.id}" style="background: transparent; border: none; color: #888; cursor: pointer; padding: 4px 8px; font-size: 13px;">Hide</button>
                                    ${canUndo ? `<button data-action="undo-send-message" data-id="${msg.id}" style="background: transparent; border: none; color: #dc3545; cursor: pointer; padding: 4px 8px; font-size: 13px;">Undo Send</button>` : ''}
                                </div>
                                ${readReceipt}
                            </div>
                        </div>
                    `;
                });

                messagesList.innerHTML = html;

            } catch (error) {
                console.error('Error loading messages:', error);
                messagesList.innerHTML = '<div style="text-align: center; color: #dc3545; padding: 2rem;">Failed to load messages</div>';
            }
        }

        /**
         * Toggle email notification preference for current user.
         * Calls PATCH /api/users with { email_notifications_enabled: boolean }.
         * Reverts the checkbox on failure and shows a toast.
         *
         * Note: checkbox `change` event is reliable on iOS Safari ‚Äî no pointerup needed for checkboxes.
         *
         * @param {boolean} enabled - The new preference value
         */
        async function toggleEmailNotifications(enabled) {
            try {
                await fetchWithAuth('/api/users', {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email_notifications_enabled: enabled })
                });
                currentEmailNotifyEnabled = enabled;
                showToast(enabled ? 'Email notifications enabled' : 'Email notifications turned off');
            } catch (e) {
                console.error('Failed to update notification preference:', e);
                showToast('Failed to update notification preference', 'error');
                // Revert checkbox to previous state on failure
                const toggle = document.getElementById('emailNotifyToggle');
                if (toggle) toggle.checked = !enabled;
            }
        }

        async function sendMessage() {
            const textEl = document.getElementById('newMessageText');
            const text = textEl.value.trim();

            if (!text) {
                showToast('Please enter a message', 'error');
                return;
            }

            if (!currentUser || !authToken) {
                showToast('Please sign in to send messages', 'error');
                return;
            }

            try {
                if (!therapistId) {
                    showToast('No therapist assigned. Cannot send message.', 'error');
                    return;
                }

                const response = await fetch('/api/logs?type=messages', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        recipient_id: therapistId,
                        body: text
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to send message');
                }

                textEl.value = '';
                await loadMessages();
                showToast('Message sent');

            } catch (error) {
                console.error('Error sending message:', error);
                showToast('Failed to send message', 'error');
            }
        }

        async function archiveMessage(messageId) {
            if (!authToken) return;

            try {
                const response = await fetch(`/api/logs?type=messages&id=${messageId}`, {
                    method: 'PATCH',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ archived: true })
                });

                if (!response.ok) {
                    throw new Error('Failed to archive message');
                }

                await loadMessages();

            } catch (error) {
                console.error('Error archiving message:', error);
                showToast('Failed to hide message', 'error');
            }
        }

        async function undoSendMessage(messageId) {
            if (!authToken) return;

            if (!confirm('Delete this message? It will be removed for both you and your PT.')) {
                return;
            }

            try {
                const response = await fetch(`/api/logs?type=messages&id=${messageId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to delete message');
                }

                await loadMessages();
                showToast('Message deleted');

            } catch (error) {
                console.error('Error deleting message:', error);
                showToast('Failed to delete message', 'error');
            }
        }

        async function checkForNewMessages() {
            if (!currentUser || !authToken) return;

            try {
                const response = await fetch('/api/logs?type=messages', {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                if (!response.ok) return;

                const data = await response.json();
                const messages = data.messages || [];

                // Count unread messages (received after lastReadMessageTime)
                const unreadCount = messages.filter(msg => {
                    const viewerId = currentUserProfileId || currentUser.id;
                    const isFromOther = msg.sender_id !== viewerId;
                    const isNew = new Date(msg.created_at) > new Date(lastReadMessageTime);
                    return isFromOther && isNew;
                }).length;

                const badge = document.getElementById('messagesBadge');
                if (badge) {
                    if (unreadCount > 0) {
                        badge.textContent = unreadCount;
                        badge.classList.remove('hidden');
                    } else {
                        badge.classList.add('hidden');
                    }
                }

            } catch (error) {
                console.error('Error checking for new messages:', error);
            }
        }

        // ============================================================================
        // EDIT SESSION FUNCTIONALITY
        // ============================================================================

        let editingLog = null; // Currently editing log

        /**
         * Open the Edit Session modal for a specific log entry.
         */
        function openEditSessionModal(logId) {
            editingLog = allHistory.find(log => log.id === logId);
            if (!editingLog) {
                showToast('Session not found', 'error');
                return;
            }

            // Find exercise info
            const exercise = allExercises.find(ex => ex.id === editingLog.exercise_id);
            // Detect sided from exercise pattern OR if any set has side data
            const hasSideData = editingLog.sets?.some(s => s.side);
            const isSided = exercise?.pattern === 'side' || hasSideData;

            // Populate exercise info
            document.getElementById('editSessionExerciseName').textContent = editingLog.exercise_name;
            document.getElementById('editSessionExerciseType').textContent = isSided ? 'üîÑ Sided' : '';

            // Populate date
            const date = new Date(editingLog.performed_at);
            const dateInput = document.getElementById('editSessionDate');
            // Format for datetime-local input
            const localDate = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
            dateInput.value = localDate.toISOString().slice(0, 16);

            // Populate notes
            document.getElementById('editSessionNotes').value = editingLog.notes || '';

            // Render sets
            renderEditSessionSets(editingLog.sets || [], isSided, exercise);

            document.getElementById('editSessionModal').classList.remove('hidden');
        }

        /**
         * Render the sets list in the Edit Session modal.
         */
        /**
         * Render sets in the edit session modal.
         * Shows reps, seconds (for hold/duration), distance (for distance), side, and form params.
         */
        function renderEditSessionSets(sets, isSided, exercise) {
            const container = document.getElementById('editSessionSetsList');
            const formParams = exercise?.form_parameters_required || [];

            // Determine which fields to show based on exercise pattern modifiers
            const hasHold = exercise?.pattern_modifiers?.includes('hold_seconds') || exercise?.dosage_type === 'hold';
            const hasDuration = exercise?.pattern_modifiers?.includes('duration_seconds') || exercise?.dosage_type === 'duration';
            const hasDistance = exercise?.pattern_modifiers?.includes('distance_feet') || exercise?.dosage_type === 'distance';
            const showSeconds = hasHold || hasDuration;

            if (sets.length === 0) {
                container.innerHTML = '<div style="color: #888; font-style: italic;">No sets logged</div>';
                return;
            }

            const html = sets.map((set, index) => {
                // Build form params display
                let paramsHtml = '';
                if (formParams.length > 0 && set.form_data && set.form_data.length > 0) {
                    paramsHtml = set.form_data.map(p => `
                        <div style="display: flex; gap: 8px; margin-top: 8px;">
                            <label style="flex: 1; font-size: 0.85rem; color: #888;">${p.parameter_name}</label>
                            <input type="text" class="edit-set-param" data-set="${index}" data-param="${p.parameter_name}"
                                value="${p.parameter_value}${p.parameter_unit ? ' ' + p.parameter_unit : ''}"
                                style="flex: 2; padding: 6px 10px; border: 1px solid #555; border-radius: 4px; background: #2a2a2a; color: #fff; font-size: 0.9rem;">
                        </div>
                    `).join('');
                }

                // Determine label for reps field based on exercise type
                const repsLabel = hasDuration ? 'Reps (usually 1)' : 'Reps';
                const secondsLabel = hasHold ? 'Seconds/rep' : 'Seconds';

                return `
                    <div class="edit-session-set" style="background: #1a1a1a; border-radius: 8px; padding: 12px; margin-bottom: 12px; border: 1px solid #333;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-weight: 600;">Set ${index + 1}</span>
                            <button type="button" class="btn" style="background: transparent; color: #dc3545; padding: 4px 12px; font-size: 0.85rem;" data-action="delete-edit-session-set" data-set-index="${index}">Delete</button>
                        </div>
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            <div style="flex: 1; min-width: 80px;">
                                <label style="font-size: 0.85rem; color: #888; display: block; margin-bottom: 4px;">${repsLabel}</label>
                                <input type="number" class="edit-set-reps" data-set="${index}" value="${set.reps || 0}"
                                    style="width: 100%; padding: 10px; border: 1px solid #555; border-radius: 4px; background: #2a2a2a; color: #fff; font-size: 1rem;">
                            </div>
                            ${showSeconds ? `
                            <div style="flex: 1; min-width: 80px;">
                                <label style="font-size: 0.85rem; color: #888; display: block; margin-bottom: 4px;">${secondsLabel}</label>
                                <input type="number" class="edit-set-seconds" data-set="${index}" value="${set.seconds || 0}"
                                    style="width: 100%; padding: 10px; border: 1px solid #555; border-radius: 4px; background: #2a2a2a; color: #fff; font-size: 1rem;">
                            </div>
                            ` : ''}
                            ${hasDistance ? `
                            <div style="flex: 1; min-width: 80px;">
                                <label style="font-size: 0.85rem; color: #888; display: block; margin-bottom: 4px;">Distance (ft)</label>
                                <input type="number" class="edit-set-distance" data-set="${index}" value="${set.distance_feet || 0}"
                                    style="width: 100%; padding: 10px; border: 1px solid #555; border-radius: 4px; background: #2a2a2a; color: #fff; font-size: 1rem;">
                            </div>
                            ` : ''}
                            ${isSided ? `
                            <div style="flex: 1; min-width: 80px;">
                                <label style="font-size: 0.85rem; color: #888; display: block; margin-bottom: 4px;">Side</label>
                                <select class="edit-set-side" data-set="${index}"
                                    style="width: 100%; padding: 10px; border: 1px solid #555; border-radius: 4px; background: #2a2a2a; color: #fff; font-size: 1rem;">
                                    <option value="left" ${set.side === 'left' ? 'selected' : ''}>Left</option>
                                    <option value="right" ${set.side === 'right' ? 'selected' : ''}>Right</option>
                                </select>
                            </div>
                            ` : ''}
                        </div>
                        ${paramsHtml}
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        /**
         * Add a new set to the editing session.
         * Pre-fills with default values based on exercise type.
         */
        function addEditSessionSet() {
            if (!editingLog) return;

            const exercise = allExercises.find(ex => ex.id === editingLog.exercise_id);
            const isSided = exercise?.pattern === 'side';
            const hasHold = exercise?.pattern_modifiers?.includes('hold_seconds') || exercise?.dosage_type === 'hold';
            const hasDuration = exercise?.pattern_modifiers?.includes('duration_seconds') || exercise?.dosage_type === 'duration';
            const hasDistance = exercise?.pattern_modifiers?.includes('distance_feet') || exercise?.dosage_type === 'distance';

            // Create new set with default values based on exercise type
            const newSet = {
                set_number: (editingLog.sets?.length || 0) + 1,
                reps: hasDuration ? 1 : (exercise?.current_reps || 10),
                seconds: (hasHold || hasDuration) ? (exercise?.seconds_per_rep || exercise?.seconds_per_set || 30) : null,
                distance_feet: hasDistance ? (exercise?.distance_feet || 20) : null,
                side: isSided ? 'right' : null,
                form_data: null,
                performed_at: new Date().toISOString()
            };

            if (!editingLog.sets) editingLog.sets = [];
            editingLog.sets.push(newSet);

            renderEditSessionSets(editingLog.sets, isSided, exercise);
        }

        /**
         * Delete a set from the editing session.
         */
        function deleteEditSessionSet(setIndex) {
            if (!editingLog || !editingLog.sets) return;

            editingLog.sets.splice(setIndex, 1);

            // Renumber sets
            editingLog.sets.forEach((set, i) => set.set_number = i + 1);

            const exercise = allExercises.find(ex => ex.id === editingLog.exercise_id);
            const isSided = exercise?.pattern === 'side';
            renderEditSessionSets(editingLog.sets, isSided, exercise);
        }

        function closeEditSessionModal() {
            document.getElementById('editSessionModal').classList.add('hidden');
            editingLog = null;
        }

        /**
         * Save edited session to the API.
         */
        async function saveEditSession() {
            if (!editingLog) return;

            // Collect updated values from form
            const dateInput = document.getElementById('editSessionDate');
            const notesInput = document.getElementById('editSessionNotes');

            // Update sets from form inputs
            document.querySelectorAll('.edit-set-reps').forEach(input => {
                const setIndex = parseInt(input.dataset.set);
                if (editingLog.sets[setIndex]) {
                    editingLog.sets[setIndex].reps = parseInt(input.value) || 0;
                }
            });

            document.querySelectorAll('.edit-set-seconds').forEach(input => {
                const setIndex = parseInt(input.dataset.set);
                if (editingLog.sets[setIndex]) {
                    editingLog.sets[setIndex].seconds = parseInt(input.value) || null;
                }
            });

            document.querySelectorAll('.edit-set-distance').forEach(input => {
                const setIndex = parseInt(input.dataset.set);
                if (editingLog.sets[setIndex]) {
                    editingLog.sets[setIndex].distance_feet = parseInt(input.value) || null;
                }
            });

            document.querySelectorAll('.edit-set-side').forEach(select => {
                const setIndex = parseInt(select.dataset.set);
                if (editingLog.sets[setIndex]) {
                    editingLog.sets[setIndex].side = select.value;
                }
            });

            // Update form parameters
            document.querySelectorAll('.edit-set-param').forEach(input => {
                const setIndex = parseInt(input.dataset.set);
                const paramName = input.dataset.param;
                if (editingLog.sets[setIndex] && editingLog.sets[setIndex].form_data) {
                    const param = editingLog.sets[setIndex].form_data.find(p => p.parameter_name === paramName);
                    if (param) {
                        // Parse value and unit if present
                        const parts = input.value.trim().split(/\s+/);
                        param.parameter_value = parts[0] || input.value;
                        if (parts.length > 1) {
                            param.parameter_unit = parts.slice(1).join(' ');
                        }
                    }
                }
            });

            try {
                const response = await fetchWithAuth(`/api/logs?id=${editingLog.id}`, {
                    method: 'PATCH',
                    body: JSON.stringify({
                        performed_at: new Date(dateInput.value).toISOString(),
                        notes: notesInput.value || null,
                        sets: editingLog.sets
                    })
                });

                showToast('Session updated', 'success');
                closeEditSessionModal();
                await loadHistory();

            } catch (error) {
                console.error('Error updating session:', error);
                showToast('Failed to update session', 'error');
            }
        }

        /**
         * Delete the entire session.
         */
        async function deleteSession() {
            if (!editingLog) return;

            if (!confirm('Are you sure you want to delete this entire session? This cannot be undone.')) {
                return;
            }

            try {
                await fetchWithAuth(`/api/logs?id=${editingLog.id}`, {
                    method: 'DELETE'
                });

                showToast('Session deleted', 'success');
                closeEditSessionModal();
                await loadHistory();

            } catch (error) {
                console.error('Error deleting session:', error);
                showToast('Failed to delete session', 'error');
            }
        }

        function formatTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return 'just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;

            return formatDateWithZone(date);
        }

        /**
         * Format date as: ddd m/d/yy h:mm tt tz (e.g., "Mon 1/15/24 3:45 PM EST")
         */
        function formatMessageDateTime(date) {
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const dayName = days[date.getDay()];
            const month = date.getMonth() + 1;
            const day = date.getDate();
            const year = String(date.getFullYear()).slice(-2);
            let hours = date.getHours();
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12 || 12;

            // Get timezone abbreviation
            let tz = '';
            try {
                const tzParts = new Intl.DateTimeFormat('en-US', { timeZoneName: 'short' }).formatToParts(date);
                const tzPart = tzParts.find(p => p.type === 'timeZoneName');
                if (tzPart) tz = tzPart.value;
            } catch (e) {
                tz = 'local';
            }

            return `sent: ${dayName} ${month}/${day}/${year} ${hours}:${minutes} ${ampm} ${tz}`;
        }

        function formatDateTimeWithZone(date, options = {}) {
            const baseOptions = { timeZoneName: 'short', ...options };
            try {
                return new Intl.DateTimeFormat(undefined, baseOptions).format(date);
            } catch (error) {
                return new Intl.DateTimeFormat('en-US', {
                    ...baseOptions,
                    timeZone: 'America/New_York'
                }).format(date);
            }
        }

        function formatDateWithZone(date, options = {}) {
            return formatDateTimeWithZone(date, {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                ...options
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Save the current session and attempt immediate sync.
         * If sync fails, session is queued in localStorage for later retry.
         */
        async function saveSession(notes) {
            const hasNotes = notes && notes.trim().length > 0;
            currentSession.notes = hasNotes ? notes.trim() : null;

            // Apply backdate if user changed the date/time
            const backdateInput = document.getElementById('backdateInput');
            if (backdateInput.value) {
                const backdateISO = new Date(backdateInput.value).toISOString();
                currentSession.date = backdateISO;
                // Update all set timestamps to match the session date
                currentSession.sets.forEach(set => {
                    set.performed_at = backdateISO;
                });
            }

            // Add to offline queue
            offlineQueue.push(currentSession);
            saveOfflineQueue();
            updateSyncBadge();

            // Try to sync immediately if online
            let syncSucceeded = false;
            try {
                await syncOfflineQueue();
                syncSucceeded = (offlineQueue.length === 0); // Check if queue is empty after sync
            } catch (error) {
                console.error('Sync failed, session queued for later:', error);
            }

            // Add to local history so exercise list shows "Done today" immediately
            const savedSession = { ...currentSession };
            allHistory.unshift({
                id: savedSession.sessionId,
                exercise_id: savedSession.exerciseId,
                exercise_name: savedSession.exerciseName,
                performed_at: savedSession.date || new Date().toISOString(),
                sets: savedSession.sets,
                notes: savedSession.notes
            });

            closeNotesModal();
            document.getElementById('sessionNotes').value = '';
            currentSession = null;
            currentExercise = null;
            showView('picker');

            // Re-render exercise list to show updated "Done today" status
            renderExerciseList(allExercises);

            // Show toast with note status
            const noteStatus = hasNotes ? 'with notes' : 'no notes';
            showToast(`Saved (${noteStatus})`);
        }

        // Offline queue management
        function loadOfflineQueue() {
            const stored = localStorage.getItem('pt_offline_queue');
            if (stored) {
                try {
                    const rawQueue = JSON.parse(stored);

                    /**
                     * MIGRATION CODE - CAN BE REMOVED AFTER ALL USERS MIGRATED (est. 2026-03)
                     *
                     * Migrates old session format to new format.
                     * Old bug: Hold exercises created multiple sets (one per rep) with reps=null.
                     * Fix: Collapse into single set with correct rep count.
                     *
                     * This migration preserves all clinical data that was logged before the fix.
                     * Once all users have migrated their offline queues, this code can be safely removed.
                     */
                    offlineQueue = rawQueue.map((session, sessionIdx) => {
                        // Check if this is an old format session (missing set_number)
                        if (session.sets && session.sets.length > 0) {
                            const firstSet = session.sets[0];

                            // Old format: has "timestamp" instead of "performed_at", missing "set_number"
                            if (firstSet.timestamp && !firstSet.set_number) {
                                console.log('Migrating old format session:', session.sessionId);

                                // Check if this is a hold exercise (multiple sets with reps: null, seconds: X)
                                // This was the bug - each hold created a separate set
                                const allSetsHaveNullRepsAndSeconds = session.sets.every(s =>
                                    (s.reps === null || s.reps === undefined) &&
                                    (s.seconds !== null && s.seconds !== undefined && s.seconds > 0)
                                );

                                if (allSetsHaveNullRepsAndSeconds) {
                                    // COLLAPSE: multiple sets ‚Üí 1 set with reps = count
                                    const holdSeconds = session.sets[0].seconds;
                                    const totalReps = session.sets.length;

                                    console.log(`Collapsing ${totalReps} hold sets into 1 set (${totalReps} reps √ó ${holdSeconds}s)`);

                                    const migratedSets = [{
                                        set_number: 1,
                                        reps: totalReps,
                                        seconds: holdSeconds,
                                        distance_feet: null,
                                        side: session.sets[0].side || null,
                                        form_data: null,
                                        manual_log: false,
                                        partial_rep: false,
                                        performed_at: session.sets[0].timestamp || session.date
                                    }];

                                    return {
                                        ...session,
                                        sets: migratedSets
                                    };
                                } else {
                                    // Normal migration: just add new fields
                                    const migratedSets = session.sets.map((set, idx) => ({
                                        set_number: idx + 1,
                                        reps: set.reps || null,
                                        seconds: set.seconds || null,
                                        distance_feet: null,
                                        side: set.side || null,
                                        form_data: null,
                                        manual_log: false,
                                        partial_rep: false,
                                        performed_at: set.timestamp || session.date
                                    }));

                                    return {
                                        ...session,
                                        sets: migratedSets
                                    };
                                }
                            }
                        }
                        return session; // Return unchanged if already in new format
                    });

                    // Save migrated queue
                    if (JSON.stringify(rawQueue) !== JSON.stringify(offlineQueue)) {
                        saveOfflineQueue();
                        console.log('Migrated old sessions to new format');
                    }
                    // END MIGRATION CODE - Can be removed after all users migrated (est. 2026-03)
                } catch (e) {
                    console.error('Error loading offline queue:', e);
                    offlineQueue = [];
                }
            }
        }

        function saveOfflineQueue() {
            localStorage.setItem('pt_offline_queue', JSON.stringify(offlineQueue));
        }

        function updateSyncBadge() {
            // Use the comprehensive sync status UI function
            updateSyncStatusUI();
        }

        async function syncOfflineQueue() {
            if (offlineQueue.length === 0) {
                showToast('Nothing to sync!', '');
                return;
            }

            let successCount = 0;
            let failCount = 0;

            for (const session of [...offlineQueue]) {
                try {
                    // Use stored activity type, or fallback to guessing from data
                    let activityType = session.activityType || 'reps';
                    if (!session.activityType && session.sets && session.sets.length > 0) {
                        // Fallback for old sessions without activityType
                        const firstSet = session.sets[0];
                        if (firstSet.distance_feet != null && firstSet.distance_feet > 0) {
                            activityType = 'distance';
                        } else if (firstSet.seconds != null && firstSet.seconds > 0) {
                            activityType = (firstSet.reps != null && firstSet.reps > 0) ? 'hold' : 'duration';
                        }
                    }

                    const apiSession = {
                        exercise_id: session.exerciseId || null,
                        exercise_name: session.exerciseName,
                        activity_type: activityType,
                        notes: session.notes || null,
                        performed_at: session.date,
                        client_mutation_id: session.sessionId,
                        sets: session.sets.map(set => ({
                            set_number: set.set_number,
                            reps: set.reps || null,
                            seconds: set.seconds || null,
                            distance_feet: set.distance_feet || null,
                            side: set.side || null,
                            form_data: set.form_data || null,
                            manual_log: set.manual_log || false,
                            partial_rep: set.partial_rep || false,
                            performed_at: set.performed_at || session.date
                        }))
                    };

                    const response = await fetchWithAuth('/api/logs', {
                        method: 'POST',
                        body: JSON.stringify(apiSession)
                    });

                    // Success or duplicate - remove from queue
                    offlineQueue = offlineQueue.filter(s => s.sessionId !== session.sessionId);
                    successCount++;

                } catch (error) {
                    console.error('Failed to sync session:', session.sessionId, error);

                    // Handle 409 duplicate as success (session already exists in DB)
                    if (error.message && error.message.includes('409')) {
                        offlineQueue = offlineQueue.filter(s => s.sessionId !== session.sessionId);
                        successCount++;
                        console.log('Removed duplicate session from queue:', session.sessionId);
                    } else {
                        // Show detailed error in toast for debugging
                        showToast(`Sync error: ${error.message || error}`, 'error', 5000);
                        failCount++;
                    }
                }
            }

            saveOfflineQueue();
            updateSyncBadge();

            if (failCount === 0) {
                showToast(`‚úì Synced ${successCount} sessions successfully!`, 'success');
            } else {
                showToast(`Synced ${successCount} sessions. ${failCount} failed (will retry later).`, 'error');
            }

            // Reload history and refresh offline cache
            await loadHistory();
            hydrateOfflineCache();
        }

        // View management
        function showView(viewName) {
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));

            if (viewName === 'picker') {
                document.getElementById('pickerView').classList.add('active');
                document.querySelector('[data-view="picker"]').classList.add('active');
            } else if (viewName === 'logger') {
                document.getElementById('loggerView').classList.add('active');
            } else if (viewName === 'history') {
                document.getElementById('historyView').classList.add('active');
                document.querySelector('[data-view="history"]').classList.add('active');
            }
        }

        /**
         * Show a toast notification (brief message that fades away).
         * Better UX than blocking alerts.
         * @param {string} message - The message to display
         * @param {string} type - 'success', 'error', or default (neutral)
         * @param {number} duration - How long to show in ms (default 3000)
         */
        function showToast(message, type = '', duration = 3000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;

            container.appendChild(toast);

            // Trigger animation
            setTimeout(() => toast.classList.add('show'), 10);

            // Remove after duration
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => container.removeChild(toast), 300);
            }, duration);
        }

        // Search
        function handleSearch(query) {
            if (!query.trim()) {
                renderExerciseList(allExercises);
                return;
            }

            const lowerQuery = query.toLowerCase();
            const filtered = allExercises.filter(ex =>
                ex.canonical_name.toLowerCase().includes(lowerQuery) ||
                ex.description.toLowerCase().includes(lowerQuery)
            );

            renderExerciseList(filtered);
        }

        // Event handlers
        function bindEventHandlers() {
            document.body.addEventListener('pointerup', () => {
                ensureAudioReady();
            }, { once: true });

            // Auth form
            document.getElementById('authForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                const email = document.getElementById('emailInput').value;
                const password = document.getElementById('passwordInput').value;
                const errorEl = document.getElementById('authError');

                try {
                    await signIn(email, password);
                    errorEl.textContent = '';
                } catch (error) {
                    errorEl.textContent = error.message;
                }
            });

            // Forgot password link
            document.getElementById('forgotPasswordLink').addEventListener('click', (e) => {
                e.preventDefault();
                showForgotPasswordModal();
            });

            // Back to login link
            document.getElementById('backToLoginLink').addEventListener('click', (e) => {
                e.preventDefault();
                hideForgotPasswordModal();
                showAuthModal();
            });

            // Forgot password form
            document.getElementById('forgotPasswordForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                const email = document.getElementById('resetEmailInput').value;
                const errorEl = document.getElementById('resetError');
                const submitBtn = e.target.querySelector('button[type="submit"]');

                submitBtn.disabled = true;
                submitBtn.textContent = 'Sending...';

                try {
                    const { error } = await requestPasswordReset(email);
                    if (error) throw error;
                    errorEl.style.color = '#28a745';
                    errorEl.textContent = 'Check your email for the reset link.';
                } catch (error) {
                    errorEl.style.color = '';
                    errorEl.textContent = error.message;
                } finally {
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Send Reset Link';
                }
            });

            // New password form
            document.getElementById('newPasswordForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                const newPassword = document.getElementById('newPasswordInput').value;
                const confirmPassword = document.getElementById('confirmPasswordInput').value;
                const errorEl = document.getElementById('newPasswordError');

                if (newPassword !== confirmPassword) {
                    errorEl.textContent = 'Passwords do not match.';
                    return;
                }

                const submitBtn = e.target.querySelector('button[type="submit"]');
                submitBtn.disabled = true;
                submitBtn.textContent = 'Updating...';

                try {
                    const { error } = await updatePassword(newPassword);
                    if (error) throw error;
                    hideNewPasswordModal();
                    showToast('Password updated successfully!', 'success');
                } catch (error) {
                    errorEl.textContent = error.message;
                } finally {
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Update Password';
                }
            });

            // Search
            document.getElementById('searchInput').addEventListener('input', (e) => {
                handleSearch(e.target.value);
            });

            // Notes form
            document.getElementById('notesForm').addEventListener('submit', (e) => {
                e.preventDefault();
                const notes = document.getElementById('sessionNotes').value;
                saveSession(notes);
                document.getElementById('sessionNotes').value = '';
            });

            // Backdate input change - show warning when date differs from session start
            document.getElementById('backdateInput').addEventListener('change', () => {
                const input = document.getElementById('backdateInput');
                const warning = document.getElementById('backdateWarning');
                if (input.value) {
                    const selected = new Date(input.value).getTime();
                    const sessionStart = new Date(currentSession.date).getTime();
                    // Show warning if more than 2 minutes different from session start
                    if (Math.abs(selected - sessionStart) > 120000) {
                        warning.classList.remove('hidden');
                    } else {
                        warning.classList.add('hidden');
                    }
                }
            });

            /**
             * Bind iOS-safe pointer event handlers to elements with data-action attributes.
             *
             * iOS Safari/PWA does not reliably trigger onclick handlers on dynamically created elements.
             * This function binds pointerup events (which work consistently on iOS touch and desktop mouse)
             * and keyboard events for accessibility.
             */
            document.body.addEventListener('pointerup', (e) => {
                const target = e.target.closest('[data-action]');
                if (!target) return;

                // Prevent parent action handlers from firing
                if (target.dataset.stopPropagation === 'true') {
                    e.stopPropagation();
                }

                // For modal backdrops: only trigger if click was directly on the element (not children)
                if (target.dataset.requireSelf === 'true' && e.target !== target) {
                    return;
                }

                const action = target.dataset.action;

                switch (action) {
                    case 'show-view':
                        showView(target.dataset.view);
                        break;
                    case 'select-exercise':
                        selectExercise(target.dataset.id);
                        break;
                    case 'showExerciseDetails':
                        showExerciseDetails(target.dataset.id);
                        break;
                    case 'closeExerciseDetailsModal':
                        closeExerciseDetailsModal();
                        break;
                    case 'counter-tap':
                    case 'counter-increase':
                        increaseCounter();
                        break;
                    case 'counter-decrease':
                        decreaseCounter();
                        break;
                    case 'timer-start-pause':
                        toggleTimer();
                        break;
                    case 'timer-reset':
                        resetTimer();
                        break;
                    case 'previous-set':
                        previousSet();
                        break;
                    case 'show-log-set-modal':
                        showLogSetModal();
                        break;
                    case 'show-next-set-modal':
                        showNextSetModal();
                        break;
                    case 'close-next-set-modal':
                        closeNextSetModal();
                        break;
                    case 'edit-next-set':
                        editNextSet();
                        break;
                    case 'confirm-next-set':
                        confirmNextSet();
                        break;
                    case 'finish-session':
                        finishSession();
                        break;
                    case 'back-to-picker':
                        currentSession = null;
                        currentExercise = null;
                        showView('picker');
                        break;
                    case 'close-log-set-modal':
                        closeLogSetModal();
                        break;
                    case 'save-logged-set':
                        saveLoggedSet();
                        break;
                    case 'log-set-select-side':
                        selectLogSetSide(target.dataset.side);
                        break;
                    case 'close-notes-modal':
                        closeNotesModal();
                        break;
                    case 'toggle-backdate':
                        toggleBackdate();
                        break;
                    case 'cancel-session':
                        if (confirm('Cancel without saving?')) {
                            closeNotesModal();
                            currentSession = null;
                            currentExercise = null;
                            document.getElementById('sessionNotes').value = '';
                            showView('picker');
                        }
                        break;
                    case 'show-messages':
                        showMessagesModal();
                        break;
                    case 'close-messages-modal':
                        closeMessagesModal();
                        break;
                    case 'send-message':
                        sendMessage();
                        break;
                    case 'archive-message':
                        archiveMessage(target.dataset.id);
                        break;
                    case 'undo-send-message':
                        undoSendMessage(target.dataset.id);
                        break;
                    case 'manual-sync':
                        toggleHamburger(); // Close menu
                        syncOfflineQueue();
                        break;
                    case 'show-debug':
                        toggleHamburger(); // Close menu
                        showDebugInfo();
                        break;
                    case 'toggle-hamburger':
                        toggleHamburger();
                        break;
                    case 'select-side':
                        selectSide(target.dataset.side);
                        break;
                    case 'sign-out':
                        toggleHamburger(); // Close menu
                        signOut();
                        break;
                    case 'reload':
                        reloadPage();
                        break;
                    case 'edit-session':
                        openEditSessionModal(target.dataset.logId);
                        break;
                    case 'close-edit-session-modal':
                        closeEditSessionModal();
                        break;
                    case 'save-edit-session':
                        saveEditSession();
                        break;
                    case 'delete-session':
                        deleteSession();
                        break;
                    case 'add-edit-session-set':
                        addEditSessionSet();
                        break;
                    case 'delete-edit-session-set':
                        deleteEditSessionSet(parseInt(target.dataset.setIndex));
                        break;
                    case 'toggle-pocket-mode':
                        togglePocketMode();
                        break;
                    case 'pocket-tap':
                        handlePocketTap();
                        break;
                }
            });

            // Checkbox `change` event is reliable on iOS Safari (unlike pointerup for checkboxes).
            // Listen on document for delegation since the checkbox is in a modal.
            document.addEventListener('change', (e) => {
                if (e.target.dataset.action === 'toggle-email-notify') {
                    toggleEmailNotifications(e.target.checked);
                }
            });
        }

        // Utility functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function generateSessionId() {
            return `session_${Date.now()}_${crypto.randomUUID().slice(0, 9)}`;
        }

        // Start the app
        init();
    </script>

    <!-- Pocket Mode overlay: fullscreen eyes-free exercise tracking -->
    <div id="pocketOverlay" class="pocket-overlay">
        <!-- Close button: top-left, outside tap zone, 44px minimum touch target -->
        <button class="pocket-close" data-action="toggle-pocket-mode" aria-label="Exit pocket mode">‚úï</button>
        <!-- Main tap zone: counter taps or timer start/pause -->
        <div class="pocket-pad" data-action="pocket-tap">
            <div class="pocket-label" id="pocketLabel">0</div>
            <div class="pocket-meta" id="pocketMeta"></div>
            <div class="pocket-hint" id="pocketHint">Tap to count</div>
        </div>
    </div>

    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js');
            let refreshing = false;
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                if (!refreshing) { refreshing = true; window.location.reload(); }
            });
        }
    </script>

    <!-- Vercel Speed Insights -->
    <script>
        window.si = window.si || function () { (window.siq = window.siq || []).push(arguments); };
    </script>
    <script defer src="/_vercel/speed-insights/script.js"></script>
    <!-- Vercel Web Analytics -->
    <script>
        window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
    </script>
    <script defer src="/_vercel/insights/script.js"></script>

</body>
</html>
