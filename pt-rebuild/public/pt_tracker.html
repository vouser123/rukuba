<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="PT Tracker">
    <link rel="manifest" href="manifest-pt.json">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%23007AFF' rx='20'/><text x='50' y='70' font-size='60' text-anchor='middle' fill='white'>üí™</text></svg>">
    <meta name="theme-color" content="#007AFF" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
    <title>PT Exercise Tracker</title>
    <style>
        :root {
            --ios-blue: #007AFF;
            --ios-red: #FF3B30;
            --ios-green: #34C759;
            --ios-orange: #FF9500;
            --ios-gray: #8E8E93;
            --ios-background: #F2F2F7;
            --bg-primary: #FFFFFF;
            --bg-secondary: #F2F2F7;
            --text-primary: #000000;
            --text-secondary: #3a3a3c;
            --border-color: rgba(0,0,0,0.1);
            --modal-bg: #FFFFFF;
            --input-bg: #FFFFFF;
            --shadow: rgba(0,0,0,0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --ios-background: #000000;
                --bg-primary: #1c1c1e;
                --bg-secondary: #2c2c2e;
                --text-primary: #FFFFFF;
                --text-secondary: #adadb3; /* Improved from #98989d for better WCAG contrast */
                --border-color: rgba(255,255,255,0.15);
                --modal-bg: #1c1c1e;
                --input-bg: #2c2c2e;
                --shadow: rgba(0,0,0,0.5);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: var(--ios-background);
            color: var(--text-primary);
            touch-action: manipulation;
            user-select: none;
            overflow-x: hidden;
            padding-bottom: 100px;
        }

        /* Header */
        .header {
            background: var(--bg-primary);
            padding: 16px 20px;
            box-shadow: 0 1px 0 rgba(0,0,0,0.08);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
            letter-spacing: -0.5px;
        }

        .exercise-name {
            font-size: 17px;
            color: var(--ios-blue);
            font-weight: 600;
            letter-spacing: -0.3px;
        }

        /* Main Counter View */
        .counter-view {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: calc(100vh - 250px);
            padding: 20px;
        }

        .set-info {
            font-size: 17px;
            color: var(--ios-gray);
            margin-bottom: 20px;
        }

        .counter-display {
            width: min(320px, 85vw);
            height: min(320px, 85vw);
            border-radius: 50%;
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 72px;
            font-weight: 700;
            color: var(--ios-blue);
            box-shadow: 0 4px 20px rgba(0, 122, 255, 0.3);
            margin-bottom: 30px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            /* Mobile Safari touch fixes for large tap target */
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }

        .counter-display:active {
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(0, 122, 255, 0.2);
        }

        .timer-display {
            font-size: 64px;
            font-weight: 700;
            color: var(--ios-blue);
            margin-bottom: 20px;
        }

        .timer-display.warning {
            color: var(--ios-orange);
        }

        .timer-display.danger {
            color: var(--ios-red);
        }

        .target-info {
            font-size: 17px;
            color: var(--ios-gray);
            margin-bottom: 30px;
        }

        .remaining-info {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            text-align: center;
            margin-bottom: 12px;
        }

        .progress-bar-container {
            width: 100%;
            max-width: 300px;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--ios-blue), var(--ios-green));
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 12px;
            width: 100%;
            max-width: 400px;
            padding: 0 20px;
        }

        .control-btn {
            flex: 1;
            padding: 10px 12px;
            font-size: 15px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
            /* Mobile Safari touch fixes */
            -webkit-appearance: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            min-height: 44px; /* Apple HIG minimum touch target */
            -webkit-user-select: none;
            user-select: none;
        }

        .control-btn:active {
            transform: scale(0.98);
            opacity: 0.8;
        }

        /* Force cursor pointer on all interactive elements */
        button,
        [data-action],
        [data-actions],
        [data-href],
        [data-reload],
        [data-open-url],
        [data-click-target],
        .pill,
        .history-item {
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        .btn-primary {
            background: var(--ios-blue);
            color: white;
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.25);
            font-weight: 600;
            letter-spacing: -0.2px;
        }

        .btn-secondary {
            background: rgba(0, 122, 255, 0.08);
            color: var(--ios-blue);
            box-shadow: none;
            font-weight: 600;
            letter-spacing: -0.2px;
        }

        .btn-success {
            background: var(--ios-green);
            color: white;
            box-shadow: 0 2px 8px rgba(52, 199, 89, 0.25);
            font-weight: 600;
            letter-spacing: -0.2px;
        }

        .btn-danger {
            background: var(--ios-red);
            color: white;
            box-shadow: 0 2px 8px rgba(255, 59, 48, 0.25);
            font-weight: 600;
            letter-spacing: -0.2px;
        }

        /* Footer */
        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--modal-bg);
            backdrop-filter: blur(20px);
            padding: 12px;
            padding-bottom: max(12px, env(safe-area-inset-bottom));
            border-top: 0.5px solid rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 12px;
            z-index: 999;
        }

        .footer button {
            flex: 1;
            padding: 12px;
            font-size: 15px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.1s, opacity 0.2s;
        }

        .footer button:active {
            transform: scale(0.98);
            opacity: 0.8;
        }

        /* iOS Bottom Sheet Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.4);
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.25s ease;
        }

        .modal.active {
            display: block;
            opacity: 1;
        }

        .modal-content {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--modal-bg);
            border-radius: 20px 20px 0 0;
            padding: 0;
            max-height: 90vh;
            overflow-y: auto;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 -2px 20px var(--shadow);
            /* iOS Safari modal scroll fixes */
            -webkit-overflow-scrolling: touch; /* Smooth momentum scrolling on iOS */
            overscroll-behavior: contain; /* Prevent scroll chaining */
        }

        .modal.active .modal-content {
            transform: translateY(0);
        }

        .modal-drag-handle {
            width: 36px;
            height: 5px;
            background: rgba(60, 60, 67, 0.3);
            border-radius: 3px;
            margin: 8px auto 12px;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 600;
            letter-spacing: -0.4px;
            text-align: center;
            padding: 0 20px 20px;
            color: var(--text-primary);
            border-bottom: 0.5px solid rgba(0,0,0,0.1);
        }

        .modal-form {
            padding: 20px;
        }

        .modal-input, .modal-select {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 17px; /* Prevents iOS zoom on focus (must be ‚â•16px) */
            margin-bottom: 12px;
            font-family: inherit;
            background: var(--input-bg);
            color: var(--text-primary);
            box-shadow: 0 1px 3px var(--shadow);
            /* Mobile Safari input fixes */
            -webkit-appearance: none;
            -webkit-tap-highlight-color: transparent;
        }

        .modal-input:focus, .modal-select:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--ios-blue);
        }

        /* iOS-specific input type fixes */
        input[type="number"], input[type="text"], textarea {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        /* Prevent iOS Safari from adding default styling to buttons */
        input[type="submit"], input[type="button"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            padding: 0 20px 20px;
        }

        .modal-buttons button {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 12px;
            font-size: 17px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.1s;
        }

        .modal-buttons button:active {
            transform: scale(0.98);
            opacity: 0.8;
        }

        .modal-save {
            background: var(--ios-blue);
            color: white;
        }

        .modal-cancel {
            background: var(--bg-primary);
            color: var(--ios-blue);
            box-shadow: 0 1px 3px var(--shadow);
        }

        /* iOS Action Sheet */
        .action-sheet-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.25s ease;
        }

        .action-sheet-backdrop.active {
            display: block;
            opacity: 1;
        }

        .action-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: transparent;
            z-index: 3001;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 8px;
        }

        .action-sheet.active {
            transform: translateY(0);
        }

        .action-sheet-content {
            background: var(--modal-bg);
            backdrop-filter: blur(20px);
            border-radius: 14px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .action-sheet-message {
            padding: 20px;
            text-align: center;
            color: var(--ios-gray);
            font-size: 13px;
            border-bottom: 0.5px solid var(--border-color);
        }

        .action-sheet-button {
            width: 100%;
            padding: 16px;
            background: transparent;
            border: none;
            font-size: 20px;
            cursor: pointer;
            border-bottom: 0.5px solid var(--border-color);
            color: var(--ios-blue);
            transition: background 0.2s;
        }

        .action-sheet-button:last-child {
            border-bottom: none;
        }

        .action-sheet-button:active {
            background: rgba(0, 0, 0, 0.05);
        }

        .action-sheet-button.destructive {
            color: var(--ios-red);
            font-weight: 600;
        }

        .action-sheet-cancel {
            background: var(--modal-bg);
            backdrop-filter: blur(20px);
            border-radius: 14px;
            width: 100%;
            padding: 16px;
            border: none;
            font-size: 20px;
            font-weight: 600;
            color: var(--ios-blue);
            cursor: pointer;
            transition: background 0.2s;
        }

        .action-sheet-cancel:active {
            background: rgba(0, 0, 0, 0.05);
        }

        .history-section {
            margin-bottom: 16px;
        }

        .history-heading {
            font-size: 15px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .history-list {
            background: var(--bg-primary);
            border-radius: 12px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
            padding: 12px;
        }

        .history-item {
            padding: 10px 8px;
            border-bottom: 0.5px solid var(--border-color);
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-meta {
            font-size: 12px;
            color: var(--ios-gray);
            margin-top: 4px;
        }

        .pill {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 12px;
            background: rgba(0, 122, 255, 0.1);
            color: var(--ios-blue);
            margin-right: 6px;
        }

        .pocket-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 4000;
        }

        .pocket-overlay.active {
            display: flex;
        }

        .pocket-pad {
            width: min(420px, 95vw);
            height: min(500px, 80vh);
            border-radius: 28px;
            background: var(--bg-primary);
            color: var(--ios-blue);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            font-size: 56px;
            font-weight: 800;
            box-shadow: 0 12px 40px rgba(0,0,0,0.35);
            text-align: center;
            padding: 20px;
        }

        .pocket-meta {
            color: #3a3a3c;
            font-size: 16px;
            font-weight: 600;
        }

        .pocket-close {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 44px;
            height: 44px;
            background: rgba(0,0,0,0.75);
            color: white;
            border: none;
            border-radius: 22px;
            font-size: 20px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 4001;
        }

        .hidden {
            display: none !important;
        }

        /* Auth Guard Overlay */
        #auth-guard-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #auth-guard-overlay h2 {
            font-size: 24px;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        #auth-guard-overlay p {
            color: var(--text-secondary);
            text-align: center;
            line-height: 1.5;
            max-width: 400px;
        }

        #auth-guard-overlay.auth-verified {
            display: none;
        }

        #auth-guard-overlay.auth-checking {
            display: none;
        }

        .auth-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.45);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .auth-modal.active {
            opacity: 1;
            pointer-events: all;
        }

        .auth-modal-content {
            background: var(--bg-primary);
            border-radius: 16px;
            width: min(420px, 90vw);
            padding: 20px;
            box-shadow: 0 18px 50px rgba(0, 0, 0, 0.25);
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        .auth-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .auth-modal-title {
            font-size: 20px;
            font-weight: 700;
        }

        .auth-modal-close {
            border: none;
            background: transparent;
            font-size: 24px;
            line-height: 1;
            cursor: pointer;
            color: var(--text-secondary);
        }

        .auth-modal-subtitle {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .auth-modal-actions {
            display: flex;
            gap: 12px;
        }

        .auth-modal-actions button {
            flex: 1;
            min-height: 48px;
        }

        /* Body Heatmap - REPLACED BY REHAB COVERAGE VIEW
        .body-diagram {
            position: relative;
            width: 200px;
            height: 380px;
            margin: 20px auto;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 380"><ellipse cx="100" cy="40" rx="25" ry="30" fill="%23e0e0e0"/><rect x="75" y="65" width="50" height="80" rx="10" fill="%23e0e0e0"/><rect x="45" y="70" width="30" height="60" rx="8" fill="%23e0e0e0"/><rect x="125" y="70" width="30" height="60" rx="8" fill="%23e0e0e0"/><rect x="70" y="145" width="60" height="40" rx="8" fill="%23e0e0e0"/><rect x="65" y="185" width="30" height="90" rx="8" fill="%23e0e0e0"/><rect x="105" y="185" width="30" height="90" rx="8" fill="%23e0e0e0"/><rect x="60" y="275" width="35" height="100" rx="8" fill="%23e0e0e0"/><rect x="105" y="275" width="35" height="100" rx="8" fill="%23e0e0e0"/></svg>') no-repeat center;
            background-size: contain;
        }

        .body-part-overlay {
            position: absolute;
            border-radius: 8px;
            transition: all 0.3s;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .heat-none { background: rgba(142, 142, 147, 0.2); }
        .heat-low { background: rgba(0, 122, 255, 0.4); }
        .heat-medium { background: rgba(255, 149, 0, 0.5); }
        .heat-high { background: rgba(255, 59, 48, 0.6); }
        .heat-very-high { background: rgba(255, 59, 48, 0.8); }

        .body-part-overlay:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .heatmap-legend {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin: 20px 0;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        */
    </style>
</head>
<body>
    <!-- Auth Guard Overlay -->
    <div id="auth-guard-overlay" class="auth-checking">
        <h2>üîê Authentication Required</h2>
        <p>You must be signed in to access the PT Tracker.</p>
        <button id="auth-guard-signin-btn" class="btn-primary" style="margin-top: 16px; padding: 12px 32px; font-size: 16px;">Sign In</button>
    </div>

    <div class="header">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;">
            <div>
                <h1 style="margin: 0; display: inline;"><span style="display: inline-block; background: var(--ios-blue); color: white; padding: 4px 10px; border-radius: 6px; font-size: 20px; font-weight: 700; margin-right: 8px;">PT</span>Exercise Tracker</h1>
                <span style="font-size: 11px; color: var(--ios-gray); margin-left: 6px; vertical-align: super;" id="header-version">v1.4.0</span>
            </div>
            <div id="streak-display" style="font-size: 14px; font-weight: 600; color: var(--ios-orange);"></div>
        </div>
        <div style="display: flex; align-items: center; justify-content: space-between;">
            <div class="exercise-name" id="exercise-name" data-action="showQuickSwitcher" role="button" tabindex="0" style="cursor: pointer;">No Exercise Selected ‚ñæ</div>
            <div style="display: flex; gap: 4px; align-items: center;">
                <div id="notes-indicator" style="display: none; position: relative; padding: 4px 8px;">
                    <span style="font-size: 16px; font-weight: 600; color: var(--ios-blue);">üí¨</span>
                    <span id="notes-count-badge" style="position: absolute; top: 0; right: 0; background: var(--ios-red); color: white; border-radius: 10px; padding: 2px 6px; font-size: 10px; font-weight: 600; min-width: 18px; text-align: center;"></span>
                </div>
                <button data-action="showWeeklyStats" style="background: transparent; border: none; font-size: 20px; cursor: pointer; padding: 4px 8px;">üìà</button>
                <button data-action="showExerciseDetailsModal" style="background: transparent; border: none; font-size: 20px; cursor: pointer; padding: 4px 8px;">üìã</button>
                <button data-action="toggleHamburgerMenu" style="background: transparent; border: none; font-size: 22px; cursor: pointer; padding: 4px 8px;">‚ò∞</button>
            </div>
        </div>
    </div>

    <!-- Hamburger Menu Overlay & Slide-out -->
    <div id="hamburger-overlay" data-action="toggleHamburgerMenu" role="button" tabindex="0" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 9998;"></div>
    <div id="hamburger-menu" style="display: none; position: fixed; top: 0; right: 0; bottom: 0; width: 280px; background: var(--bg-secondary); z-index: 9999; box-shadow: -2px 0 8px rgba(0, 0, 0, 0.3); overflow-y: auto;">
        <div style="padding: 20px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center;">
            <div style="font-size: 18px; font-weight: 600;">Menu</div>
            <button data-action="toggleHamburgerMenu" style="background: transparent; border: none; color: var(--ios-blue); font-size: 16px; cursor: pointer; padding: 8px;">Close</button>
        </div>
        <div style="padding: 0;">
            <!-- Auth Status -->
            <div id="menu-auth-section">
                <!-- Signed In State -->
                <div id="menu-auth-signed-in" style="display: none;">
                    <div style="padding: 16px 20px; border-bottom: 1px solid var(--border-color); background: var(--bg-primary);">
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Signed in as</div>
                        <div id="menu-auth-email" style="font-size: 14px; font-weight: 500; color: var(--text-primary); margin-bottom: 12px; word-break: break-all;"></div>
                        <button id="menu-signout-btn" style="width: 100%; padding: 10px; background: var(--ios-red); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">Sign Out</button>
                    </div>
                </div>
                <!-- Signed Out State -->
                <div id="menu-auth-signed-out" style="display: none;">
                    <div style="padding: 16px 20px; border-bottom: 1px solid var(--border-color); background: var(--bg-primary);">
                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">Cloud sync disabled</div>
                        <button id="menu-signin-btn" style="width: 100%; padding: 10px; background: var(--ios-blue); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">Sign In</button>
                    </div>
                </div>
            </div>

            <div data-actions="showNotesModal,toggleHamburgerMenu" role="button" tabindex="0" style="padding: 16px 20px; border-bottom: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px; width: 24px; text-align: center; position: relative;">
                    üí¨
                    <span id="menu-notes-badge" style="display: none; position: absolute; top: -4px; right: -4px; background: var(--ios-red); color: white; border-radius: 10px; padding: 2px 6px; font-size: 10px; font-weight: 600;"></span>
                </span>
                <span>Notes</span>
            </div>
            <div data-href="pt_report.html" role="button" tabindex="0" style="padding: 16px 20px; border-bottom: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px; width: 24px; text-align: center;">‚úèÔ∏è</span>
                <span>PT Editor Mode</span>
            </div>
            <div data-actions="showSettings,toggleHamburgerMenu" role="button" tabindex="0" style="padding: 16px 20px; border-bottom: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px; width: 24px; text-align: center;">‚öôÔ∏è</span>
                <span>Settings</span>
            </div>
            <div data-actions="exportForPT,toggleHamburgerMenu" role="button" tabindex="0" style="padding: 16px 20px; border-bottom: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px; width: 24px; text-align: center;">üè•</span>
                <span>Export for PT</span>
            </div>
            <div data-actions="importPTModifications,toggleHamburgerMenu" role="button" tabindex="0" style="padding: 16px 20px; border-bottom: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px; width: 24px; text-align: center;">üì®</span>
                <span>Import PT Modifications</span>
            </div>
            <div data-actions="showLibraryDiagnostics,toggleHamburgerMenu" role="button" tabindex="0" style="padding: 16px 20px; border-bottom: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px; width: 24px; text-align: center;">üß™</span>
                <span>Library Debug</span>
            </div>
            <div data-reload="true" role="button" tabindex="0" style="padding: 16px 20px; cursor: pointer; display: flex; align-items: center; gap: 12px;">
                <span style="font-size: 20px; width: 24px; text-align: center;">üîÑ</span>
                <span>Reload</span>
            </div>
        </div>
    </div>

    <!-- Library Debug Modal -->
    <div class="modal" id="library-debug-modal">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Library Debug</div>
            <div style="padding: 16px 20px 20px;">
                <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
                    Snapshot of local + shared library sources to explain count differences.
                </div>
                <div id="library-debug-output" style="white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size: 12px; color: var(--text-primary); background: var(--bg-secondary); padding: 12px; border-radius: 10px;"></div>
                <button class="modal-cancel" style="margin-top: 16px; width: 100%;" data-action="closeLibraryDiagnostics">Close</button>
            </div>
        </div>
    </div>

    <!-- Session Plan -->
    <div id="session-plan-container" style="padding: 12px 15px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); display: none;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
            <div style="font-size: 13px; font-weight: 600; color: var(--text-secondary);">Today's Session</div>
            <button data-action="endSessionEarly" style="background: transparent; border: none; color: var(--ios-red); font-size: 12px; font-weight: 600; cursor: pointer; padding: 4px 8px;">End Session</button>
        </div>
        <div id="session-plan-list" style="display: flex; flex-direction: column; gap: 6px;"></div>
    </div>

    <!-- App Load Warning (shown if module script fails) -->
    <div id="app-load-warning" style="display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.65); z-index: 5000; padding: 20px;">
        <div style="max-width: 420px; margin: 80px auto 0; background: var(--bg-primary); padding: 20px; border-radius: 16px; box-shadow: 0 12px 40px rgba(0,0,0,0.4); text-align: center;">
            <div style="font-size: 18px; font-weight: 700; margin-bottom: 8px;">App failed to load</div>
            <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 16px;">
                The tracker scripts didn‚Äôt initialize. Buttons may not work. Try reloading the page.
            </div>
            <button class="control-btn btn-primary" data-reload="true">Reload</button>
        </div>
    </div>

    <!-- Counter View -->
    <div class="counter-view" id="counter-view">
        <div class="set-info" id="set-info">Tap "Exercises" below to choose</div>
        <div class="remaining-info" id="remaining-info"></div>

        <!-- Side Selector for Unilateral Exercises -->
        <div id="current-side-selector" style="display: none; margin: 16px 0; width: 100%; max-width: 400px;">
            <div style="font-size: 14px; font-weight: 600; margin-bottom: 10px; text-align: center; color: var(--text-secondary);">Working Side:</div>
            <div id="current-side-buttons" style="display: flex; gap: 10px;"></div>
        </div>

        <!-- Counter Mode -->
        <div id="counter-mode" class="hidden">
            <div class="counter-display" id="counter-display" data-action="incrementCounter" role="button" tabindex="0" aria-live="assertive">0</div>
            <div class="target-info" id="target-info">Target: 10 reps</div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
        </div>

        <!-- Timer Mode -->
        <div id="timer-mode" class="hidden">
            <div class="target-info" id="timer-rep-info">Rep 1 of 10</div>
            <div class="timer-display" id="timer-display">00:00</div>
            <div class="target-info" id="timer-target">Target: 10 seconds</div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="timer-progress-bar"></div>
            </div>
            <div class="controls" style="margin-bottom: 20px;">
                <button class="control-btn btn-primary" id="timer-start-btn" data-action="startTimer">Start Timer</button>
                <button class="control-btn btn-danger hidden" id="timer-stop-btn" data-action="stopTimer">Pause</button>
                <button class="control-btn btn-secondary hidden" id="timer-reset-btn" data-action="resetTimer">Reset</button>
            </div>
            <!-- Log partial rep (only shown when paused) -->
            <div class="controls" id="timer-log-controls" style="margin-bottom: 10px; display: none;">
                <button class="control-btn btn-warning" data-action="logPartialTimerRep" style="font-size: 13px; padding: 8px;">‚è±Ô∏è Log This Time & Next Rep</button>
            </div>
        </div>

        <div class="controls hidden" id="main-controls">
            <button class="control-btn btn-secondary" data-action="previousSet">Previous</button>
            <button class="control-btn btn-primary" data-action="showLogSetModal">Log Set</button>
            <button class="control-btn btn-success" id="next-set-btn" data-action="showNextSetModal">Next Set</button>
        </div>
    </div>

    <div class="footer">
        <button class="btn-secondary" data-action="showExerciseList">Exercises</button>
        <button class="btn-secondary" data-action="showHistory">History</button>
        <button class="btn-secondary" data-href="rehab_coverage.html">Coverage</button>
        <button class="btn-secondary" data-action="togglePocketMode" data-action-arg-bool="true">Pocket Tap</button>
    </div>

    <!-- Exercise Selection Modal -->
    <div class="modal" id="exercise-modal" data-action="closeExerciseModal" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Select Exercise</div>
            <div class="modal-form">
                <select class="modal-select" id="exercise-select" onchange="updateExerciseType()"></select>
                <select class="modal-select" id="exercise-type" onchange="updateTargetLabel()">
                    <option value="reps">Rep-based</option>
                    <option value="timed">Timed Reps</option>
                    <option value="hold">Hold</option>
                    <option value="duration">Duration</option>
                    <option value="amrap">AMRAP</option>
                    <option value="distance">Distance</option>
                </select>
                <input type="number" class="modal-input" id="sets-input" placeholder="Number of sets" value="3">
                <input type="number" class="modal-input" id="reps-input" placeholder="Reps per set" value="10">
                <input type="number" class="modal-input" id="target-input" placeholder="Target (seconds or distance)" value="10">
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closeExerciseModal">Cancel</button>
                <button class="modal-save" data-action="saveExercise">Start</button>
            </div>
        </div>
    </div>

    <!-- Exercise List Modal -->
    <div class="modal" id="exercise-list-modal" data-action="closeExerciseList" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">My Exercises</div>

            <!-- Sticky Actions at Top -->
            <div style="padding: 12px 20px; border-bottom: 1px solid var(--border-color); background: var(--modal-bg);">
                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <button class="control-btn btn-primary" data-action="showPlanSessionModal" style="flex: 1; font-size: 14px;">üìÖ Plan Session</button>
                    <button class="control-btn btn-primary" data-action="showLibraryBrowser" style="flex: 1; font-size: 14px;">üìö Browse Library</button>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button class="control-btn btn-secondary" data-action="showArchivedExercises" style="flex: 1; font-size: 13px;" id="archived-btn">üì¶ Archived</button>
                    <button class="control-btn btn-secondary" data-action="showNotesModal" style="flex: 1; font-size: 13px; position: relative;" id="notes-btn">
                        üí¨ Notes
                        <span id="notes-badge" style="display: none; position: absolute; top: 4px; right: 4px; background: var(--ios-red); color: white; border-radius: 10px; padding: 2px 6px; font-size: 10px; font-weight: 600;"></span>
                    </button>
                    <button class="control-btn btn-secondary" data-action="showDataBackup" style="flex: 1; font-size: 13px;">üíæ Data</button>
                </div>
            </div>

            <!-- Scrollable Content -->
            <div class="modal-form" style="max-height: 60vh; overflow-y: auto;">
                <input type="text" class="modal-input" id="exercise-search" placeholder="Search exercises..." oninput="filterExercises()">
                <div id="tag-filter-container" style="margin-bottom: 12px;"></div>
                <div id="recent-exercises-container" style="margin-bottom: 12px;"></div>
                <div class="history-list" id="exercise-list-content"></div>
            </div>
        </div>
    </div>

    <!-- Form Parameters Modal (shown after completing all sets) -->
    <div class="modal" id="form-params-modal" data-action="closeFormParamsModal" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Exercise Parameters</div>
            <div class="modal-form">
                <div style="font-size: 15px; color: var(--ios-gray); margin-bottom: 16px; text-align: center;" id="form-params-subtitle">
                    Enter details for this session
                </div>
                <div id="form-params-fields"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="skipFormParams">Skip</button>
                <button class="modal-save" data-action="saveFormParams">Save & Continue</button>
            </div>
        </div>
    </div>

    <!-- Auth Sign In Modal -->
    <div class="auth-modal" id="auth-modal" role="dialog" aria-modal="true" aria-labelledby="auth-modal-title" aria-hidden="true">
        <div class="auth-modal-content">
            <div class="auth-modal-header">
                <div class="auth-modal-title" id="auth-modal-title">Sign In to Continue</div>
                <button type="button" class="auth-modal-close" id="auth-modal-close" aria-label="Close sign in">√ó</button>
            </div>
            <div class="auth-modal-subtitle">Use your therapist account to sync session data across devices.</div>
            <div id="auth-credential-fields"></div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <input type="checkbox" id="auth-remember" style="width: 20px; height: 20px;">
                <label for="auth-remember" style="font-size: 14px; color: var(--text-secondary); cursor: pointer;">Remember me on this device</label>
            </div>
            <div id="auth-error" style="display: none; color: var(--ios-red); font-size: 14px; text-align: center;"></div>
            <button type="button" id="auth-reset-btn" style="margin-top: 8px; background: none; border: none; color: var(--ios-blue); font-size: 14px; font-weight: 600; cursor: pointer;">Forgot password?</button>
            <div class="auth-modal-actions">
                <button type="button" class="btn-secondary" id="auth-cancel-btn">Cancel</button>
                <button type="button" class="btn-primary" id="auth-signin-btn">Sign In</button>
            </div>
        </div>
    </div>

    <div class="modal" id="session-notes-modal" data-action="closeSessionNotesModal" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Session Notes (Optional)</div>
            <div class="modal-form">
                <textarea class="modal-input" id="session-notes" placeholder="How did it feel? Any pain? Progress notes..." style="min-height: 100px; resize: vertical;"></textarea>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="confirmSkipNotes">Skip Notes</button>
                <button class="modal-save" data-action="saveSessionWithNotes" data-action-arg-source="#session-notes">Save & Finish</button>
            </div>
        </div>
    </div>

    <!-- PT Notes Modal -->
    <div class="modal" id="notes-modal" data-action="closeNotesModal" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content" style="max-height: 80vh; display: flex; flex-direction: column;">
            <div class="modal-drag-handle"></div>
            <h2 style="font-size: 20px; margin-bottom: 16px;">üí¨ PT Notes</h2>
            <div id="notes-list" style="flex: 1; overflow-y: auto; margin-bottom: 16px;">
                <!-- Notes loaded here -->
            </div>
            <div style="border-top: 1px solid var(--border-color); padding-top: 16px;">
                <textarea id="new-note-text" placeholder="Write a note for your PT..." style="width: 100%; min-height: 80px; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); font-family: inherit; resize: vertical; margin-bottom: 12px;"></textarea>
                <div class="modal-buttons">
                    <button class="modal-cancel" data-action="closeNotesModal">Cancel</button>
                    <button class="modal-save" data-action="sendNote">Send Note</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Log Set Modal -->
    <div class="modal" id="log-set-modal" data-action="closeLogSetModal" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title" id="log-set-title">Log Set</div>
            <div class="modal-form">
                <div style="font-size: 15px; color: var(--ios-gray); margin-bottom: 12px; text-align: center;" id="log-set-subtitle">
                    Enter actual reps performed
                </div>
                <input type="number" class="modal-input" id="log-set-reps" placeholder="Reps performed" min="0">
                <input type="number" class="modal-input" id="log-set-distance" placeholder="Distance (feet)" min="0" step="1" style="display: none;">
                <!-- Duration exercises log seconds instead of reps. -->
                <input type="number" class="modal-input" id="log-set-seconds" placeholder="Seconds performed" min="0" step="1" style="display: none;">
                <div id="log-set-side-selector" style="margin: 12px 0;"></div>

                <!-- Dynamic Form Parameters -->
                <div id="log-set-form-params" style="background: rgba(0,122,255,0.05); padding: 12px; border-radius: 8px; margin: 12px 0; display: none;">
                    <div style="font-size: 13px; font-weight: 600; margin-bottom: 8px;">Form Parameters:</div>
                    <div id="log-set-form-params-fields"></div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closeLogSetModal">Cancel</button>
                <button class="modal-save" data-action="saveLoggedSet">Save</button>
            </div>
        </div>
    </div>

    <!-- Next Set Confirmation Modal -->
    <div class="modal" id="next-set-modal" data-action="closeNextSetModal" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Next Set</div>
            <div class="modal-form">
                <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Logging:</div>
                <div style="font-size: 15px; color: var(--text-secondary);" id="next-set-summary"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closeNextSetModal">Cancel</button>
                <button class="modal-save" data-action="editNextSet">Edit</button>
                <button class="modal-save" data-action="confirmNextSet">Log & Next</button>
            </div>
        </div>
    </div>

    <!-- Exercise Details Modal -->
    <div class="modal" id="exercise-details-modal" data-action="closeExerciseDetailsModal" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title" id="exercise-details-title">Exercise Details</div>
            <div class="modal-form" style="max-height: 500px; overflow-y: auto;">
                <!-- Professional Guidance Section (for imported exercises) -->
                <div id="professional-guidance-section" style="display: none; margin-bottom: 16px;">
                    <div style="background: rgba(0,122,255,0.05); padding: 12px; border-radius: 8px; margin-bottom: 12px;">
                        <div style="font-weight: 600; font-size: 14px; margin-bottom: 8px; color: var(--ios-blue);">
                            üìö Professional Guidance
                        </div>
                        <div id="professional-guidance-content"></div>
                    </div>
                    <hr style="border: none; border-top: 1px solid rgba(0,0,0,0.1); margin: 16px 0;">
                </div>

                <!-- User's Personal Notes (hidden - kept for data persistence) -->
                <textarea class="modal-input" id="exercise-description" style="display: none;"></textarea>
                <textarea class="modal-input" id="exercise-tips" style="display: none;"></textarea>
                <textarea class="modal-input" id="exercise-feel" style="display: none;"></textarea>
                <textarea class="modal-input" id="exercise-not-feel" style="display: none;"></textarea>
                <textarea class="modal-input" id="exercise-modifications" style="display: none;"></textarea>
                <input type="number" class="modal-input" id="exercise-rest-seconds" style="display: none;">
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closeExerciseDetailsModal" style="flex: 1;">Close</button>
            </div>
        </div>
    </div>

    <!-- Rest Timer Modal -->
    <div class="modal" id="rest-timer-modal">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Rest Timer</div>
            <div class="modal-form">
                <div style="text-align: center; font-size: 48px; font-weight: 700; color: var(--ios-blue); margin: 20px 0;" id="rest-countdown">60</div>
                <div style="text-align: center; font-size: 15px; color: var(--ios-gray); margin-bottom: 20px;">Rest between sets</div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="rest-progress-bar"></div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="skipRest">Skip Rest</button>
                <button class="modal-save" data-action="closeRestTimer">Continue</button>
            </div>
        </div>
    </div>

    <!-- Quick Exercise Switcher Modal -->
    <div class="modal" id="quick-switcher-modal" data-action="closeQuickSwitcher" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Switch Exercise</div>
            <div class="modal-form">
                <div style="font-size: 13px; color: var(--ios-gray); margin-bottom: 12px; text-align: center;">Tap to switch (current progress will be saved)</div>
                <div class="history-list" id="quick-switcher-list"></div>
            </div>
        </div>
    </div>

    <!-- History Modal -->
    <div class="modal" id="history-modal" data-action="closeHistoryModal" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">History</div>
            <div class="modal-form">
                <div class="history-section">
                    <div class="history-heading">Exercise revisions</div>
                    <div class="history-list" id="exercise-history-list"></div>
                </div>
                <div class="history-section">
                    <div class="history-heading">Recent sessions</div>
                    <div class="history-list" id="session-history-list"></div>
                </div>
                <div style="display: flex; gap: 8px; margin-top: 12px;">
                    <button class="control-btn btn-secondary" data-action="exportWeeklySummary" style="flex: 1;">üìà 7-Day Summary</button>
                    <button class="control-btn btn-primary" data-action="exportForPT" style="flex: 1;">Full Report</button>
                    <button class="control-btn btn-secondary" data-action="reloadApp" style="flex: 1;">Reload app (use after updates)</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Session Modal -->
    <div class="modal" id="edit-session-modal" data-action="closeEditSession" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Edit Session</div>
            <div class="modal-form" style="max-height: 70vh; overflow-y: auto;">
                <!-- Session Date -->
                <div style="margin-bottom: 20px;">
                    <label style="font-weight: 600; margin-bottom: 8px; display: block;">Session Date & Time</label>
                    <input type="datetime-local" class="modal-input" id="edit-session-date">
                </div>

                <!-- Exercise Info (Read-only) -->
                <div style="margin-bottom: 20px; padding: 12px; background: rgba(0,122,255,0.05); border-radius: 8px;">
                    <div style="font-weight: 600; margin-bottom: 4px;" id="edit-session-exercise-name"></div>
                    <div style="font-size: 12px; color: var(--ios-gray);" id="edit-session-exercise-pattern"></div>
                </div>

                <!-- Sets -->
                <div style="margin-bottom: 20px;">
                    <label style="font-weight: 600; margin-bottom: 8px; display: block;">Sets</label>
                    <div id="edit-session-sets-container"></div>
                    <button type="button" class="modal-cancel" data-action="addSetToEditSession" style="margin-top: 8px; font-size: 13px; padding: 6px 12px;">+ Add Set</button>
                </div>

                <!-- Notes -->
                <div style="margin-bottom: 20px;">
                    <label style="font-weight: 600; margin-bottom: 8px; display: block;">Notes</label>
                    <textarea class="modal-input" id="edit-session-notes" placeholder="Session notes..." style="min-height: 60px; resize: vertical;"></textarea>
                </div>

                <!-- Delete Section -->
                <div style="padding-top: 12px; border-top: 1px solid var(--border-color);">
                    <button type="button" class="modal-cancel" data-action="deleteSession" style="background: var(--ios-red); color: white; width: 100%;">üóë Delete Session</button>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closeEditSession">Cancel</button>
                <button class="modal-save" data-action="saveEditedSession">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Body Heatmap Modal - REPLACED BY REHAB COVERAGE VIEW
    <div class="modal" id="body-heatmap-modal" data-action="closeBodyHeatmap" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Body Parts Worked (Last 7 Days)</div>
            <div class="modal-form">
                <div style="font-size: 13px; color: var(--ios-gray); text-align: center; margin-bottom: 12px;">
                    Tap body parts to see exercises
                </div>
                <div class="body-diagram" id="body-diagram"></div>
                <div class="heatmap-legend">
                    <div class="legend-item">
                        <div class="legend-color heat-none"></div>
                        <span>None</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color heat-low"></div>
                        <span>1-2√ó</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color heat-medium"></div>
                        <span>3-4√ó</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color heat-high"></div>
                        <span>5+√ó</span>
                    </div>
                </div>
                <div id="body-part-details" style="margin-top: 12px;"></div>
            </div>
        </div>
    </div>
    -->

    <!-- All Sessions Modal (grouped by workout session) -->
    <div class="modal" id="all-sessions-modal" data-action="closeAllSessions" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Complete Workout Sessions</div>
            <div class="modal-form" style="max-height: 500px; overflow-y: auto;">
                <div style="font-size: 13px; color: var(--ios-gray); margin-bottom: 12px; text-align: center;">
                    All exercises grouped by workout session
                </div>
                <div id="all-sessions-list"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closeAllSessions">Close</button>
            </div>
        </div>
    </div>

    <!-- Weekly Stats Modal -->
    <div class="modal" id="weekly-stats-modal" data-action="closeWeeklyStats" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Weekly Stats</div>
            <div class="modal-form" style="max-height: 500px; overflow-y: auto;">
                <div id="weekly-overview"></div>
                <div id="weekly-volume-chart"></div>
                <div id="weekly-exercises"></div>
                <div id="weekly-adherence"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closeWeeklyStats">Close</button>
                <button class="modal-save" data-action="showAllSessions">View All Sessions</button>
            </div>
        </div>
    </div>

    <!-- Exercise Progress Modal -->
    <div class="modal" id="exercise-progress-modal" data-action="closeExerciseProgress" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title" id="progress-modal-title">Exercise Progress</div>
            <div class="modal-form" style="max-height: 500px; overflow-y: auto;">
                <div id="progress-summary" style="margin-bottom: 16px;"></div>
                <div id="progress-chart" style="margin-bottom: 16px;"></div>
                <div id="progress-sessions" style="margin-bottom: 16px;"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closeExerciseProgress">Close</button>
            </div>
        </div>
    </div>

    <!-- Exercise Library Browser Modal -->
    <div class="modal" id="library-browser-modal" data-action="closeLibraryBrowser" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Exercise Library</div>
            <div class="modal-form">
                <div style="font-size: 13px; color: var(--ios-gray); text-align: center; margin-bottom: 12px;">
                    Professional PT exercises with detailed guidance
                </div>
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; padding: 8px 12px; background: rgba(0,122,255,0.05); border-radius: 8px;">
                    <label style="font-size: 14px; font-weight: 500; cursor: pointer;" for="show-new-toggle">
                        Show only new
                    </label>
                    <input type="checkbox" id="show-new-toggle" checked onchange="toggleShowOnlyNew()" style="width: 20px; height: 20px; cursor: pointer;">
                </div>
                <input type="text" class="modal-input" id="library-search" placeholder="Search exercises..." oninput="filterLibraryExercises()">
                <div class="history-list" id="library-exercises-list" style="max-height: 400px; overflow-y: auto;"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closeLibraryBrowser">Close</button>
                <button class="modal-save" id="bulk-import-btn" data-action="bulkImportExercises" style="display: none;">Import Selected</button>
            </div>
        </div>
    </div>

    <!-- Exercise Detail View Modal -->
    <div class="modal" id="exercise-detail-modal" data-action="closeExerciseDetail" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title" id="exercise-detail-title">Exercise Details</div>
            <div class="modal-form">
                <div id="exercise-detail-content" style="max-height: 500px; overflow-y: auto;"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closeExerciseDetail">Back</button>
                <button class="modal-save" id="import-exercise-btn" data-action="importLibraryExercise">Import to My Exercises</button>
            </div>
        </div>
    </div>

    <!-- Data / Backup Modal -->
    <div class="modal" id="data-backup-modal" data-action="closeDataBackup" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Data / Backup</div>
            <div class="modal-form">
                <div style="font-size: 13px; color: var(--ios-gray); margin-bottom: 16px;">Export your data to save a backup or commit to GitHub.</div>
                <button class="control-btn btn-primary" data-action="exportAllData" style="width: 100%; margin-bottom: 12px; font-weight: 600;">üíæ Export All Data</button>
                <div style="font-size: 12px; color: var(--ios-gray); margin: -8px 0 16px 0; text-align: center;">Single file with library, history, and version</div>
                <button class="control-btn btn-secondary" data-action="exportExerciseLibrary" style="width: 100%; margin-bottom: 12px;">üìö Export Exercise Library</button>
                <button class="control-btn btn-secondary" data-action="exportExerciseHistory" style="width: 100%; margin-bottom: 20px;">üìä Export Exercise History</button>

                <div style="border-top: 1px solid var(--ios-separator); padding-top: 16px; margin-top: 4px;">
                    <div style="font-size: 13px; color: var(--ios-gray); margin-bottom: 12px;">Restore from backup file</div>
                    <input type="file" id="import-file-input" accept=".json" style="display: none;" onchange="handleImportFile(event)">
                    <button class="control-btn btn-secondary" data-click-target="import-file-input" style="width: 100%; margin-bottom: 12px;">üì• Import Data</button>
                </div>

                <div style="border-top: 1px solid var(--ios-separator); padding-top: 16px; margin-top: 4px;">
                    <div style="font-size: 13px; color: var(--ios-gray); margin-bottom: 12px;">Advanced: Exercise editor</div>
                    <button class="control-btn btn-primary" data-open-url="./pt_report.html?mode=editor" data-open-target="_blank" style="width: 100%;">üõ†Ô∏è Open Exercise Editor</button>
                    <div style="font-size: 11px; color: var(--ios-gray); margin-top: 8px; text-align: center;">Edit exercises, dosage, and roles with Firestore sync</div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closeDataBackup">Close</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settings-modal" data-action="closeSettings" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">‚öôÔ∏è Settings</div>
            <div class="modal-form" style="max-height: 600px; overflow-y: auto;">

                <!-- Data & Backup Section -->
                <div style="margin-bottom: 24px;">
                    <div style="font-size: 13px; font-weight: 700; color: var(--text-secondary); margin-bottom: 12px; padding-left: 8px;">üìä DATA & BACKUP</div>
                    <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden;">
                        <button data-action="exportAllData" style="width: 100%; padding: 10px 12px; border: none; background: transparent; text-align: left; border-bottom: 1px solid var(--border-color); cursor: pointer; font-size: 15px; color: var(--text-primary);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span>üíæ Export All Data</span>
                                <span style="color: var(--ios-gray); font-size: 14px;">‚Ä∫</span>
                            </div>
                            <div style="font-size: 12px; color: var(--ios-gray); margin-top: 2px;">Library + history + version</div>
                        </button>
                        <button data-action="exportExerciseLibrary" style="width: 100%; padding: 10px 12px; border: none; background: transparent; text-align: left; border-bottom: 1px solid var(--border-color); cursor: pointer; font-size: 15px; color: var(--text-primary);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span>üìö Export Library Only</span>
                                <span style="color: var(--ios-gray); font-size: 14px;">‚Ä∫</span>
                            </div>
                        </button>
                        <button data-action="exportExerciseHistory" style="width: 100%; padding: 10px 12px; border: none; background: transparent; text-align: left; border-bottom: 1px solid var(--border-color); cursor: pointer; font-size: 15px; color: var(--text-primary);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span>üìä Export History Only</span>
                                <span style="color: var(--ios-gray); font-size: 14px;">‚Ä∫</span>
                            </div>
                        </button>
                        <button data-click-target="import-file-input" style="width: 100%; padding: 10px 12px; border: none; background: transparent; text-align: left; cursor: pointer; font-size: 15px; color: var(--text-primary);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span>üì• Import Data</span>
                                <span style="color: var(--ios-gray); font-size: 14px;">‚Ä∫</span>
                            </div>
                            <div style="font-size: 12px; color: var(--ios-gray); margin-top: 2px;">Restore from backup</div>
                        </button>
                    </div>
                </div>

                <!-- Exercise Library Section -->
                <div style="margin-bottom: 24px;">
                    <div style="font-size: 13px; font-weight: 700; color: var(--text-secondary); margin-bottom: 12px; padding-left: 8px;">üí™ EXERCISE LIBRARY</div>
                    <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden;">
                        <button data-actions="closeSettings,showLibraryBrowser" style="width: 100%; padding: 10px 12px; border: none; background: transparent; text-align: left; border-bottom: 1px solid var(--border-color); cursor: pointer; font-size: 15px; color: var(--text-primary);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span>üìö Browse Library</span>
                                <span style="color: var(--ios-gray); font-size: 14px;">‚Ä∫</span>
                            </div>
                            <div style="font-size: 12px; color: var(--ios-gray); margin-top: 2px;">Professional PT exercises</div>
                        </button>
                        <button data-open-url="./pt_report.html?mode=editor" data-open-target="_blank" style="width: 100%; padding: 10px 12px; border: none; background: transparent; text-align: left; cursor: pointer; font-size: 15px; color: var(--text-primary);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span>üõ†Ô∏è Exercise Editor</span>
                                <span style="color: var(--ios-gray); font-size: 14px;">‚Üó</span>
                            </div>
                            <div style="font-size: 12px; color: var(--ios-gray); margin-top: 2px;">Edit exercises with Firestore sync</div>
                        </button>
                    </div>
                </div>

                <!-- Tracking Preferences Section -->
                <div style="margin-bottom: 24px;">
                    <div style="font-size: 13px; font-weight: 700; color: var(--text-secondary); margin-bottom: 12px; padding-left: 8px;">üéØ TRACKING PREFERENCES</div>
                    <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden;">
                        <div style="padding: 10px 12px; border-bottom: 1px solid var(--border-color);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div>
                                    <div style="font-size: 15px; color: var(--text-primary);">Haptic Feedback</div>
                                    <div style="font-size: 11px; color: var(--ios-gray); margin-top: 2px;">Vibration on actions</div>
                                </div>
                                <input type="checkbox" id="haptic-toggle" checked onchange="toggleHaptic()" style="width: 42px; height: 24px; cursor: pointer;">
                            </div>
                        </div>
                        <div style="padding: 10px 12px;">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <div>
                                    <div style="font-size: 15px; color: var(--text-primary);">Voice Announcements</div>
                                    <div style="font-size: 11px; color: var(--ios-gray); margin-top: 2px;">Speak progress updates</div>
                                </div>
                                <input type="checkbox" id="voice-toggle" checked onchange="toggleVoice()" style="width: 42px; height: 24px; cursor: pointer;">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- App Management Section -->
                <div style="margin-bottom: 24px;">
                    <div style="font-size: 13px; font-weight: 700; color: var(--text-secondary); margin-bottom: 12px; padding-left: 8px;">üì± APP MANAGEMENT</div>
                    <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden;">
                        <div style="padding: 10px 12px; border-bottom: 1px solid var(--border-color);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span style="font-size: 15px; color: var(--text-primary);">App Version</span>
                                <span style="color: var(--ios-gray); font-size: 13px;" id="app-version-display">v1.4.0</span>
                            </div>
                        </div>
                        <button data-action="reloadApp" style="width: 100%; padding: 10px 12px; border: none; background: transparent; text-align: left; cursor: pointer; font-size: 15px; color: var(--text-primary);">
                            <div style="display: flex; align-items: center; justify-content: space-between;">
                                <span>üîÑ Reload App</span>
                                <span style="color: var(--ios-gray); font-size: 14px;">‚Ä∫</span>
                            </div>
                            <div style="font-size: 12px; color: var(--ios-gray); margin-top: 2px;">Check for updates</div>
                        </button>
                    </div>
                </div>

                <!-- About Section -->
                <div style="margin-bottom: 24px;">
                    <div style="font-size: 13px; font-weight: 700; color: var(--text-secondary); margin-bottom: 12px; padding-left: 8px;">‚ÑπÔ∏è ABOUT</div>
                    <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden;">
                        <div style="padding: 14px 16px;">
                            <div style="font-size: 14px; color: var(--ios-gray); line-height: 1.6;">
                                All data stored locally on your device. No cloud sync. Export regularly to back up your progress.
                            </div>
                        </div>
                    </div>
                </div>

            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closeSettings">Close</button>
            </div>
        </div>
    </div>

    <!-- Dosage Prompt Modal -->
    <div class="modal" id="dosage-prompt-modal" data-action="closeDosagePrompt" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">üíä Set Initial Dosage</div>
            <div class="modal-form">
                <div style="font-size: 15px; color: var(--text-primary); margin-bottom: 20px; text-align: center; font-weight: 600;" id="dosage-exercise-name"></div>
                <div style="font-size: 14px; color: var(--ios-gray); margin-bottom: 24px; text-align: center;">What did your PT prescribe?</div>

                <div style="margin-bottom: 16px;">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px;">Sets</label>
                    <input type="number" id="dosage-sets" class="modal-input" placeholder="e.g., 3" min="1" style="font-size: 20px; text-align: center; font-weight: 600;">
                </div>

                <div style="margin-bottom: 16px;" id="dosage-reps-container">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px;">Reps (per set)</label>
                    <input type="number" id="dosage-reps" class="modal-input" placeholder="e.g., 10" min="1" style="font-size: 20px; text-align: center; font-weight: 600;">
                </div>

                <div id="dosage-seconds-container" style="margin-bottom: 16px; display: none;">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px;" id="dosage-seconds-label">Seconds (per rep)</label>
                    <input type="number" id="dosage-seconds" class="modal-input" placeholder="e.g., 30" min="1" style="font-size: 20px; text-align: center; font-weight: 600;">
                    <div style="font-size: 12px; color: var(--ios-gray); margin-top: 4px; text-align: center;">Hold exercises typically 20-30s</div>
                </div>

                <div id="dosage-distance-container" style="margin-bottom: 16px; display: none;">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px;">Distance (feet)</label>
                    <input type="number" id="dosage-distance" class="modal-input" placeholder="e.g., 100" min="1" style="font-size: 20px; text-align: center; font-weight: 600;">
                    <div style="font-size: 12px; color: var(--ios-gray); margin-top: 4px; text-align: center;">Distance to walk/move</div>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closeDosagePrompt">Cancel</button>
                <button class="modal-save" data-action="confirmDosage">Add to My Program</button>
            </div>
        </div>
    </div>

    <!-- Edit Dosage Modal -->
    <div class="modal" id="edit-dosage-modal" data-action="closeEditDosage" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">‚úèÔ∏è Edit Dosage</div>
            <div class="modal-form">
                <div style="font-size: 15px; color: var(--text-primary); margin-bottom: 20px; text-align: center; font-weight: 600;" id="edit-dosage-exercise-name"></div>

                <div style="margin-bottom: 16px;">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px;">Sets</label>
                    <input type="number" id="edit-dosage-sets" class="modal-input" placeholder="e.g., 3" min="1" style="font-size: 20px; text-align: center; font-weight: 600;">
                </div>

                <div style="margin-bottom: 16px;" id="edit-dosage-reps-container">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px;">Reps (per set)</label>
                    <input type="number" id="edit-dosage-reps" class="modal-input" placeholder="e.g., 10" min="1" style="font-size: 20px; text-align: center; font-weight: 600;">
                </div>

                <div id="edit-dosage-seconds-container" style="margin-bottom: 16px; display: none;">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px;" id="edit-dosage-seconds-label">Seconds (per rep)</label>
                    <input type="number" id="edit-dosage-seconds" class="modal-input" placeholder="e.g., 30" min="1" style="font-size: 20px; text-align: center; font-weight: 600;">
                </div>

                <div id="edit-dosage-distance-container" style="margin-bottom: 16px; display: none;">
                    <label style="display: block; font-size: 14px; font-weight: 600; margin-bottom: 8px;">Distance (feet)</label>
                    <input type="number" id="edit-dosage-distance" class="modal-input" placeholder="e.g., 100" min="1" style="font-size: 20px; text-align: center; font-weight: 600;">
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closeEditDosage">Cancel</button>
                <button class="modal-save" data-action="saveEditedDosage">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Plan Session Modal -->
    <div class="modal" id="plan-session-modal" data-action="closePlanSessionModal" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">Plan Today's Session</div>
            <div class="modal-form">
                <div style="font-size: 13px; color: var(--ios-gray); margin-bottom: 12px;">Select exercises for today's workout. Tap to add/remove.</div>
                <div id="plan-session-list" class="history-list" style="max-height: 400px; overflow-y: auto;"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closePlanSessionModal">Cancel</button>
                <button class="modal-save" id="start-session-btn" data-action="startPlannedSession">Start Session</button>
            </div>
        </div>
    </div>

    <!-- iOS Action Sheet -->
    <div class="action-sheet-backdrop" id="action-sheet-backdrop" data-action="hideActionSheet" role="button" tabindex="0"></div>
    <div class="action-sheet" id="action-sheet">
        <div class="action-sheet-content">
            <div class="action-sheet-message" id="action-sheet-message"></div>
            <button class="action-sheet-button destructive" id="action-sheet-confirm" data-action="confirmActionSheet">Confirm</button>
        </div>
        <button class="action-sheet-cancel" data-action="hideActionSheet">Cancel</button>
    </div>

    <!-- Export for PT Modal (Email) -->
    <div class="modal" id="export-pt-modal" data-action="closeExportPTModal" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">üì§ Send to PT</div>
            <div class="modal-form">
                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px; line-height: 1.5;">
                    Enter your PT's email address (optional). You can copy the payload only or open your email client with the payload ready to send.
                </div>
                <input type="email" class="modal-input" id="pt-email-address" placeholder="your.pt@example.com" style="margin-bottom: 12px;">
                <textarea class="modal-input" id="pt-note" placeholder="Optional: Add a note for your PT" style="min-height: 80px; resize: vertical;"></textarea>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closeExportPTModal">Cancel</button>
                <button class="modal-save" data-action="copyPtPayloadOnly">üìã Copy Payload Only</button>
                <button class="modal-save" data-action="sendToPT">üìß Send Email</button>
            </div>
        </div>
    </div>

    <!-- Import PT Modifications Modal (Paste) -->
    <div class="modal" id="import-pt-modal" data-action="closeImportPTModal" data-require-self="true" role="button" tabindex="0">
        <div class="modal-content">
            <div class="modal-drag-handle"></div>
            <div class="modal-title">üì® Import from PT</div>
            <div class="modal-form" style="max-height: 60vh;">
                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px; line-height: 1.5;">
                    Paste the text from your PT's email below. The app will automatically extract and import the data.
                </div>
                <textarea id="import-pt-content" placeholder="Paste the entire email content here (including markers)..." style="
                    width: 100%;
                    min-height: 300px;
                    padding: 12px;
                    font-family: 'Courier New', monospace;
                    font-size: 11px;
                    background: var(--bg-tertiary);
                    border: 1px solid var(--border-color);
                    border-radius: 8px;
                    resize: vertical;
                    color: var(--text-primary);
                "></textarea>
            </div>
            <div class="modal-buttons">
                <button class="modal-cancel" data-action="closeImportPTModal">Cancel</button>
                <button class="modal-save" data-action="processPastedImport">Import</button>
            </div>
        </div>
    </div>

    <!-- Firestore write guard modal (in-app, iOS PWA compatible) -->
    <div class="modal" id="firestore-write-guard-modal" aria-hidden="true" role="dialog" aria-modal="true">
        <div class="modal-content" style="max-width: 520px;">
            <h3 style="margin-bottom: 12px;">Cloud data not loaded</h3>
            <p id="firestore-write-guard-message" style="white-space: pre-line; color: var(--text-secondary); margin-bottom: 16px;">
                Cloud data has not been loaded.
                Saving now may overwrite existing data.
                Continue anyway?
            </p>
            <div class="modal-buttons">
                <button class="modal-cancel" id="firestore-write-guard-cancel">Cancel</button>
                <button class="modal-save" id="firestore-write-guard-confirm">Save Anyway</button>
            </div>
        </div>
    </div>

    <!-- Eyes-free pocket tap overlay -->
    <div class="pocket-overlay" id="pocket-overlay" data-action="handlePocketTap" role="button" tabindex="0" aria-live="assertive">
        <button class="pocket-close" data-action="togglePocketMode" data-action-arg-bool="false" data-stop-propagation="true" aria-label="Exit Pocket Mode">‚úï</button>
        <div class="pocket-pad" role="button" aria-label="Pocket tap target">
            <div id="pocket-label">Tap to count</div>
            <div class="pocket-meta" id="pocket-meta">Reps left ¬∑ Sets left</div>
        </div>
    </div>

    <script src="pt_payload_utils.js"></script>
    <script>
        // Guard: show a warning if the module script fails to initialize.
        window.appBooted = false;
        window.addEventListener('load', () => {
            setTimeout(() => {
                if (!window.appBooted) {
                    const warning = document.getElementById('app-load-warning');
                    if (warning) warning.style.display = 'block';
                }
            }, 1500);
        });
    </script>
    <script type="module" src="firebase.js"></script>
    <script type="module">
        import { db } from './firebase.js';
        import {
            auth,
            signInWithEmailAndPassword,
            signOut,
            onAuthStateChanged,
            setPersistence,
            browserLocalPersistence,
            browserSessionPersistence
        } from './firebase.js';
        // import { sendPasswordResetEmail } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js"; // TODO: Fix password reset
        import { ulid } from "https://cdn.jsdelivr.net/npm/ulid@2.3.0/dist/index.esm.js";
        import {
            loadExerciseRolesShared,
            loadExerciseVocabularyShared,
            loadExerciseFileSchemaShared,
            loadExerciseRolesSchemaShared,
            saveExerciseRolesShared,
            saveExerciseVocabularyShared,
            saveExerciseLibraryShared
        } from './shared/firestore_shared_data.js';
        import {
            addDoc,
            collection,
            deleteDoc,
            doc,
            getDoc,
            getDocs,
            orderBy,
            query,
            setDoc,
            updateDoc,
            where,
            writeBatch
        } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

        const STORAGE_KEY = 'pt_tracker_data';
        const LIBRARY_KEY = 'pt_exercise_library';
        const ROLES_DATA_KEY = 'pt_exercise_roles';
        const VOCABULARY_KEY = 'pt_exercise_vocabulary';
        const LAST_EXERCISE_KEY = 'pt_last_exercise_id';
        const FIRESTORE_QUEUE_KEY = 'pt_firestore_queue';
        const RECOVERY_STORAGE_KEY = 'pt_session_recovery';
        const PREFERENCES_STORAGE_KEY = 'pt_preferences';
        const RUNTIME_UPDATED_KEY = 'pt_runtime_updated_at';
        const LEGACY_HISTORY_MIGRATION_KEY = 'pt_tracker_history_migrated';
        const APP_VERSION = 'v1.5.9'; // Updated: 2025-12-27 - Equipment editing with dynamic library and add-new capability
        const PT_VERSION_KEY = 'pt_data_version';
        const PT_DATA_VERSION = '1';

        // Auth state
        let currentUser = null;
        let isAuthReady = false;
        let authModalActive = false;
        let authModalLastFocus = null;

        // Auth UI functions
        function ensureAuthCredentialFields() {
            const fieldsContainer = document.getElementById('auth-credential-fields');
            if (!fieldsContainer || fieldsContainer.childElementCount > 0) return;
            // Create credential inputs only after explicit user action to avoid iOS PWA autofill prompts.
            const emailGroup = document.createElement('div');
            emailGroup.className = 'form-group';
            emailGroup.style.marginBottom = '0';

            const emailLabel = document.createElement('label');
            emailLabel.className = 'form-label';
            emailLabel.setAttribute('for', 'auth-email');
            emailLabel.textContent = 'Email';

            const emailInput = document.createElement('input');
            emailInput.type = 'email';
            emailInput.className = 'form-input';
            emailInput.id = 'auth-email';
            emailInput.placeholder = 'name@example.com';
            emailInput.autocomplete = 'email';

            emailGroup.appendChild(emailLabel);
            emailGroup.appendChild(emailInput);

            const passwordGroup = document.createElement('div');
            passwordGroup.className = 'form-group';
            passwordGroup.style.marginBottom = '0';

            const passwordLabel = document.createElement('label');
            passwordLabel.className = 'form-label';
            passwordLabel.setAttribute('for', 'auth-password');
            passwordLabel.textContent = 'Password';

            const passwordInput = document.createElement('input');
            passwordInput.type = 'password';
            passwordInput.className = 'form-input';
            passwordInput.id = 'auth-password';
            passwordInput.placeholder = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
            passwordInput.autocomplete = 'current-password';

            passwordGroup.appendChild(passwordLabel);
            passwordGroup.appendChild(passwordInput);

            fieldsContainer.appendChild(emailGroup);
            fieldsContainer.appendChild(passwordGroup);

            const submitOnEnter = (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    handleSignIn();
                }
            };

            emailInput.addEventListener('keydown', submitOnEnter);
            passwordInput.addEventListener('keydown', submitOnEnter);
        }

        function clearAuthCredentialFields() {
            const fieldsContainer = document.getElementById('auth-credential-fields');
            if (!fieldsContainer) return;
            // Remove credential inputs when the modal closes so they are not mounted on navigation.
            fieldsContainer.innerHTML = '';
        }

        function showAuthModal() {
            const modal = document.getElementById('auth-modal');
            if (!modal) return;
            authModalLastFocus = document.activeElement;
            ensureAuthCredentialFields();
            modal.classList.add('active');
            modal.setAttribute('aria-hidden', 'false');
            authModalActive = true;
            clearAuthError();
            const emailInput = document.getElementById('auth-email');
            if (emailInput) {
                emailInput.focus();
                emailInput.select();
            }
        }

        function hideAuthModal() {
            const modal = document.getElementById('auth-modal');
            if (!modal || !authModalActive) return;
            modal.classList.remove('active');
            modal.setAttribute('aria-hidden', 'true');
            authModalActive = false;
            clearAuthCredentialFields();
            if (authModalLastFocus && typeof authModalLastFocus.focus === 'function') {
                authModalLastFocus.focus();
            }
        }

        function showAuthMessage(message, tone = 'error') {
            const errorDiv = document.getElementById('auth-error');
            if (!errorDiv) return;
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            errorDiv.style.color = tone === 'success' ? 'var(--ios-green)' : 'var(--ios-red)';
        }

        function showAuthError(message) {
            showAuthMessage(message, 'error');
        }

        function clearAuthError() {
            const errorDiv = document.getElementById('auth-error');
            if (!errorDiv) return;
            errorDiv.textContent = '';
            errorDiv.style.display = 'none';
            errorDiv.style.color = 'var(--ios-red)';
        }

        function updateMenuAuthDisplay() {
            const signedInSection = document.getElementById('menu-auth-signed-in');
            const signedOutSection = document.getElementById('menu-auth-signed-out');
            const emailDisplay = document.getElementById('menu-auth-email');

            if (currentUser) {
                // Show signed in state
                signedInSection.style.display = 'block';
                signedOutSection.style.display = 'none';
                emailDisplay.textContent = currentUser.email;
            } else {
                // Show signed out state
                signedInSection.style.display = 'none';
                signedOutSection.style.display = 'block';
            }
        }

        async function handleMenuSignOut() {
            try {
                // TODO(firebase-auth): replace Firebase sign-out with API-based auth
                await signOut(auth);
                console.log('[Auth] Signed out successfully');
                // Close menu
                const toggleMenu = window.toggleHamburgerMenu;
                if (toggleMenu) toggleMenu();
            } catch (error) {
                console.error('[Auth] Sign out error:', error);
                alert('Failed to sign out. Please try again.');
            }
        }

        function handleMenuSignIn() {
            showAuthModal();
            // Close menu
            const toggleMenu = window.toggleHamburgerMenu;
            if (toggleMenu) toggleMenu();
        }

        async function handleSignIn() {
            const emailInput = document.getElementById('auth-email');
            const passwordInput = document.getElementById('auth-password');
            if (!emailInput || !passwordInput) {
                showAuthError('Tap "Sign In" to enter your credentials.');
                return;
            }
            const email = emailInput.value.trim();
            const password = passwordInput.value;
            const rememberMe = document.getElementById('auth-remember').checked;

            if (!email || !password) {
                showAuthError('Enter both email and password to sign in.');
                return;
            }

            try {
                const persistence = rememberMe ? browserLocalPersistence : browserSessionPersistence;
                // TODO(firebase-auth): replace Firebase auth persistence with API-based auth
                await setPersistence(auth, persistence);
                // TODO(firebase-auth): replace Firebase sign-in with API-based auth
                await signInWithEmailAndPassword(auth, email, password);
                console.log('[Auth] Signed in successfully');
            } catch (error) {
                console.error('[Auth] Sign in error:', error);
                if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password') {
                    showAuthError('Incorrect email or password.');
                } else if (error.code === 'auth/invalid-email') {
                    showAuthError('Please enter a valid email address.');
                } else if (error.code === 'auth/too-many-requests') {
                    showAuthError('Too many attempts. Please try again later.');
                } else {
                    showAuthError('Sign in failed. Please try again.');
                }
            }
        }

        async function handlePasswordReset() {
            // Send a Firebase password reset email using the existing auth instance.
            const emailInput = document.getElementById('auth-email');
            if (!emailInput) {
                showAuthError('Tap "Sign In" to enter your email first.');
                return;
            }
            const email = emailInput.value.trim();
            if (!email) {
                showAuthError('Enter your email to reset your password.');
                return;
            }

            try {
                // await sendPasswordResetEmail(auth, email); // TODO: Fix password reset
                // showAuthMessage('Password reset email sent. Check your inbox.', 'success');
                showAuthMessage('Password reset temporarily disabled. Contact your therapist.', 'error');
            } catch (error) {
                console.error('[Auth] Password reset failed:', error);
                if (error.code === 'auth/invalid-email') {
                    showAuthError('Please enter a valid email address.');
                } else if (error.code === 'auth/user-not-found') {
                    showAuthError('No account found for that email.');
                } else if (error.code === 'auth/too-many-requests') {
                    showAuthError('Too many attempts. Please try again later.');
                } else {
                    showAuthError('Password reset failed. Please try again.');
                }
            }
        }

        // Auth state listener
        // TODO(firebase-auth): replace Firebase auth state listener with API-based auth
        onAuthStateChanged(auth, (user) => {
            currentUser = user;
            isAuthReady = true;

            // Auth Guard: Block page if no user is signed in
            const authGuardOverlay = document.getElementById('auth-guard-overlay');
            if (authGuardOverlay) {
                // Avoid flashing the sign-in prompt before auth state is resolved.
                authGuardOverlay.classList.remove('auth-checking');
            }
            if (user) {
                console.log('[Auth] User signed in:', user.email);
                firestoreUserId = user.uid; // Set for runtime sync
                updateMenuAuthDisplay(); // Update menu

                // Remove auth guard overlay
                if (authGuardOverlay) {
                    authGuardOverlay.classList.add('auth-verified');
                }
                hideAuthModal();

                // Flush queue when authenticated
                if (navigator.onLine) {
                    console.log('[Auth] Triggering queue flush after authentication');
                    void flushFirestoreQueue();
                }

                // Sync runtime if pending
                if (runtimeSyncPending) {
                    runtimeSyncPending = false;
                    syncRuntimeToFirestore();
                }

                // Check for new notes from therapist
                checkForNewNotes();
            } else {
                console.log('[Auth] No user signed in - blocking page access');
                // Show auth guard overlay
                if (authGuardOverlay) {
                    authGuardOverlay.classList.remove('auth-verified');
                }
                firestoreUserId = null;
                updateMenuAuthDisplay(); // Update menu
            }
        });

        /**
         * SESSION ID TRACKING
         * -------------------
         * Each history entry includes a sessionId to group exercises performed in the same workout session.
         *
         * Current strategy: Generate a ULID sessionId once per app load.
         * - All exercises completed before closing/refreshing the app share the same sessionId
         * - Different app launches = different sessionIds, even on the same day
         * - Format: 26-character ULID (Crockford Base32)
         *
         * Future: This enables session-based UI features like:
         * - "Today's Workout" view grouping exercises by session
         * - Session history browser
         * - Session planning (which exercises in what order)
         */
        function generateSessionId() {
            return ulid();
        }

        let currentSessionId = generateSessionId();

        // Session planning
        let sessionPlan = []; // Array of exercise IDs planned for today
        let sessionPlanCompleted = new Set(); // IDs of completed exercises

        // Runtime sync state
        let firestoreUserId = null;
        let runtimeSyncPending = false;
        let runtimeSyncInFlight = false;
        let runtimeSyncTimer = null;
        let sharedLibrarySyncTimer = null;
        let sharedLibrarySyncReason = null;

        // Session history cache (Firestore-backed)
        let sessionHistoryCache = [];
        let sessionHistoryLoadedFromFirestore = false;
        let sessionHistoryUnsubscribe = null;
        let legacyHistoryMigrationAttempted = false;
        let sessionHistoryHydrated = false;
        let legacyHistoryFetchAttempted = false;

        // Per-document hydration + overwrite guard state (safety-critical).
        let runtimeHydrated = false;
        let sharedLibraryHydrated = false;
        let sharedRolesHydrated = false;
        let sharedVocabHydrated = false;

        const firestoreReadState = {
            runtime: false,
            sharedLibrary: false,
            sharedRoles: false,
            sharedVocab: false
        };

        const userConfirmedOverwriteState = {
            runtime: false,
            sharedLibrary: false,
            sharedRoles: false,
            sharedVocab: false
        };

        const sharedDocSource = {
            sharedLibrary: 'unknown',
            sharedRoles: 'unknown',
            sharedVocab: 'unknown'
        };

        const pendingWriteFlags = {
            runtime: false,
            sharedLibrary: false,
            sharedRoles: false,
            sharedVocab: false
        };

        function stripSessionMetadata(session) {
            const { _firestoreId, ...rest } = session;
            return rest;
        }

        function serializeSessionHistory(sessions) {
            return sessions.map(stripSessionMetadata);
        }

        function getSessionFingerprint(session) {
            if (session.sessionId) {
                const exerciseKey = session.exerciseId || session.exerciseName || 'unknown';
                return `session:${session.sessionId}|exercise:${exerciseKey}`;
            }
            const exerciseId = session.exerciseId || 'unknown';
            const date = session.date || '';
            const name = session.exerciseName || '';
            return `fallback:${exerciseId}|${date}|${name}`;
        }

        function getSessionTimestamp(session) {
            if (session?.date) {
                const parsed = new Date(session.date);
                if (!isNaN(parsed.getTime())) return parsed.getTime();
            }
            return 0;
        }

        function dedupeSessions(sessions) {
            const map = new Map();
            sessions.forEach((session) => {
                const key = getSessionFingerprint(session);
                if (!key) return;
                const existing = map.get(key);
                if (!existing) {
                    map.set(key, session);
                    return;
                }
                const existingTimestamp = getSessionTimestamp(existing);
                const nextTimestamp = getSessionTimestamp(session);
                if (nextTimestamp > existingTimestamp) {
                    map.set(key, session);
                }
            });
            return Array.from(map.values());
        }

        function setSessionHistoryCache(newHistory, { source = 'unknown', syncLocalStorage = false } = {}) {
            const deduped = dedupeSessions(newHistory);
            deduped.sort((a, b) => new Date(a.date || 0) - new Date(b.date || 0));
            sessionHistoryCache = deduped;
            if (syncLocalStorage) {
                syncCacheToLocalStorage();
            }
            const timestamp = new Date().toISOString();
            console.log(`[${timestamp}] [History] Cache updated (${deduped.length} sessions) from ${source}`);
        }

        function getSessionHistoryFromCache() {
            return sessionHistoryCache;
        }

        function syncCacheToLocalStorage() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(serializeSessionHistory(sessionHistoryCache)));
            } catch (error) {
                console.warn('[History] Failed to sync cache to localStorage:', error);
            }
        }

        function loadLegacyHistoryFromLocalStorage() {
            if (sessionHistoryHydrated) {
                return [];
            }
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (!stored) return [];
                const parsed = JSON.parse(stored);
                return Array.isArray(parsed) ? parsed : [];
            } catch (error) {
                console.warn('[History] Failed to read legacy history from localStorage:', error);
                return [];
            }
        }

        function seedLegacyHistoryCache() {
            if (sessionHistoryHydrated) return;
            if (sessionHistoryCache.length > 0) return;
            const legacySessions = loadLegacyHistoryFromLocalStorage();
            if (legacySessions.length > 0) {
                setSessionHistoryCache(legacySessions, { source: 'legacy-localStorage', syncLocalStorage: false });
            }
        }

        const writeGuardModalState = {
            resolve: null,
            allowOverride: false
        };

        function closeWriteGuardModal(result) {
            const modal = document.getElementById('firestore-write-guard-modal');
            if (modal) {
                modal.classList.remove('active');
                modal.setAttribute('aria-hidden', 'true');
            }
            if (writeGuardModalState.resolve) {
                writeGuardModalState.resolve(result);
                writeGuardModalState.resolve = null;
            }
        }

        function showWriteGuardModal({ message, allowOverride = true, confirmLabel = 'Save Anyway' } = {}) {
            const modal = document.getElementById('firestore-write-guard-modal');
            const messageEl = document.getElementById('firestore-write-guard-message');
            const confirmBtn = document.getElementById('firestore-write-guard-confirm');
            const cancelBtn = document.getElementById('firestore-write-guard-cancel');
            if (!modal || !messageEl || !confirmBtn || !cancelBtn) {
                alert(message || 'Cloud data has not been loaded.');
                return Promise.resolve(false);
            }

            messageEl.textContent = message || '';
            confirmBtn.textContent = confirmLabel;
            confirmBtn.style.display = allowOverride ? 'inline-flex' : 'none';
            cancelBtn.textContent = allowOverride ? 'Cancel' : 'Close';

            modal.classList.add('active');
            modal.setAttribute('aria-hidden', 'false');
            writeGuardModalState.allowOverride = allowOverride;

            return new Promise((resolve) => {
                writeGuardModalState.resolve = resolve;
            });
        }

        function bindWriteGuardModalEvents() {
            const modal = document.getElementById('firestore-write-guard-modal');
            const confirmBtn = document.getElementById('firestore-write-guard-confirm');
            const cancelBtn = document.getElementById('firestore-write-guard-cancel');

            if (confirmBtn) {
                confirmBtn.addEventListener('pointerup', () => closeWriteGuardModal(true));
            }
            if (cancelBtn) {
                cancelBtn.addEventListener('pointerup', () => closeWriteGuardModal(false));
            }
            if (modal) {
                modal.addEventListener('pointerup', (event) => {
                    if (event.target === modal) {
                        closeWriteGuardModal(false);
                    }
                });
            }
        }

        bindWriteGuardModalEvents();

        function setFirestoreReadSucceeded(docKey) {
            if (firestoreReadState[docKey] !== undefined) {
                firestoreReadState[docKey] = true;
            }
        }

        function isDocHydrated(docKey) {
            switch (docKey) {
                case 'runtime':
                    return runtimeHydrated;
                case 'sharedLibrary':
                    return sharedLibraryHydrated;
                case 'sharedRoles':
                    return sharedRolesHydrated;
                case 'sharedVocab':
                    return sharedVocabHydrated;
                default:
                    return false;
            }
        }

        function markDocHydrated(docKey) {
            switch (docKey) {
                case 'runtime':
                    runtimeHydrated = true;
                    break;
                case 'sharedLibrary':
                    sharedLibraryHydrated = true;
                    break;
                case 'sharedRoles':
                    sharedRolesHydrated = true;
                    break;
                case 'sharedVocab':
                    sharedVocabHydrated = true;
                    break;
                default:
                    break;
            }

            if (pendingWriteFlags[docKey]) {
                pendingWriteFlags[docKey] = false;
                switch (docKey) {
                    case 'runtime':
                        scheduleRuntimeSync('hydration');
                        break;
                    case 'sharedLibrary':
                        scheduleSharedLibrarySync('hydration');
                        break;
                    case 'sharedRoles':
                        void syncRolesToFirestore(loadRolesDataSync());
                        break;
                    case 'sharedVocab':
                        void syncVocabularyToFirestore(loadVocabularySync());
                        break;
                    default:
                        break;
                }
            }
        }

        async function confirmCanonicalWrite({ docKey, source = 'firestore' }) {
            if (source === 'fallback' || source === 'cache') {
                await showWriteGuardModal({
                    message: 'Cloud data loaded from offline cache or fallback.\n\nSaving to cloud is blocked until live data loads.',
                    allowOverride: false,
                    confirmLabel: 'Close'
                });
                return false;
            }

            if (isDocHydrated(docKey) || userConfirmedOverwriteState[docKey]) {
                return true;
            }

            const confirmed = await showWriteGuardModal({
                message: 'Cloud data has not been loaded.\nSaving now may overwrite existing data.\nContinue anyway?',
                allowOverride: true,
                confirmLabel: 'Save Anyway'
            });

            if (confirmed) {
                userConfirmedOverwriteState[docKey] = true;
            }

            return confirmed;
        }

        function sanitizeExerciseLibraryForRuntime(library) {
            if (!Array.isArray(library)) return [];
            return library.filter(entry => {
                const exerciseId = entry?.id || entry?.exercise_id;
                return typeof exerciseId === 'string' && exerciseId.trim().length > 0;
            });
        }

        function sanitizeOfflineQueue(queue) {
            if (!Array.isArray(queue)) return [];
            return queue.filter(entry => entry && typeof entry === 'object');
        }

        // BUG FIX: Add more detailed error logging when snapshot build fails
        function buildRuntimeSnapshot({ allowLocalTimestamp = false } = {}) {
            try {
                const history = getSessionHistoryFromCache();
                const recovery = localStorage.getItem(RECOVERY_STORAGE_KEY);
                const preferences = localStorage.getItem(PREFERENCES_STORAGE_KEY);
                const offlineQueue = localStorage.getItem(FIRESTORE_QUEUE_KEY);
                const dataVersion = localStorage.getItem(PT_VERSION_KEY) || PT_DATA_VERSION;
                const updatedAt = new Date().toISOString();
                const sanitizedLibrary = sanitizeExerciseLibraryForRuntime(exerciseLibrary);

                if (allowLocalTimestamp) {
                    localStorage.setItem(RUNTIME_UPDATED_KEY, updatedAt);
                }

                return {
                    updatedAt,
                    sessionHistory: serializeSessionHistory(history),
                    sessionRecovery: recovery ? JSON.parse(recovery) : null,
                    preferences: preferences ? JSON.parse(preferences) : null,
                    offlineQueue: sanitizeOfflineQueue(offlineQueue ? JSON.parse(offlineQueue) : []),
                    exerciseLibrary: sanitizedLibrary,  // Use in-memory global, not localStorage
                    ptDataVersion: dataVersion
                    // NOTE: Firestore (with IndexedDB offline persistence) is authoritative.
                    // Timestamp comparison handles conflicts - most recent wins.
                };
            } catch (error) {
                console.error('[Runtime] Failed to build runtime snapshot - sync will be skipped:', error);
                // Return null causes syncRuntimeToFirestore to silently skip sync
                return null;
            }
        }

        function scheduleRuntimeSync(reason = 'scheduled') {
            if (!firestoreUserId) {
                runtimeSyncPending = true;
                return;
            }
            if (runtimeSyncTimer) {
                clearTimeout(runtimeSyncTimer);
            }
            runtimeSyncTimer = setTimeout(() => {
                runtimeSyncTimer = null;
                void syncRuntimeToFirestore();
            }, 500);
        }

        function scheduleSharedLibrarySync(reason = 'scheduled') {
            // Debounce shared library writes so edits (including dosage) persist to Firebase.
            sharedLibrarySyncReason = reason;
            if (sharedLibrarySyncTimer) {
                clearTimeout(sharedLibrarySyncTimer);
            }
            sharedLibrarySyncTimer = setTimeout(() => {
                const nextReason = sharedLibrarySyncReason || 'scheduled';
                sharedLibrarySyncTimer = null;
                sharedLibrarySyncReason = null;
                void syncExerciseLibraryToFirestore(nextReason);
            }, 500);
        }

        // BUG FIX: Improve error logging for runtime sync failures
        async function syncRuntimeToFirestore() {
            if (!firestoreUserId) {
                runtimeSyncPending = true;
                return;
            }
            if (runtimeSyncInFlight) return;
            runtimeSyncInFlight = true;
            try {
                const canWrite = await confirmCanonicalWrite({ docKey: 'runtime', source: 'firestore' });
                if (!canWrite) {
                    pendingWriteFlags.runtime = true;
                    runtimeSyncPending = true;
                    return;
                }

                const allowLocalTimestamp = firestoreReadState.runtime && runtimeHydrated;
                const snapshot = buildRuntimeSnapshot({ allowLocalTimestamp });
                if (!snapshot) {
                    console.error('[Runtime] Sync skipped - buildRuntimeSnapshot returned null (see error above)');
                    return;
                }
                const docRef = doc(db, 'users', firestoreUserId, 'pt_runtime', 'state');
                // TODO(firebase-write): replace runtime state write with API
                await setDoc(docRef, snapshot, { merge: true });
            } catch (error) {
                console.error('[Runtime] Failed to sync runtime data to Firestore:', error);
            } finally {
                runtimeSyncInFlight = false;
            }
        }

        /**
         * Apply PT modifications from Firestore runtime automatically (no user prompt).
         * This handles dosage changes, archived exercises, edited exercises, and role updates
         * that were saved by pt_report.html.
         *
         * @param {Object} mods - The pt_modifications object from Firestore runtime
         */
        async function applyModificationsAutomatically(mods) {
            if (!mods || typeof mods !== 'object') return;

            console.log('[Runtime] Applying pt_modifications from Firestore');

            // Load current exercise library
            let exerciseLibrary = loadExerciseLibrary();
            let rolesData = loadRolesDataSync();
            let vocabulary = loadVocabularySync();
            let modified = false;

            // 1. Add new exercises to library
            if (Array.isArray(mods.newExercises) && mods.newExercises.length > 0) {
                mods.newExercises.forEach(ex => {
                    const exists = exerciseLibrary.find(e => e.id === ex.id);
                    if (!exists) {
                        exerciseLibrary.push(ex);
                        modified = true;
                        console.log(`[Runtime] Added new exercise: ${ex.id}`);
                    }
                });
            }

            // 2. Update edited exercises in library
            if (mods.editedExercises && Object.keys(mods.editedExercises).length > 0) {
                Object.keys(mods.editedExercises).forEach(exerciseId => {
                    const updatedExercise = mods.editedExercises[exerciseId];
                    const index = exerciseLibrary.findIndex(e => e.id === exerciseId);
                    if (index !== -1) {
                        exerciseLibrary[index] = updatedExercise;
                        modified = true;
                        console.log(`[Runtime] Updated exercise: ${exerciseId}`);
                    } else {
                        console.warn(`[Runtime] Edited exercise not found: ${exerciseId}`);
                    }
                });
            }

            // 3. Archive exercises (remove from library)
            if (Array.isArray(mods.archivedExercises) && mods.archivedExercises.length > 0) {
                mods.archivedExercises.forEach(exerciseId => {
                    const index = exerciseLibrary.findIndex(e => e.id === exerciseId);
                    if (index !== -1) {
                        exerciseLibrary.splice(index, 1);
                        modified = true;
                        console.log(`[Runtime] Archived exercise: ${exerciseId}`);
                    }
                    // Also remove role data
                    if (rolesData?.exercise_roles?.[exerciseId]) {
                        delete rolesData.exercise_roles[exerciseId];
                    }
                });
            }

            // 4. Add new roles
            if (mods.newRoles && Object.keys(mods.newRoles).length > 0) {
                Object.keys(mods.newRoles).forEach(exerciseId => {
                    const exercise = exerciseLibrary.find(e => e.id === exerciseId);
                    const exerciseName = exercise ? (exercise.name || exercise.canonical_name || exercise.title || exerciseId) : exerciseId;

                    if (!rolesData.exercise_roles[exerciseId]) {
                        rolesData.exercise_roles[exerciseId] = { name: exerciseName, roles: [] };
                    }
                    const newRoles = mods.newRoles[exerciseId];
                    newRoles.forEach(role => {
                        rolesData.exercise_roles[exerciseId].roles.push(role);
                        modified = true;
                    });
                    console.log(`[Runtime] Added ${newRoles.length} new roles for: ${exerciseId}`);
                });
            }

            // 5. Delete roles
            if (mods.deletedRoles && Object.keys(mods.deletedRoles).length > 0) {
                Object.keys(mods.deletedRoles).forEach(exerciseId => {
                    if (rolesData?.exercise_roles?.[exerciseId]) {
                        const rolesToDelete = mods.deletedRoles[exerciseId];
                        rolesToDelete.forEach(roleToDelete => {
                            const index = rolesData.exercise_roles[exerciseId].roles.findIndex(r =>
                                r.region === roleToDelete.region &&
                                r.capacity === roleToDelete.capacity &&
                                (r.focus || '') === (roleToDelete.focus || '')
                            );
                            if (index !== -1) {
                                rolesData.exercise_roles[exerciseId].roles.splice(index, 1);
                                modified = true;
                            }
                        });
                        console.log(`[Runtime] Deleted ${rolesToDelete.length} roles from: ${exerciseId}`);
                    }
                });
            }

            // 6. Update edited roles (replace entire role set for exercise)
            if (mods.editedRoles && Object.keys(mods.editedRoles).length > 0) {
                Object.keys(mods.editedRoles).forEach(exerciseId => {
                    if (rolesData?.exercise_roles?.[exerciseId]) {
                        rolesData.exercise_roles[exerciseId].roles = mods.editedRoles[exerciseId];
                        modified = true;
                    } else {
                        const exercise = exerciseLibrary.find(e => e.id === exerciseId);
                        const exerciseName = exercise ? (exercise.name || exercise.canonical_name || exercise.title || exerciseId) : exerciseId;
                        rolesData.exercise_roles[exerciseId] = {
                            name: exerciseName,
                            roles: mods.editedRoles[exerciseId]
                        };
                        modified = true;
                    }
                    console.log(`[Runtime] Updated roles for: ${exerciseId}`);
                });
            }

            // 7. Update dosages
            if (mods.dosageChanges && Object.keys(mods.dosageChanges).length > 0) {
                Object.keys(mods.dosageChanges).forEach(exerciseId => {
                    const exercise = exerciseLibrary.find(e => e.id === exerciseId);
                    if (exercise) {
                        const previousSpec = exercise.current || {};
                        exercise.current = mods.dosageChanges[exerciseId];

                        // Add to history
                        if (!exercise.history) exercise.history = [];
                        exercise.history.push({
                            timestamp: new Date().toISOString(),
                            summary: `Dosage updated by PT`,
                            previous: previousSpec,
                            next: mods.dosageChanges[exerciseId],
                            supersedes: []
                        });
                        modified = true;
                        console.log(`[Runtime] Updated dosage for: ${exerciseId}`);
                    } else {
                        console.warn(`[Runtime] Dosage change for unknown exercise: ${exerciseId}`);
                    }
                });
            }

            // 8. Update vocabulary
            if (mods.updatedVocab && Object.keys(mods.updatedVocab).length > 0) {
                Object.keys(mods.updatedVocab).forEach(category => {
                    if (!vocabulary[category]) {
                        vocabulary[category] = {};
                    }
                    Object.assign(vocabulary[category], mods.updatedVocab[category]);
                    modified = true;
                });
                console.log(`[Runtime] Updated vocabulary`);
            }

            // Save all updated data if any modifications were applied
            if (modified) {
                // Modifications came from Firestore - update global and sync back
                window.exerciseLibrary = exerciseLibrary;
                saveRolesDataSync(rolesData);
                saveVocabularySync(vocabulary);

                // Sync updated library back to Firestore
                scheduleRuntimeSync('apply-modifications');
                scheduleSharedLibrarySync('apply-modifications');

                // Refresh UI
                renderExerciseList();
                renderLibraryExercises();

                console.log('[Runtime] pt_modifications applied and saved successfully');
            }
        }

        async function loadRuntimeFromFirestore() {
            if (!firestoreUserId) {
                runtimeSyncPending = true;
                return;
            }
            try {
                const wasRuntimeHydrated = runtimeHydrated;
                const docRef = doc(db, 'users', firestoreUserId, 'pt_runtime', 'state');
                // TODO(firebase-read): runtime state read requires API endpoint mapping
                const snapshot = await getDoc(docRef);
                setFirestoreReadSucceeded('runtime');
                markDocHydrated('runtime');
                if (!snapshot.exists()) return;

                const data = snapshot.data();
                const remoteUpdatedAt = data?.updatedAt;
                const localUpdatedAt = wasRuntimeHydrated ? localStorage.getItem(RUNTIME_UPDATED_KEY) : null;
                if (!remoteUpdatedAt) return;

                if (!localUpdatedAt || new Date(remoteUpdatedAt) > new Date(localUpdatedAt)) {
                    if (Array.isArray(data.sessionHistory)) {
                        console.log('[Firestore] Runtime session history ignored (Firestore sessions collection is authoritative)');
                    }
                    if (data.sessionRecovery) {
                        localStorage.setItem(RECOVERY_STORAGE_KEY, JSON.stringify(data.sessionRecovery));
                    } else {
                        localStorage.removeItem(RECOVERY_STORAGE_KEY);
                    }
                    if (data.preferences) {
                        localStorage.setItem(PREFERENCES_STORAGE_KEY, JSON.stringify(data.preferences));
                    }
                    if (Array.isArray(data.offlineQueue)) {
                        localStorage.setItem(FIRESTORE_QUEUE_KEY, JSON.stringify(data.offlineQueue));
                    }
                    if (Array.isArray(data.exerciseLibrary) && data.exerciseLibrary.length > 0) {
                        const incomingLibraryJson = JSON.stringify(data.exerciseLibrary);
                        const existingLibraryJson = JSON.stringify(exerciseLibrary);
                        if (incomingLibraryJson !== existingLibraryJson) {
                            // Update global exerciseLibrary from Firestore (authoritative)
                            exerciseLibrary = data.exerciseLibrary;
                            window.exerciseLibrary = exerciseLibrary;
                            const version = data.ptDataVersion || PT_DATA_VERSION;
                            localStorage.setItem(PT_VERSION_KEY, version);
                            // Update localStorage cache for offline boot fallback
                            localStorage.setItem(LIBRARY_KEY, incomingLibraryJson);
                            renderExerciseList();
                            renderLibraryExercises();
                            console.log('[Runtime] Updated exerciseLibrary from Firestore');
                        }
                    }

                    // Apply pt_modifications if present (dosage, archiving, edits)
                    if (data.pt_modifications) {
                        await applyModificationsAutomatically(data.pt_modifications);
                        // Clear modifications from Firestore after applying them
                        try {
                            // TODO(firebase-write): replace runtime modifications clear with API
                            await import("https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js")
                                .then(({ updateDoc }) => updateDoc(docRef, { pt_modifications: {} }));
                            console.log('[Runtime] Cleared pt_modifications from Firestore after applying');
                        } catch (error) {
                            console.warn('[Runtime] Failed to clear pt_modifications:', error);
                        }
                    }

                    localStorage.setItem(RUNTIME_UPDATED_KEY, remoteUpdatedAt);
                }
            } catch (error) {
                console.error('Failed to load runtime data from Firestore:', error);
            }
        }

        function getQueuedSessionFingerprint(session) {
            return getSessionFingerprint(session);
        }

        function removeQueuedSession(session) {
            const queue = loadFirestoreQueue();
            const target = getQueuedSessionFingerprint(session);
            const filtered = queue.filter((queued) => getQueuedSessionFingerprint(queued) !== target);
            if (filtered.length !== queue.length) {
                saveFirestoreQueue(filtered);
            }
        }

        async function resolveFirestoreDocId(session) {
            if (session._firestoreId) return session._firestoreId;
            if (!currentUser || !session.sessionId) return null;
            try {
                const sessionsRef = collection(db, `users/${currentUser.uid}/sessions`);
                const sessionQuery = query(sessionsRef, where('sessionId', '==', session.sessionId));
                // TODO(firebase-read): session doc lookup needs API replacement while preserving Firestore IDs
                const snapshot = await getDocs(sessionQuery);
                const docMatch = snapshot.docs[0];
                return docMatch ? docMatch.id : null;
            } catch (error) {
                console.warn('[Firestore] Failed to resolve session doc ID:', error);
                return null;
            }
        }

        function migrateLegacyHistoryToFirestore(firestoreSessions) {
            if (sessionHistoryHydrated) return [];
            if (legacyHistoryMigrationAttempted) return [];
            legacyHistoryMigrationAttempted = true;

            const migrationFlag = localStorage.getItem(LEGACY_HISTORY_MIGRATION_KEY);
            if (migrationFlag === 'true') return [];

            const legacySessions = loadLegacyHistoryFromLocalStorage();
            if (legacySessions.length === 0) {
                localStorage.setItem(LEGACY_HISTORY_MIGRATION_KEY, 'true');
                return [];
            }

            const firestoreKeys = new Set(firestoreSessions.map(getSessionFingerprint));
            const missingSessions = legacySessions.filter(session => !firestoreKeys.has(getSessionFingerprint(session)));

            if (missingSessions.length > 0) {
                console.log(`[Migration] Queuing ${missingSessions.length} legacy sessions for Firestore sync`);
                missingSessions.forEach(session => enqueueFirestoreSession(session));
            }

            localStorage.setItem(LEGACY_HISTORY_MIGRATION_KEY, 'true');
            return missingSessions;
        }

        async function fetchFirestoreSessionsForLegacyMigration(user) {
            if (!user || sessionHistoryHydrated || legacyHistoryFetchAttempted) return;
            legacyHistoryFetchAttempted = true;
            try {
                const snapshot = await fetch(`/api/logs?patient_id=${user.uid}`).then(r => r.json());
                const sessions = (snapshot || []).map(session => ({
                    _firestoreId: session._firestoreId || session.id,
                    ...session
                }));
                migrateLegacyHistoryToFirestore(sessions);
            } catch (error) {
                console.warn('[Migration] Failed to fetch Firestore sessions:', error);
            }
        }

        function isWorkoutSessionActive() {
            return Boolean(currentExercise);
        }

        function subscribeToFirestoreSessionHistory(user) {
            if (sessionHistoryUnsubscribe) {
                sessionHistoryUnsubscribe();
                sessionHistoryUnsubscribe = null;
            }

            if (!user) {
                sessionHistoryLoadedFromFirestore = false;
                if (!sessionHistoryHydrated) {
                    seedLegacyHistoryCache();
                }
                return;
            }

            sessionHistoryUnsubscribe = null;

            // TODO(firebase-snapshot): replace realtime listener with API-based refresh or polling
            (async () => {
                try {
                    const timestamp = new Date().toISOString();
                    const snapshot = await fetch(`/api/logs?patient_id=${user.uid}`).then(r => r.json());
                    console.log(`[${timestamp}] [Firestore] Session history loaded`);

                    const sessions = (snapshot || []).map(session => ({
                        _firestoreId: session._firestoreId || session.id,
                        ...session
                    }));
                    const activeSessionId = isWorkoutSessionActive() ? currentSessionId : null;
                    const localSessions = getSessionHistoryFromCache();
                    const filteredSessions = activeSessionId
                        ? sessions.filter(session => session.sessionId !== activeSessionId)
                        : sessions;
                    const queued = loadFirestoreQueue();
                    const merged = dedupeSessions([
                        ...filteredSessions,
                        ...localSessions,
                        ...queued
                    ]);
                    // Only sync to localStorage on initial load; subsequent updates skip localStorage
                    // to reduce write operations and prevent Firebase rate-limiting
                    const syncToLS = !sessionHistoryLoadedFromFirestore;
                    setSessionHistoryCache(merged, { source: 'firestore', syncLocalStorage: syncToLS });
                    sessionHistoryLoadedFromFirestore = true;
                    if (!sessionHistoryHydrated) {
                        sessionHistoryHydrated = true;
                    }

                    renderHistory();
                    updateStreakDisplay();
                } catch (error) {
                    console.error('[Firestore] Session history listener error:', error);
                    sessionHistoryLoadedFromFirestore = true;
                }
            })();

            void fetchFirestoreSessionsForLegacyMigration(user);
        }

        // TODO(firebase-auth): replace Firebase auth state listener with API-based auth
        onAuthStateChanged(auth, user => {
            firestoreUserId = user ? user.uid : null;
            subscribeToFirestoreSessionHistory(user);
            if (user) {
                void loadRuntimeFromFirestore();
                if (runtimeSyncPending) {
                    runtimeSyncPending = false;
                    void syncRuntimeToFirestore();
                }
            }
        });

        seedLegacyHistoryCache();

        function loadFirestoreQueue() {
            const stored = localStorage.getItem(FIRESTORE_QUEUE_KEY);
            if (!stored) return [];
            try {
                const parsed = JSON.parse(stored);
                return Array.isArray(parsed) ? parsed : [];
            } catch (e) {
                console.warn('Failed to parse Firestore queue:', e);
                return [];
            }
        }

        function saveFirestoreQueue(queue) {
            localStorage.setItem(FIRESTORE_QUEUE_KEY, JSON.stringify(queue));
            void syncRuntimeToFirestore();
        }

        function sanitizeSessionForFirestore(session) {
            return stripSessionMetadata(session);
        }

        function enqueueFirestoreSession(session) {
            const queue = loadFirestoreQueue();
            queue.push(sanitizeSessionForFirestore(session));
            saveFirestoreQueue(queue);
            console.log('[Firestore] Session queued for sync:', session.sessionId || session.date);
        }

        /**
         * Flush queued Firestore sessions using batched writes.
         *
         * Firestore has write rate limits. This function batches up to 500 writes per batch
         * to avoid exhausting the write stream quota. This prevents the error:
         * "Write stream exhausted maximum allowed queued writes"
         */
        async function flushFirestoreQueue() {
            const queue = loadFirestoreQueue();

            // Only flush if authenticated
            if (!currentUser) {
                if (queue.length > 0) {
                    console.log(`[Firestore] Skipping queue flush - not authenticated (${queue.length} sessions queued)`);
                }
                return;
            }

            if (queue.length === 0) {
                console.log('[Firestore] Queue flush called but queue is empty');
                return;
            }

            console.log(`[Firestore] Flushing ${queue.length} queued sessions for user ${currentUser.uid}`);

            const BATCH_SIZE = 500; // Firestore max batch size
            const remaining = [];

            // Process queue in batches
            for (let i = 0; i < queue.length; i += BATCH_SIZE) {
                const batchSessions = queue.slice(i, i + BATCH_SIZE);
                // TODO(firebase-write): replace batched session writes with API
                const batch = writeBatch(db);

                // Add each session to the batch
                batchSessions.forEach(session => {
                    const docRef = doc(collection(db, `users/${currentUser.uid}/sessions`));
                    // TODO(firebase-write): replace batched session write with API
                    batch.set(docRef, sanitizeSessionForFirestore(session));
                });

                try {
                    // TODO(firebase-write): replace batched session commit with API
                    await batch.commit();
                    console.log(`[Firestore] Batch ${Math.floor(i / BATCH_SIZE) + 1} committed: ${batchSessions.length} sessions`);
                } catch (error) {
                    console.error(`[Firestore] Batch write failed:`, error);
                    // If batch fails, add those sessions back to remaining queue
                    remaining.push(...batchSessions);
                }
            }

            saveFirestoreQueue(remaining);
            if (remaining.length === 0) {
                console.log('[Firestore] Queue flush complete - all sessions synced');
            } else {
                console.log(`[Firestore] Queue flush complete - ${remaining.length} sessions remain queued`);
            }
        }

        window.addEventListener('online', () => {
            void flushFirestoreQueue();
        });

        if (navigator.onLine) {
            void flushFirestoreQueue();
        }

        function reloadApp() {
            try {
                window.location.reload();
            } catch (e) {
                console.warn('Reload failed, you can close and reopen the app manually.', e);
            }
        }

        // Exercise library loaded from localStorage or starts empty
        let exerciseLibrary = loadExerciseLibrary();

        async function reconcileSharedExerciseLibrary() {
            let sharedExerciseLibrary = [];
            let sharedLoaded = false;

            try {
                const result = await fetch('/api/exercises').then(r => r.json());
                sharedExerciseLibrary = result || [];
                sharedDocSource.sharedLibrary = 'api';
                setFirestoreReadSucceeded('sharedLibrary');
                markDocHydrated('sharedLibrary');
                sharedLoaded = true;
            } catch (error) {
                console.warn('[Library] Shared exercise library unavailable; keeping local only.', error);
            }

            if (!sharedLoaded) {
                return;
            }

            const mergedLibrary = mergeExerciseLibraries(sharedExerciseLibrary, exerciseLibrary);
            if (mergedLibrary.length !== exerciseLibrary.length) {
                console.log(`[Library] Merged shared library into local (${exerciseLibrary.length} -> ${mergedLibrary.length}).`);
                exerciseLibrary = mergedLibrary;
                persistExerciseLibrary();
                renderExerciseList();
                renderLibraryExercises();
            }
        }

        function getInitialExercise() {
            // Only restore last used exercise if it exists
            const lastExerciseId = localStorage.getItem(LAST_EXERCISE_KEY);
            if (lastExerciseId) {
                const lastExercise = exerciseLibrary.find(ex => ex.id === lastExerciseId && !ex.archived);
                if (lastExercise) {
                    return toSessionExercise(lastExercise);
                }
            }

            // Don't auto-select any exercise - let user choose
            return null;
        }

        let currentExercise = null;  // Don't auto-open exercises (too easy to accidentally tap rep button)

        let timerInterval = null;
        let timerSecondsRemaining = currentExercise ? Math.max(currentExercise.secondsPerRep || 0, 1) : 0; // counts DOWN
        let timerRunning = false;
        let actionSheetCallback = null;
        let pocketMode = false;

        const TIMER_TYPES = ['timed', 'hold', 'duration'];
        const COUNTER_TYPES = ['reps', 'amrap', 'distance'];

        // Pattern helper functions - avoid hard-coded pattern checks
        function isSidedPattern(pattern) {
            return pattern === 'side';
        }

        function isBilateralPattern(pattern) {
            return pattern === 'both';
        }

        function getSideOptionsForPattern(pattern) {
            return isSidedPattern(pattern) ? ['left', 'right'] : [];
        }

        function getPatternBadge(pattern) {
            return isSidedPattern(pattern) ? 'üîÑ' : '‚úì';
        }

        function getPatternLabel(pattern) {
            return isSidedPattern(pattern) ? 'Sided' : 'Bilateral';
        }

        function getPatternColor(pattern) {
            return isSidedPattern(pattern) ? 'var(--ios-blue)' : 'var(--ios-green)';
        }

        function getPatternDescription(pattern) {
            return isSidedPattern(pattern)
                ? 'work left and right separately'
                : 'both sides together';
        }

        // Derive available tags from library
        function getAvailableTags() {
            const tags = new Set();
            exerciseLibrary.forEach(ex => {
                if (ex.tags && Array.isArray(ex.tags)) {
                    ex.tags.forEach(tag => tags.add(tag));
                }
            });
            return Array.from(tags).sort();
        }

        // Derive available equipment from library
        function getAvailableEquipment() {
            const equipment = new Set();
            exerciseLibrary.forEach(ex => {
                if (ex.equipment && Array.isArray(ex.equipment)) {
                    ex.equipment.forEach(item => equipment.add(item));
                }
                if (ex.equipmentOptional && Array.isArray(ex.equipmentOptional)) {
                    ex.equipmentOptional.forEach(item => equipment.add(item));
                }
            });
            return Array.from(equipment).sort();
        }

        // Get historical values for a form parameter from this exercise's session history
        function getHistoricalParamValues(exerciseId, paramName, side = null) {
            const sessions = loadHistory();
            const exerciseSessions = sessions.filter(s => s.exerciseId === exerciseId);
            const values = new Set();

            exerciseSessions.forEach(session => {
                (session.sets || []).forEach(set => {
                    // Match side if specified, otherwise any side
                    if (side && set.side !== side) return;

                    if (set.formParams && set.formParams[paramName]) {
                        values.add(set.formParams[paramName]);
                    }
                });
            });

            return Array.from(values).sort();
        }

        // Get the last used value for a parameter on this exercise
        function getLastUsedParamValue(exerciseId, paramName, side = null) {
            const sessions = loadHistory();
            const exerciseSessions = sessions.filter(s => s.exerciseId === exerciseId);

            // Sort by date descending (most recent first)
            exerciseSessions.sort((a, b) => new Date(b.date) - new Date(a.date));

            // Find the most recent value
            for (const session of exerciseSessions) {
                for (const set of (session.sets || [])) {
                    // Match side if specified, otherwise any side
                    if (side && set.side !== side) continue;

                    if (set.formParams && set.formParams[paramName]) {
                        return set.formParams[paramName];
                    }
                }
            }

            return null;
        }

        function getLastUsedParamUnit(exerciseId, paramName, side = null) {
            const sessions = loadHistory();
            const exerciseSessions = sessions.filter(s => s.exerciseId === exerciseId);
            exerciseSessions.sort((a, b) => new Date(b.date) - new Date(a.date));

            for (const session of exerciseSessions) {
                for (const set of (session.sets || [])) {
                    if (side && set.side !== side) continue;
                    const unit = set.formParams?.[`${paramName}_unit`];
                    if (unit) {
                        return unit;
                    }
                }
            }

            return null;
        }

        // Get historical values across all exercises for a parameter
        function getGlobalHistoricalParamValues(paramName) {
            const sessions = loadHistory();
            const values = new Set();

            sessions.forEach(session => {
                (session.sets || []).forEach(set => {
                    if (set.formParams && set.formParams[paramName]) {
                        values.add(set.formParams[paramName]);
                    }
                });
            });

            return Array.from(values).sort();
        }

        // Format date/time to human-readable EST/EDT
        function formatDateTime(isoDateString) {
            if (!isoDateString) return '';
            const date = new Date(isoDateString);
            return date.toLocaleString('en-US', {
                timeZone: 'America/New_York',
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            });
        }

        // Render a smart form parameter select that learns from history
        const CUSTOM_PARAM_VALUE = '__custom__';

        function renderSmartParamSelect(param, exerciseId, elementId, options = {}) {
            const { side = null, includeGlobal = false } = options;
            const historicalValues = getHistoricalParamValues(exerciseId, param, side);
            const globalValues = includeGlobal ? getGlobalHistoricalParamValues(param) : [];
            const lastUsed = getLastUsedParamValue(exerciseId, param, side);
            const label = param.replace(/_/g, ' ');

            const mergedValues = new Set([...historicalValues, ...globalValues]);
            if (lastUsed) mergedValues.add(lastUsed);

            const sortedValues = Array.from(mergedValues).sort();
            const placeholder = `<option value="">Select ${label}...</option>`;
            const optionHtml = sortedValues.map(value => {
                const selected = value === lastUsed ? 'selected' : '';
                return `<option value="${value}" ${selected}>${value}</option>`;
            });

            return `
                <label style="font-size: 13px; margin-bottom: 4px; display: block;">${label}</label>
                <select class="modal-select param-select" id="${elementId}" style="margin-bottom: 8px;" data-param="${param}" data-side="${side || ''}">
                    ${lastUsed ? '' : placeholder}
                    ${optionHtml.join('')}
                    <option value="${CUSTOM_PARAM_VALUE}">Other...</option>
                </select>
                <input type="text" class="modal-input" id="${elementId}-custom" placeholder="Enter ${label}" style="display: none; margin-bottom: 12px;">
            `;
        }

        /**
         * Handle parameter select change events (shows/hides "Other" custom input).
         * iOS Safari/PWA compatible - uses event delegation instead of inline onchange.
         */
        function handleParamSelectChange(selectElement) {
            const customElem = document.getElementById(`${selectElement.id}-custom`);
            if (!customElem) return;

            if (selectElement.value === CUSTOM_PARAM_VALUE) {
                customElem.style.display = 'block';
                customElem.focus();
            } else {
                customElem.style.display = 'none';
                customElem.value = '';
            }
        }

        /**
         * iOS-safe event delegation for parameter select dropdowns.
         * Listens for change events on all .param-select elements.
         */
        document.addEventListener('change', (event) => {
            if (event.target.classList.contains('param-select')) {
                handleParamSelectChange(event.target);
            }
        });

        function readParamSelectValue(selectElement) {
            if (!selectElement) return '';
            if (selectElement.value === CUSTOM_PARAM_VALUE) {
                const customElem = document.getElementById(`${selectElement.id}-custom`);
                return customElem ? customElem.value.trim() : '';
            }
            return selectElement.value.trim();
        }

        let editingExerciseId = null;
        let selectedTags = [];
        let filterTags = [];
        let selectedSideOptions = [];
        let selectedSupersedes = [];

        const SIDE_OPTIONS_AVAILABLE = ['left', 'right', 'both'];

        // Audio for timer
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Speech synthesis for voice announcements
        function speak(text) {
            if (!preferences.voiceEnabled) return;
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 1.0;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                speechSynthesis.speak(utterance);
            }
        }

        /**
         * FIRST-RUN DETECTION & DATA LOADING
         * -----------------------------------
         * TRUE FIRST RUN is detected when ALL of these are missing:
         *   - PT_VERSION_KEY
         *   - LIBRARY_KEY
         *   - STORAGE_KEY
         *
         * On true first run:
         *   - Seed default exercises into LIBRARY_KEY
         *   - Set PT_VERSION_KEY to prevent future reseeding
         *
         * Once PT_VERSION_KEY exists, we NEVER auto-reseed defaults.
         * This prevents data loss on PWA updates/reinstalls.
         *
         * Parse errors are handled gracefully:
         *   - Log warning to console
         *   - Return empty array (in memory only)
         *   - DO NOT overwrite stored data
         */
        function normalizeExerciseEntry(entry) {
            const normalized = { ...entry };
            const tagSource = normalized.tags;
            const pattern = normalized.pattern || 'both';
            normalized.pattern = pattern;

            if (!normalized.id && normalized.exercise_id) {
                normalized.id = normalized.exercise_id;
                delete normalized.exercise_id;
            }

            if (!normalized.name) {
                normalized.name = normalized.canonical_name || normalized.exercise_name || normalized.title || '';
            }

            if (normalized.canonical_name === undefined && normalized.name) {
                normalized.canonical_name = normalized.name;
            }

            if (normalized.equipment && typeof normalized.equipment === 'object' && !Array.isArray(normalized.equipment)) {
                normalized.equipmentOptional = normalized.equipmentOptional || normalized.equipment.optional || [];
                normalized.equipment = normalized.equipment.required || [];
            }

            if (!normalized.equipment) normalized.equipment = [];
            if (!normalized.equipmentOptional) normalized.equipmentOptional = [];

            if (!Array.isArray(normalized.equipment)) {
                normalized.equipment = [normalized.equipment];
            }
            if (!Array.isArray(normalized.equipmentOptional)) {
                normalized.equipmentOptional = [normalized.equipmentOptional];
            }

            if (!Array.isArray(normalized.pattern_modifiers)) {
                normalized.pattern_modifiers = normalized.pattern_modifiers ? [normalized.pattern_modifiers] : [];
            }

            if (!Array.isArray(normalized.form_parameters_required)) {
                normalized.form_parameters_required = normalized.form_parameters_required ? [normalized.form_parameters_required] : [];
            }

            if (!Array.isArray(normalized.sideOptions) || normalized.sideOptions.length === 0) {
                normalized.sideOptions = getSideOptionsForPattern(pattern);
            }

            if (tagSource && !Array.isArray(tagSource) && Array.isArray(tagSource.functional)) {
                normalized.tags = tagSource.functional;
                if (!normalized.anatomicRegions && Array.isArray(tagSource.heatmap)) {
                    normalized.anatomicRegions = tagSource.heatmap.join(', ');
                }
            } else if (!normalized.tags) {
                normalized.tags = [];
            }

            if (!normalized.anatomicRegions && Array.isArray(normalized.heatmapTags)) {
                normalized.anatomicRegions = normalized.heatmapTags.join(', ');
            }

            return normalized;
        }

        function loadExerciseLibrary() {
            const version = localStorage.getItem(PT_VERSION_KEY);
            const storedLibrary = localStorage.getItem(LIBRARY_KEY);
            // Load existing library or start empty
            if (storedLibrary) {
                try {
                    const parsed = JSON.parse(storedLibrary);
                    const exercises = Array.isArray(parsed)
                        ? parsed
                        : Array.isArray(parsed?.exercises)
                            ? parsed.exercises
                            : null;
                    if (exercises) {
                        return exercises.map(normalizeExerciseEntry);
                    }
                } catch (e) {
                    console.error('Failed to parse exercise library:', e);
                    console.warn('Returning empty library - stored data preserved');
                    return [];
                }
            }

            // No stored library - start empty
            // User can browse library to import exercises
            return [];
        }

        function persistExerciseLibrary() {
            // Firestore (with IndexedDB offline persistence) is authoritative.
            // Write directly to Firestore; no localStorage intermediary needed.
            scheduleRuntimeSync('exercise-library');
            scheduleSharedLibrarySync('exercise-library');
        }

        function getTodayDateString() {
            return new Date().toISOString().split('T')[0];
        }

        function startOfLocalDay(date) {
            const localDate = new Date(date);
            // Use local midnight so "today" matches the user's calendar day across timezones/DST.
            localDate.setHours(0, 0, 0, 0);
            return localDate;
        }

        function getLocalDayDiff(today, otherDate) {
            const dayMs = 1000 * 60 * 60 * 24;
            // Compare by local calendar day using UTC midnight to avoid DST-length days.
            const todayUtc = Date.UTC(today.getFullYear(), today.getMonth(), today.getDate());
            const otherUtc = Date.UTC(otherDate.getFullYear(), otherDate.getMonth(), otherDate.getDate());
            return Math.floor((todayUtc - otherUtc) / dayMs);
        }

        function updateExerciseLifecycle(entry, { archived }) {
            const lifecycle = entry.lifecycle || {
                status: 'active',
                effective_start_date: null,
                effective_end_date: null
            };

            if (archived) {
                lifecycle.status = 'archived';
                lifecycle.effective_end_date = getTodayDateString();
            } else {
                lifecycle.status = 'active';
                lifecycle.effective_end_date = null;
            }

            entry.lifecycle = lifecycle;
        }

        // BUG FIX: Alert user when library sync fails instead of silent console.warn
        async function syncExerciseLibraryToFirestore(reason) {
            try {
                const canWrite = await confirmCanonicalWrite({
                    docKey: 'sharedLibrary',
                    source: sharedDocSource.sharedLibrary
                });
                if (!canWrite) {
                    if (sharedDocSource.sharedLibrary !== 'fallback' && sharedDocSource.sharedLibrary !== 'cache') {
                        pendingWriteFlags.sharedLibrary = true;
                    }
                    return;
                }
                const schemaFormattedLibrary = buildExerciseLibrarySchemaData(exerciseLibrary, { includeDosage: true });
                // TODO(firebase-write): replace shared library write with API
                await saveExerciseLibraryShared(schemaFormattedLibrary);
                console.log(`[Library] Shared library synced after ${reason}.`);
            } catch (error) {
                console.error(`[Library] Shared library sync failed after ${reason}:`, error);
                // Only alert for user-initiated actions, not background syncs
                if (reason === 'archive' || reason === 'unarchive' || reason === 'delete') {
                    alert(`Warning: Exercise ${reason} saved locally but failed to sync to cloud: ${error.message}`);
                }
            }
        }

        // Synchronous load/save for roles data
        function loadRolesDataSync() {
            const stored = localStorage.getItem(ROLES_DATA_KEY);
            if (stored) {
                try {
                    const parsed = JSON.parse(stored);
                    if (sharedDocSource.sharedRoles === 'unknown') {
                        sharedDocSource.sharedRoles = 'cache';
                    }
                    return parsed;
                } catch (e) {
                    console.error('[Roles] Failed to parse stored roles:', e);
                }
            }
            // Return default structure if not found
            return { exercise_roles: {} };
        }

        function saveRolesDataSync(rolesData, { skipFirestoreSync = false } = {}) {
            localStorage.setItem(ROLES_DATA_KEY, JSON.stringify(rolesData));
            if (!skipFirestoreSync) {
                void syncRolesToFirestore(rolesData);
            }
        }

        // Synchronous load/save for vocabulary
        function loadVocabularySync() {
            const stored = localStorage.getItem(VOCABULARY_KEY);
            if (stored) {
                try {
                    const parsed = JSON.parse(stored);
                    if (sharedDocSource.sharedVocab === 'unknown') {
                        sharedDocSource.sharedVocab = 'cache';
                    }
                    return parsed;
                } catch (e) {
                    console.error('[Vocabulary] Failed to parse stored vocabulary:', e);
                }
            }
            // Return default structure if not found
            return {};
        }

        function saveVocabularySync(vocabulary, { skipFirestoreSync = false } = {}) {
            localStorage.setItem(VOCABULARY_KEY, JSON.stringify(vocabulary));
            if (!skipFirestoreSync) {
                void syncVocabularyToFirestore(vocabulary);
            }
        }

        // Safe history loading with error handling and backward compatibility
        function loadHistory() {
            const sessions = getSessionHistoryFromCache();
            if (!Array.isArray(sessions)) return [];

            sessions.forEach(session => {
                // Ensure sessionId exists (added in later versions)
                if (!session.sessionId) {
                    session.sessionId = session.date || new Date().toISOString();
                }

                // Ensure exerciseId exists (try to find by name if missing)
                if (!session.exerciseId && session.exerciseName) {
                    const matchingExercise = exerciseLibrary.find(ex => ex.name === session.exerciseName);
                    if (matchingExercise) {
                        session.exerciseId = matchingExercise.id;
                    }
                }

                // Ensure sets array exists
                if (!session.sets) {
                    session.sets = [];
                }

                // Migrate old weight/resistance fields to formParams if needed
                session.sets = session.sets.map(set => {
                    if ((set.weight || set.resistance) && !set.formParams) {
                        set.formParams = {};
                        if (set.weight) {
                            set.formParams.weight = set.weight;
                            set.formParams.weight_unit = set.weightUnit || 'lb';
                        }
                        if (set.resistance) {
                            set.formParams.band_resistance = set.resistance;
                        }
                    }
                    return set;
                });

            });

            return sessions;
        }

        function addSessionToCache(session) {
            const updated = [...getSessionHistoryFromCache(), session];
            setSessionHistoryCache(updated, { source: 'local-add', syncLocalStorage: true });
        }

        function queueSessionsForFirestore(sessions, source = 'import') {
            if (!Array.isArray(sessions) || sessions.length === 0) return;
            const pendingSessions = sessions.filter(session => !session._firestoreId);
            if (pendingSessions.length === 0) return;
            console.log(`[Firestore] Queueing ${pendingSessions.length} sessions from ${source}`);
            pendingSessions.forEach(session => enqueueFirestoreSession(session));
            if (currentUser && navigator.onLine) {
                void flushFirestoreQueue();
            }
        }

        // Load roles data from Firestore (cached locally for offline use)
        function loadRolesData() {
            // TODO(firebase-read): roles shared data requires API endpoint mapping
            return loadExerciseRolesShared().then((result) => {
                const data = result?.data || { exercise_roles: {} };
                sharedDocSource.sharedRoles = result?.source || sharedDocSource.sharedRoles;
                if (result?.hasFirestoreReadSucceeded) {
                    setFirestoreReadSucceeded('sharedRoles');
                    markDocHydrated('sharedRoles');
                }
                if (data) {
                    saveRolesDataSync(data, { skipFirestoreSync: true });
                }
                return data;
            }).catch(err => {
                console.error('Failed to load roles data:', err);
                return { exercise_roles: {} };
            });
        }

        // Load schema from Firestore
        function loadSchema() {
            // TODO(firebase-read): schema shared data requires API endpoint mapping
            return loadExerciseFileSchemaShared().then((result) => {
                return result?.data || {};
            }).catch(err => {
                console.error('Failed to load schema:', err);
                return {};
            });
        }

        // Load vocabulary from Firestore (cached locally for offline use)
        function loadVocabulary() {
            // TODO(firebase-read): vocabulary shared data requires API endpoint mapping
            return loadExerciseVocabularyShared().then((result) => {
                const data = result?.data || {};
                sharedDocSource.sharedVocab = result?.source || sharedDocSource.sharedVocab;
                if (result?.hasFirestoreReadSucceeded) {
                    setFirestoreReadSucceeded('sharedVocab');
                    markDocHydrated('sharedVocab');
                }
                if (data) {
                    saveVocabularySync(data, { skipFirestoreSync: true });
                }
                return data;
            }).catch(err => {
                console.error('Failed to load vocabulary:', err);
                return {};
            });
        }

        /**
         * DATA LOSS PREVENTION - TEST CHECKLIST
         * --------------------------------------
         * To verify the version guard prevents data loss:
         *
         * ‚úì TEST 1: True first run
         *   - Clear all localStorage (DevTools ‚Üí Application ‚Üí Clear Site Data)
         *   - Reload app
         *   - EXPECT: Default exercises seeded, PT_VERSION_KEY set to "1"
         *   - VERIFY: localStorage has pt_data_version="1", pt_exercise_library with defaults
         *
         * ‚úì TEST 2: Update with existing data
         *   - Add custom exercises, complete some workouts
         *   - Note your custom data
         *   - Reload app (simulates PWA update)
         *   - EXPECT: All custom exercises and history preserved
         *   - VERIFY: No re-seeding, PT_VERSION_KEY still "1"
         *
         * ‚úì TEST 3: Corrupted JSON
         *   - In DevTools ‚Üí Application ‚Üí localStorage, manually corrupt pt_exercise_library
         *     (e.g., change JSON to invalid syntax like `[{broken`)
         *   - Reload app
         *   - EXPECT: Console shows error "Failed to parse exercise library"
         *   - EXPECT: Console shows warning "Returning empty library - stored data preserved"
         *   - EXPECT: App shows blank exercise list (safe in-memory fallback)
         *   - VERIFY: Corrupted data still in localStorage (not overwritten)
         *   - FIX: Restore valid JSON or clear localStorage to reset
         */

        /**
         * EXERCISE OBJECT STRUCTURE
         * -------------------------
         * This app represents exercises in two forms:
         *
         * 1. Library Entry (persisted in localStorage):
         *    - id: unique identifier
         *    - name: exercise name
         *    - pattern: 'side' | 'both' (determines if sides tracked separately)
         *    - current: { type, sets, repsPerSet, secondsPerRep }
         *    - sideOptions: ['left', 'right'] (for sided exercises)
         *    - tags: body parts (knee, hip, etc.)
         *    - equipment: array of equipment types
         *    - guidance: { external_cues, motor_cues, compensation_warnings, safety_flags }
         *    - history: array of revisions tracking dosage changes
         *    - details: { description, executionTips, shouldFeel, shouldNotFeel, etc. }
         *    - favorite, archived: boolean flags
         *
         * 2. Session Exercise (runtime state):
         *    Converted from library entry by toSessionExercise()
         *    - All library fields PLUS:
         *    - currentSet, currentRep: live progress tracking
         *    - sessionData: array of logged sets [{set, reps, timestamp, side?, weight?, resistance?}]
         *
         * TODO: Define what a "session" is (one workout? one day? when does it end?)
         * TODO: Add program-layer integration (how exercises fit into rehab programs)
         * TODO: Schema-driven fields (lifecycle, progression parameters, etc.)
         */
        function toSessionExercise(entry) {
            const spec = entry?.current || {};
            const isBilateral = isBilateralPattern(entry.pattern);
            const sideOptions = entry.sideOptions || [];
            const modifiers = entry.pattern_modifiers || [];
            const resolvedType = spec.type
                || (modifiers.includes('distance_feet') ? 'distance' : null)
                || (modifiers.includes('duration_seconds') ? 'duration' : null)
                || (modifiers.includes('hold_seconds') ? 'hold' : null)
                || 'reps';
            const distanceTarget = spec.distanceFeet || spec.repsPerSet || 0;

            // For sided exercises, multiply sets by number of sides
            // E.g., 3 sets with ['left', 'right'] = 6 total sets (3 per side)
            const baseSets = spec.sets || 3;
            const effectiveSides = (!isBilateral && sideOptions.length > 0) ? sideOptions.length : 1;
            const totalSets = baseSets * effectiveSides;

            return {
                id: entry.id,
                name: entry.name,
                type: resolvedType,
                sets: totalSets,
                baseSets: baseSets, // Original sets per side
                sideOptions: sideOptions,
                bilateral: isBilateral,
                repsPerSet: resolvedType === 'distance' ? distanceTarget : (spec.repsPerSet || 10),
                secondsPerRep: spec.secondsPerRep ?? 10,
                distanceTarget: distanceTarget,
                alternatingSide: sideOptions[0] || 'left',
                currentSet: 1,
                currentRep: 0,
                sessionData: [] // Populated during execution
            };
        }

        function getLibraryEntryById(id) {
            return exerciseLibrary.find(ex => ex.id === id) || exerciseLibrary[0];
        }

        function recordRevision(entry, nextSpec, reason = 'Updated dosage') {
            const previous = { ...(entry.current || {}) };
            const changes = [];

            if ((previous.sets ?? null) !== nextSpec.sets) changes.push(`sets ${previous.sets ?? '‚Äî'} ‚Üí ${nextSpec.sets}`);
            if ((previous.repsPerSet ?? null) !== nextSpec.repsPerSet) changes.push(`reps ${previous.repsPerSet ?? '‚Äî'} ‚Üí ${nextSpec.repsPerSet}`);
            if ((previous.secondsPerRep ?? null) !== nextSpec.secondsPerRep) changes.push(`seconds ${previous.secondsPerRep ?? '‚Äî'} ‚Üí ${nextSpec.secondsPerRep}`);
            if ((previous.type ?? '') !== nextSpec.type) changes.push(`type ${previous.type || 'reps'} ‚Üí ${nextSpec.type}`);

            entry.history = entry.history || [];
            entry.history.push({
                timestamp: new Date().toISOString(),
                summary: changes.length ? changes.join(', ') : reason,
                previous,
                next: nextSpec,
                supersedes: entry.supersedes || []
            });

            entry.current = nextSpec;
            persistExerciseLibrary();
        }

        function populateExerciseSelect() {
            const select = document.getElementById('exercise-select');
            const selectedValue = currentExercise?.id;
            select.innerHTML = '';

            exerciseLibrary.forEach(entry => {
                const opt = document.createElement('option');
                opt.value = entry.id;
                opt.textContent = entry.name;
                if (entry.id === selectedValue) {
                    opt.selected = true;
                }
                select.appendChild(opt);
            });
        }

        function applyLibraryEntryToForm(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            const spec = entry.current || {};

            document.getElementById('exercise-type').value = spec.type || 'reps';
            document.getElementById('sets-input').value = spec.sets || 3;
            document.getElementById('reps-input').value = spec.repsPerSet || 10;
            document.getElementById('target-input').value = spec.secondsPerRep ?? 10;
            updateTargetLabel();
        }

        function playBeep(frequency = 800, duration = 200) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = 'square'; // More noticeable than sine

            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime); // Louder
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration / 1000);
        }

        function playCompletionSound() {
            // Triple beep for completion
            playBeep(1000, 150);
            setTimeout(() => playBeep(1200, 150), 200);
            setTimeout(() => playBeep(1400, 200), 400);
        }

        // Haptic feedback helper (stronger vibrations for better feedback)
        function haptic(style = 'light') {
            if (!preferences.hapticEnabled) return;
            if ('vibrate' in navigator) {
                switch(style) {
                    case 'light':
                        navigator.vibrate(30);
                        break;
                    case 'medium':
                        navigator.vibrate(50);
                        break;
                    case 'heavy':
                        navigator.vibrate(80);
                        break;
                    case 'success':
                        navigator.vibrate([30, 50, 30]);
                        break;
                    case 'error':
                        navigator.vibrate([50, 100, 50]);
                        break;
                }
            }
        }

        const isTimerType = (type) => TIMER_TYPES.includes(type);

        /**
         * POCKET MODE BEHAVIOR
         * --------------------
         * Eyes-free fullscreen overlay for use when phone is in pocket/armband.
         *
         * HOW IT WORKS:
         *
         * For REP-BASED exercises (reps, amrap, distance):
         *   - Large tap area displays current rep count
         *   - Each tap increments the counter
         *   - Audio and haptic feedback confirm each tap
         *   - When target reps reached, set auto-completes
         *
         * For TIME-BASED exercises (timed, hold, duration):
         *   - Large tap area displays countdown timer
         *   - First tap starts the timer
         *   - Second tap pauses the timer
         *   - Timer auto-advances to next rep when complete
         *   - Can log partial reps (if paused) via "Log This Time" button (not in Pocket mode)
         *
         * INTERACTION:
         *   - Tap anywhere on white pad to count/start-pause
         *   - Small X button in top-left to exit (positioned away from tap area)
         *   - All existing audio/haptic cues preserved
         *
         * TODO: Add Pocket mode support for "Log This Rep" when timer paused
         * TODO: Consider voice-only interaction mode (no screen needed)
         */
        // Pocket Mode long-press detection for timer logging
        let pocketPressTimer = null;
        let pocketLongPressTriggered = false;

        function togglePocketMode(enabled) {
            pocketMode = enabled;
            const overlay = document.getElementById('pocket-overlay');
            if (enabled) {
                overlay.classList.add('active');
                haptic('medium');
                setupPocketLongPress();
            } else {
                overlay.classList.remove('active');
                haptic('medium');
                cleanupPocketLongPress();
            }
            updatePocketOverlay();
        }

        function setupPocketLongPress() {
            const overlay = document.getElementById('pocket-overlay');
            overlay.addEventListener('touchstart', handlePocketPressStart, { passive: true });
            overlay.addEventListener('touchend', handlePocketPressEnd, { passive: true });
            overlay.addEventListener('touchcancel', handlePocketPressCancel, { passive: true });
        }

        function cleanupPocketLongPress() {
            const overlay = document.getElementById('pocket-overlay');
            overlay.removeEventListener('touchstart', handlePocketPressStart);
            overlay.removeEventListener('touchend', handlePocketPressEnd);
            overlay.removeEventListener('touchcancel', handlePocketPressCancel);
            if (pocketPressTimer) {
                clearTimeout(pocketPressTimer);
                pocketPressTimer = null;
            }
        }

        function handlePocketPressStart(e) {
            // Ignore if tapping the X button
            if (e.target.closest('.pocket-close')) return;

            pocketLongPressTriggered = false;

            // Only enable long-press for timer exercises
            if (!isTimerType(currentExercise.type)) return;

            // Start long-press timer (700ms for deliberate action)
            pocketPressTimer = setTimeout(() => {
                pocketLongPressTriggered = true;
                handlePocketLongPress();
            }, 700);
        }

        function handlePocketPressEnd(e) {
            if (pocketPressTimer) {
                clearTimeout(pocketPressTimer);
                pocketPressTimer = null;
            }
        }

        function handlePocketPressCancel(e) {
            if (pocketPressTimer) {
                clearTimeout(pocketPressTimer);
                pocketPressTimer = null;
            }
            pocketLongPressTriggered = false;
        }

        function handlePocketLongPress() {
            // Log timer and advance to next rep
            if (isTimerType(currentExercise.type) && timerRunning) {
                logPartialTimerRep();
                updatePocketOverlay();
            }
        }

        function handlePocketTap() {
            if (!pocketMode) return;

            // If long-press was triggered, don't also handle tap
            if (pocketLongPressTriggered) {
                pocketLongPressTriggered = false;
                return;
            }

            if (COUNTER_TYPES.includes(currentExercise.type)) {
                incrementCounter();
            } else if (isTimerType(currentExercise.type)) {
                if (!timerRunning) {
                    startTimer();
                } else {
                    stopTimer();
                }
            }
            updatePocketOverlay();
        }

        function updatePocketOverlay() {
            const overlay = document.getElementById('pocket-overlay');
            if (!overlay.classList.contains('active')) return;

            const setsLeft = Math.max(currentExercise.sets - currentExercise.currentSet, 0);
            const distanceTarget = currentExercise.distanceTarget || currentExercise.repsPerSet || 0;
            const repsLeft = Math.max((currentExercise.repsPerSet || 0) - currentExercise.currentRep, 0);
            const distanceLeft = Math.max(distanceTarget - currentExercise.currentRep, 0);
            const label = COUNTER_TYPES.includes(currentExercise.type)
                ? `${currentExercise.currentRep}`
                : `${formatSeconds(timerSecondsRemaining)}`;

            document.getElementById('pocket-label').textContent = label;

            const metaPieces = [
                `Sets left: ${setsLeft}`
            ];

            if (COUNTER_TYPES.includes(currentExercise.type) && currentExercise.type !== 'amrap' && currentExercise.repsPerSet) {
                if (currentExercise.type === 'distance') {
                    metaPieces.push(`Feet left: ${distanceLeft}`);
                } else {
                    metaPieces.push(`Reps left: ${repsLeft}`);
                }
            }

            if (currentExercise.type === 'amrap' && currentExercise.secondsPerRep) {
                metaPieces.push(`AMRAP ${currentExercise.secondsPerRep}s window`);
            }

            if (currentExercise.type === 'distance') {
                metaPieces.push(`Distance goal: ${distanceTarget} ft`);
            }

            if (isTimerType(currentExercise.type)) {
                metaPieces.push(timerRunning ? 'Timer running' : 'Timer paused');
            }

            document.getElementById('pocket-meta').textContent = metaPieces.join(' ¬∑ ');
        }

        // iOS-style Action Sheet
        function showActionSheet(message, onConfirm) {
            document.getElementById('action-sheet-message').textContent = message;
            actionSheetCallback = onConfirm;

            const backdrop = document.getElementById('action-sheet-backdrop');
            const sheet = document.getElementById('action-sheet');

            backdrop.classList.add('active');
            setTimeout(() => {
                sheet.classList.add('active');
            }, 10);

            haptic('medium');
        }

        function hideActionSheet() {
            const backdrop = document.getElementById('action-sheet-backdrop');
            const sheet = document.getElementById('action-sheet');

            sheet.classList.remove('active');
            setTimeout(() => {
                backdrop.classList.remove('active');
            }, 300);

            actionSheetCallback = null;
            haptic('medium');
        }

        function confirmActionSheet() {
            if (actionSheetCallback) {
                actionSheetCallback();
            }
            hideActionSheet();
            haptic('medium');
        }

        // Counter Functions
        function incrementCounter() {
            if (!COUNTER_TYPES.includes(currentExercise.type)) return;

            currentExercise.currentRep++;
            const entry = getLibraryEntryById(currentExercise.id);
            const hasAlternating = entry && (entry.pattern_modifiers || []).includes('alternating');
            if (hasAlternating && currentExercise.sideOptions && currentExercise.sideOptions.length > 0) {
                const [firstSide, secondSide] = currentExercise.sideOptions;
                currentExercise.alternatingSide = currentExercise.alternatingSide === firstSide ? secondSide : firstSide;
                speak(`Switch to ${currentExercise.alternatingSide} side`);
            }
            haptic('medium');

            const repsLeft = currentExercise.repsPerSet - currentExercise.currentRep;

            // Voice announcements at milestones
            if (currentExercise.repsPerSet && currentExercise.type !== 'amrap') {
                if (repsLeft === 5) speak('5 reps left');
                else if (repsLeft === 3) speak('3 reps left');
                else if (repsLeft === 1) speak('Last rep');
                else if (repsLeft === 0) {
                    playCompletionSound();
                    haptic('success');
                    speak('Set complete');
                }
            }

            updateDisplay();
        }

        function formatSeconds(totalSeconds = 0) {
            const minutes = Math.floor(Math.max(totalSeconds, 0) / 60);
            const seconds = Math.max(totalSeconds % 60, 0);
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function updateDisplay() {
            // Handle no exercise selected
            if (!currentExercise) {
                document.getElementById('exercise-name').textContent = 'No Exercise Selected';
                document.getElementById('set-info').textContent = 'Tap "Exercises" below to choose';
                document.getElementById('remaining-info').textContent = '';
                document.getElementById('counter-mode').classList.add('hidden');
                document.getElementById('timer-mode').classList.add('hidden');
                document.getElementById('main-controls').classList.add('hidden');
                return;
            }

            // Show exercise name with pattern badge
            const entry = getLibraryEntryById(currentExercise.id);
            let exerciseNameDisplay = currentExercise.name;
            if (entry) {
                const patternBadge = ' ' + getPatternBadge(entry.pattern);
                exerciseNameDisplay += patternBadge;
            }
            document.getElementById('exercise-name').textContent = exerciseNameDisplay;

            // For sided exercises, show per-side progress
            const hasSides = currentExercise.sideOptions && currentExercise.sideOptions.length > 0 && !currentExercise.bilateral;
            let setInfoText = `Set ${currentExercise.currentSet} of ${currentExercise.sets}`;

            if (hasSides && currentExercise.baseSets) {
                setInfoText += ` (${currentExercise.baseSets} per side)`;
            }
            document.getElementById('set-info').textContent = setInfoText;

            const setsLeft = Math.max(currentExercise.sets - currentExercise.currentSet, 0);
            const repsLeft = Math.max((currentExercise.repsPerSet || 0) - currentExercise.currentRep, 0);
            const distanceLeft = Math.max((currentExercise.distanceTarget || currentExercise.repsPerSet || 0) - currentExercise.currentRep, 0);

            let remainingLabel = `Sets left: ${setsLeft}`;

            // For sided exercises, show per-side breakdown
            if (hasSides && currentExercise.sideOptions) {
                const sideProgress = {};
                currentExercise.sideOptions.forEach(side => sideProgress[side] = 0);

                // Count completed sets per side
                currentExercise.sessionData.forEach(set => {
                    if (set.side && sideProgress[set.side] !== undefined) {
                        sideProgress[set.side]++;
                    }
                });

                const sideLabels = currentExercise.sideOptions.map(side =>
                    `${side}: ${sideProgress[side]}/${currentExercise.baseSets}`
                ).join(' ¬∑ ');

                // Show alternating indicator if applicable
                const entry = getLibraryEntryById(currentExercise.id);
                const hasAlternating = entry && (entry.pattern_modifiers || []).includes('alternating');
                remainingLabel = `${sideLabels}`;
                if (hasAlternating) {
                    remainingLabel += ' ‚ö° Alternating';
                }
            }

            if (COUNTER_TYPES.includes(currentExercise.type) && currentExercise.type !== 'amrap' && currentExercise.repsPerSet) {
                if (currentExercise.type === 'distance') {
                    remainingLabel += ` ¬∑ Feet left: ${distanceLeft}`;
                } else {
                    remainingLabel += ` ¬∑ Reps left: ${repsLeft}`;
                }
            }
            if (currentExercise.type === 'amrap' && currentExercise.secondsPerRep) {
                remainingLabel += ` ¬∑ ${currentExercise.secondsPerRep}s AMRAP window`;
            }
            if (isTimerType(currentExercise.type)) {
                remainingLabel += ` ¬∑ Time: ${formatSeconds(timerSecondsRemaining)}`;
            }
            document.getElementById('remaining-info').textContent = remainingLabel;

            if (COUNTER_TYPES.includes(currentExercise.type)) {
                document.getElementById('counter-mode').classList.remove('hidden');
                document.getElementById('timer-mode').classList.add('hidden');
                document.getElementById('main-controls').classList.remove('hidden');

                document.getElementById('counter-display').textContent = currentExercise.currentRep;

                let targetText = 'Target: ';
                if (currentExercise.type === 'amrap') {
                    targetText += currentExercise.secondsPerRep ? `${currentExercise.secondsPerRep}s AMRAP window` : 'AMRAP';
                } else if (currentExercise.type === 'distance') {
                    targetText += `${currentExercise.distanceTarget || currentExercise.repsPerSet || 0} ft`;
                } else {
                    targetText += `${currentExercise.repsPerSet} reps`;
                }
                document.getElementById('target-info').textContent = targetText;

                const targetValue = currentExercise.type === 'distance'
                    ? (currentExercise.distanceTarget || currentExercise.repsPerSet || 0)
                    : currentExercise.repsPerSet;
                const progress = targetValue
                    ? Math.min((currentExercise.currentRep / targetValue) * 100, 100)
                    : Math.min((currentExercise.currentSet / currentExercise.sets) * 100, 100);
                document.getElementById('progress-bar').style.width = progress + '%';
            } else {
                document.getElementById('counter-mode').classList.add('hidden');
                document.getElementById('timer-mode').classList.remove('hidden');
                document.getElementById('main-controls').classList.remove('hidden');

                const repLabel = currentExercise.type === 'hold' || currentExercise.type === 'duration'
                    ? `Set ${currentExercise.currentSet} timer`
                    : `Rep ${currentExercise.currentRep + 1} of ${currentExercise.repsPerSet}`;
                document.getElementById('timer-rep-info').textContent = repLabel;

                const display = formatSeconds(timerSecondsRemaining);
                document.getElementById('timer-display').textContent = display;

                const timerLabel = currentExercise.type === 'duration'
                    ? `Target: ${currentExercise.secondsPerRep || 0}s total`
                    : `Target: ${currentExercise.secondsPerRep || 0} seconds`;
                document.getElementById('timer-target').textContent = timerLabel;

                const progress = currentExercise.secondsPerRep
                    ? Math.max(0, (timerSecondsRemaining / currentExercise.secondsPerRep) * 100)
                    : 0;
                document.getElementById('timer-progress-bar').style.width = progress + '%';

                const timerDisplay = document.getElementById('timer-display');
                timerDisplay.classList.remove('warning', 'danger');
                if (timerSecondsRemaining <= 5 && timerSecondsRemaining > 0) {
                    timerDisplay.classList.add('danger');
                } else if (timerSecondsRemaining <= 10 && timerSecondsRemaining > 5) {
                    timerDisplay.classList.add('warning');
                }

                const logControls = document.getElementById('timer-log-controls');
                if (timerRunning) {
                    document.getElementById('timer-start-btn').classList.add('hidden');
                    document.getElementById('timer-stop-btn').classList.remove('hidden');
                    document.getElementById('timer-reset-btn').classList.add('hidden');
                    logControls.style.display = 'none';
                } else if (timerSecondsRemaining === 0 || timerSecondsRemaining === currentExercise.secondsPerRep) {
                    document.getElementById('timer-start-btn').classList.remove('hidden');
                    document.getElementById('timer-stop-btn').classList.add('hidden');
                    document.getElementById('timer-reset-btn').classList.add('hidden');
                    logControls.style.display = 'none';
                } else {
                    // Timer is paused mid-rep
                    document.getElementById('timer-start-btn').classList.remove('hidden');
                    document.getElementById('timer-stop-btn').classList.add('hidden');
                    document.getElementById('timer-reset-btn').classList.remove('hidden');
                    // Show "Log This Time & Next Rep" button when paused
                    logControls.style.display = 'flex';
                }
            }

            // Update side selector for unilateral exercises
            updateCurrentSideSelector();

            updatePocketOverlay();
        }

        function startTimer() {
            if (timerInterval || !isTimerType(currentExercise.type)) return;

            const targetSeconds = Math.max(currentExercise.secondsPerRep || 0, 1);

            // Initialize timer if starting fresh
            if (timerSecondsRemaining === 0) {
                timerSecondsRemaining = targetSeconds;
            }

            timerRunning = true;
            playBeep(400, 100); // Audio feedback for resume
            haptic('heavy'); // Stronger haptic for resume

            timerInterval = setInterval(() => {
                timerSecondsRemaining--;
                updateDisplay();

                // Countdown beeps
                if (timerSecondsRemaining <= 3 && timerSecondsRemaining > 0) {
                    playBeep(600, 100);
                    haptic('medium');
                }

                // Timer complete
                if (timerSecondsRemaining <= 0) {
                    stopTimer();
                    playCompletionSound();
                    haptic('success');

                    currentExercise.currentRep++;
                    const entry = getLibraryEntryById(currentExercise.id);
                    const hasAlternating = entry && (entry.pattern_modifiers || []).includes('alternating');
                    if (hasAlternating && currentExercise.sideOptions && currentExercise.sideOptions.length > 0) {
                        const [firstSide, secondSide] = currentExercise.sideOptions;
                        currentExercise.alternatingSide = currentExercise.alternatingSide === firstSide ? secondSide : firstSide;
                        speak(`Switch to ${currentExercise.alternatingSide} side`);
                    }

                    const repsLeft = currentExercise.repsPerSet - currentExercise.currentRep;
                    if (repsLeft === 0) speak('Set complete');
                    else if (repsLeft === 1) speak('Last rep');
                    else speak(`${repsLeft} reps left`);

                    // Auto-complete holds/durations when rep target is reached
                    if (currentExercise.type !== 'timed' && currentExercise.repsPerSet && currentExercise.currentRep >= currentExercise.repsPerSet) {
                        updateDisplay();
                        return;
                    }

                    // Reset timer for next rep
                    timerSecondsRemaining = targetSeconds;
                    updateDisplay();
                }
            }, 1000);

            updateDisplay();
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            timerRunning = false;
            playBeep(300, 100); // Audio feedback for pause
            haptic('heavy'); // Stronger haptic for pause
            updateDisplay();
        }

        function seedTimerSeconds() {
            timerSecondsRemaining = isTimerType(currentExercise.type)
                ? Math.max(currentExercise.secondsPerRep || 0, 1)
                : 0;
        }

        function resetTimer() {
            stopTimer();
            seedTimerSeconds();
            haptic('heavy');
            updateDisplay();
        }

        // Log the current partial timer value and advance to next rep
        function logPartialTimerRep() {
            const achievedSeconds = Math.max(currentExercise.secondsPerRep || 0, 1) - timerSecondsRemaining;

            // Record this rep with the actual time achieved (not target)
            const setData = {
                set: currentExercise.currentSet,
                reps: 1,
                secondsAchieved: achievedSeconds,
                secondsTarget: currentExercise.secondsPerRep || 0,
                type: currentExercise.type,
                timestamp: new Date().toISOString(),
                partialRep: true
            };

            // Add side information for unilateral exercises (but not alternating)
            if (currentWorkingSide !== 'both' && currentWorkingSide !== 'alternating') {
                setData.side = currentWorkingSide;
            }

            currentExercise.sessionData.push(setData);

            playBeep(500, 150);
            haptic('success');
            speak(`Logged ${achievedSeconds} seconds`);

            currentExercise.currentRep++;
            const entry = getLibraryEntryById(currentExercise.id);
            const hasAlternating = entry && (entry.pattern_modifiers || []).includes('alternating');
            if (hasAlternating && currentExercise.sideOptions && currentExercise.sideOptions.length > 0) {
                const [firstSide, secondSide] = currentExercise.sideOptions;
                currentExercise.alternatingSide = currentExercise.alternatingSide === firstSide ? secondSide : firstSide;
                speak(`Switch to ${currentExercise.alternatingSide} side`);
            }

            const repsLeft = currentExercise.repsPerSet - currentExercise.currentRep;
            if (repsLeft === 0) {
                speak('Set complete');
                seedTimerSeconds();
                updateDisplay();
            } else {
                if (repsLeft === 1) speak('Last rep');
                else speak(`${repsLeft} reps left`);

                // Reset timer for next rep
                seedTimerSeconds();
                updateDisplay();
            }
        }

        function getTargetValueForCurrentExercise() {
            // Duration exercises track seconds per set rather than reps.
            if (currentExercise.type === 'duration') {
                return currentExercise.secondsPerRep || 0;
            }
            if (currentExercise.type === 'distance') {
                return currentExercise.distanceTarget || currentExercise.repsPerSet || 0;
            }
            return currentExercise.repsPerSet || 0;
        }

        function getNextSetLogValue() {
            // Keep duration "Next Set" values aligned to seconds targets.
            if (currentExercise.type === 'duration') {
                return currentExercise.secondsPerRep || 0;
            }
            const targetValue = getTargetValueForCurrentExercise();
            return currentExercise.currentRep > 0 ? currentExercise.currentRep : targetValue;
        }

        function buildNextSetSummary() {
            const targetValue = getTargetValueForCurrentExercise();
            const logValue = getNextSetLogValue();

            if (currentExercise.type === 'distance') {
                return `${logValue} ft (target ${targetValue} ft)`;
            }

            // Duration summaries should display seconds, not reps.
            if (currentExercise.type === 'duration') {
                return `${logValue}s (target ${targetValue}s)`;
            }

            if (currentExercise.type === 'amrap') {
                return `${logValue} reps (AMRAP ${currentExercise.secondsPerRep || 0}s)`;
            }

            if (isTimerType(currentExercise.type)) {
                return `${logValue} reps @ ${currentExercise.secondsPerRep || 0}s`;
            }

            return `${logValue} reps (target ${targetValue})`;
        }

        function showNextSetModal() {
            if (!currentExercise) return;
            const summary = buildNextSetSummary();
            document.getElementById('next-set-summary').textContent = summary;
            document.getElementById('next-set-modal').classList.add('active');
            haptic('medium');
        }

        function closeNextSetModal() {
            document.getElementById('next-set-modal').classList.remove('active');
            haptic('medium');
        }

        // iOS Safari/PWA does not reliably support onclick; unified pointer-based event handling enforced for iOS and desktop.
        // Problem: inline onclick and click handlers are unreliable on iOS PWA. Fix: use pointerup + keydown bindings.
        function bindPointerHandlers(root = document) {
            const elements = root.querySelectorAll('[data-action], [data-actions], [data-href], [data-reload], [data-open-url], [data-click-target]');
            elements.forEach((element) => {
                if (element.dataset.pointerBound === 'true') return;
                element.dataset.pointerBound = 'true';

                const handleActivation = (event) => {
                    if (element.dataset.requireSelf === 'true' && event.target !== element) return;
                    if (element.dataset.stopPropagation === 'true') event.stopPropagation();

                    if (element.dataset.actions) {
                        element.dataset.actions.split(',').forEach((actionName) => {
                            const action = window[actionName.trim()];
                            if (typeof action === 'function') action();
                        });
                        return;
                    }

                    if (element.dataset.action) {
                        const action = window[element.dataset.action];
                        if (typeof action === 'function') {
                            const args = [];
                            if (element.dataset.actionArgSource) {
                                const source = document.querySelector(element.dataset.actionArgSource);
                                args.push(source ? source.value : '');
                            }
                            if (element.dataset.actionArgNumber !== undefined) args.push(Number(element.dataset.actionArgNumber));
                            if (element.dataset.actionArgBool !== undefined) args.push(element.dataset.actionArgBool === 'true');
                            if (element.dataset.actionArg !== undefined) args.push(element.dataset.actionArg);
                            if (element.dataset.actionPassEvent === 'true') args.push(event);
                            action(...args);
                        }
                        return;
                    }

                    if (element.dataset.href) {
                        window.location.href = element.dataset.href;
                        return;
                    }
                    if (element.dataset.reload === 'true') {
                        window.location.reload();
                        return;
                    }
                    if (element.dataset.openUrl) {
                        window.open(element.dataset.openUrl, element.dataset.openTarget || '_blank');
                        return;
                    }
                    if (element.dataset.clickTarget) {
                        const target = document.getElementById(element.dataset.clickTarget);
                        if (target) target.click();
                    }
                };

                element.addEventListener('pointerup', handleActivation);
                if (element.tagName !== 'BUTTON') {
                    element.addEventListener('keydown', (event) => {
                        if (event.key === 'Enter' || event.key === ' ') {
                            handleActivation(event);
                        }
                    });
                }
            });
        }

        function bindExerciseSearchEvents() {
            const searchInput = document.getElementById('exercise-search');
            if (!searchInput || searchInput.dataset.searchBound === 'true') return;
            searchInput.dataset.searchBound = 'true';

            const applyFilter = () => filterExercises();
            ['input', 'change', 'keyup', 'search'].forEach((eventName) => {
                searchInput.addEventListener(eventName, applyFilter);
            });
        }

        function bindTouchActivation(elementId, handler) {
            const element = document.getElementById(elementId);
            if (!element) return;
            if (element.dataset.pointerBound === 'true') return;
            // iOS Safari/PWA does not reliably support onclick; unified pointer-based event handling enforced for iOS and desktop.
            // Problem: onclick can miss taps on iOS; Fix: pointerup activation while preserving existing handler.
            element.addEventListener('pointerup', handler);
        }

        function editNextSet() {
            closeNextSetModal();
            const logValue = getNextSetLogValue();
            if (currentExercise.type === 'distance') {
                showLogSetModal({ presetDistance: logValue });
            // Duration exercises use seconds input in the manual log modal.
            } else if (currentExercise.type === 'duration') {
                showLogSetModal({ presetSeconds: logValue });
            } else {
                showLogSetModal({ presetReps: logValue });
            }
        }

        function confirmNextSet() {
            const logValue = getNextSetLogValue();
            const entry = getLibraryEntryById(currentExercise.id);
            const formParams = entry?.form_parameters_required || [];

            // If exercise has form parameters, show modal to collect them
            // Note: Side selection from Next Set modal is not preserved (user must reselect in log modal)
            if (formParams.length > 0) {
                closeNextSetModal();
                editNextSet(); // Opens log set modal with form parameters
                return;
            }

            closeNextSetModal();
            logCurrentSetAndAdvance({ logValue });
        }

        function logCurrentSetAndAdvance({ logValue, manualLog = false, skipZeroPrompt = false } = {}) {
            const targetValue = getTargetValueForCurrentExercise();
            const entry = getLibraryEntryById(currentExercise.id);
            const finalValue = logValue ?? targetValue;
            const isDistance = currentExercise.type === 'distance';
            const isDuration = currentExercise.type === 'duration';

            if (finalValue === 0 && !skipZeroPrompt) {
                showActionSheet('‚ö†Ô∏è Log 0 for this set?\n\nThis will log an empty set and move to the next set.\n\nTip: Use "Log Set" to manually enter values.', () => {
                    logCurrentSetAndAdvance({ logValue: 0, manualLog, skipZeroPrompt: true });
                });
                return;
            }

            const setData = {
                set: currentExercise.currentSet,
                // Keep reps at 1 for distance/duration so downstream logic remains consistent.
                reps: isDistance || isDuration ? 1 : finalValue,
                type: currentExercise.type,
                timestamp: new Date().toISOString()
            };

            if (manualLog) {
                setData.manualLog = true;
            }

            if (isDistance) {
                setData.distanceFeet = finalValue;
            }
            // Store duration in seconds for duration-based exercises.
            if (isDuration) {
                setData.secondsAchieved = finalValue;
                setData.secondsTarget = currentExercise.secondsPerRep || 0;
            }

            // Add side information for unilateral exercises (but not alternating)
            if (currentWorkingSide !== 'both' && currentWorkingSide !== 'alternating') {
                setData.side = currentWorkingSide;
            }

            currentExercise.sessionData.push(setData);

            haptic('success');
            speak(`Set ${currentExercise.currentSet} logged`);

            // Check for progress (duration uses seconds, distance uses feet, otherwise reps).
            detectProgress(currentExercise.currentSet, finalValue);

            if (currentExercise.currentSet < currentExercise.sets) {
                currentExercise.currentSet++;
                currentExercise.currentRep = 0;
                seedTimerSeconds();
                stopTimer();
                updateDisplay();

                const restSeconds = entry?.details?.restSeconds;
                if (restSeconds && restSeconds > 0) {
                    showRestTimer(restSeconds);
                }
            } else {
                speak('All sets complete');
                const formParams = entry?.form_parameters_required || [];
                if (formParams.length > 0) {
                    showFormParamsModal();
                } else {
                    showSessionNotesModal();
                }
            }
        }

        function completeSet() {
            showNextSetModal();
        }

        /**
         * EXERCISE EXECUTION DATA TRACKING
         * ---------------------------------
         * When performing an exercise, this app currently tracks:
         *
         * currentExercise.sessionData[] contains:
         *   - set: which set number (1-based)
         *   - reps: how many reps completed
         *   - type: exercise type (reps, timed, hold, etc.)
         *   - timestamp: ISO datetime of completion
         *   - side: (optional) which side for unilateral exercises ('left', 'right', 'both')
         *   - weight: (optional) weight used in lb/kg
         *   - weightUnit: (optional) 'lb' or 'kg'
         *   - resistance: (optional) resistance band level ('light', 'medium', 'heavy')
         *   - secondsAchieved: (optional) actual time held (for partial timer reps)
         *   - secondsTarget: (optional) target time (for partial timer reps)
         *   - partialRep: (optional) true if logged early via "Log This Time"
         *   - manualLog: (optional) true if logged via "Log Set" modal
         *
         * At session completion (all sets done):
         *   - sessionData is saved to the in-memory cache and queued to Firestore
         *   - Includes: exerciseId, exerciseName, date, sets[], notes
         *
         * TODO: Define "session" concept - when does it start/end? How to group exercises?
         * TODO: Add session planning (which exercises in what order for today)
         * TODO: Track adherence to program-level dosage prescriptions
         * TODO: Progressive overload tracking (weight/resistance over time)
         */
        function finishSet() {
            const setData = {
                set: currentExercise.currentSet,
                reps: currentExercise.currentRep,
                type: currentExercise.type,
                timestamp: new Date().toISOString()
            };

            // Add side information for unilateral exercises (but not alternating)
            if (currentWorkingSide !== 'both' && currentWorkingSide !== 'alternating') {
                setData.side = currentWorkingSide;
            }

            currentExercise.sessionData.push(setData);

            if (currentExercise.currentSet < currentExercise.sets) {
                currentExercise.currentSet++;
                currentExercise.currentRep = 0;
                seedTimerSeconds();
                stopTimer();
                updateDisplay();
            } else {
                // Check if form parameters need to be logged
                const entry = getLibraryEntryById(currentExercise.id);
                const formParams = entry?.form_parameters_required || [];
                if (formParams.length > 0) {
                    showFormParamsModal();
                } else {
                    showSessionNotesModal();
                }
            }
        }

        let logSetSide = 'both'; // Track which side for unilateral exercises
        let currentWorkingSide = 'both'; // Track which side for current set during rep/timer

        function updateCurrentSideSelector() {
            const entry = getLibraryEntryById(currentExercise?.id);
            if (!entry) return;

            const sideOptions = entry.sideOptions || [];
            const isBilateral = isBilateralPattern(entry.pattern);
            const hasAlternating = entry && (entry.pattern_modifiers || []).includes('alternating');
            const selectorContainer = document.getElementById('current-side-selector');
            const buttonsContainer = document.getElementById('current-side-buttons');

            // For alternating exercises, show indicator instead of selector
            if (hasAlternating && sideOptions.length > 0 && !isBilateral) {
                const alternatingSide = currentExercise?.alternatingSide || sideOptions[0] || 'left';
                buttonsContainer.innerHTML = `
                    <div style="
                        flex: 1;
                        padding: 14px 10px;
                        border-radius: 12px;
                        border: 3px solid var(--ios-orange);
                        background: rgba(255,149,0,0.1);
                        text-align: center;
                    ">
                        <div style="font-size: 20px; margin-bottom: 2px;">‚ö°</div>
                        <div style="font-size: 15px; font-weight: 700; text-transform: uppercase; color: var(--text-primary); margin-bottom: 4px;">
                            ALTERNATING
                        </div>
                        <div style="font-size: 12px; font-weight: 600; color: var(--ios-gray);">
                            Next side: ${alternatingSide.toUpperCase()}
                        </div>
                    </div>
                `;
                selectorContainer.style.display = 'block';
                currentWorkingSide = 'alternating'; // Special marker
                return;
            }

            // Show selector only for non-alternating unilateral exercises
            if (sideOptions.length > 0 && !isBilateral) {
                // Count completed sets per side
                const sideProgress = {};
                sideOptions.forEach(side => sideProgress[side] = 0);
                currentExercise.sessionData.forEach(set => {
                    if (set.side && sideProgress[set.side] !== undefined) {
                        // Set with specific side (left or right)
                        sideProgress[set.side]++;
                    } else if (!set.side) {
                        // Set without side = alternating set, counts for ALL sides
                        sideOptions.forEach(side => sideProgress[side]++);
                    }
                });

                const targetSets = currentExercise.baseSets || 0;

                // Auto-select side that needs more work if currentWorkingSide is 'both'
                if (currentWorkingSide === 'both' || !sideOptions.includes(currentWorkingSide)) {
                    // Find which side needs more sets
                    for (const side of sideOptions) {
                        if (sideProgress[side] < targetSets) {
                            currentWorkingSide = side;
                            break;
                        }
                    }
                    // If both complete or equal, default to first option
                    if (currentWorkingSide === 'both') {
                        currentWorkingSide = sideOptions[0];
                    }
                }

                // Render side buttons
                buttonsContainer.innerHTML = sideOptions.map(side => {
                    const completed = sideProgress[side];
                    const isSelected = currentWorkingSide === side;
                    const isComplete = completed >= targetSets;
                    const emoji = side === 'left' ? 'üëà' : side === 'right' ? 'üëâ' : '';

                    return `
                        <div data-action="selectCurrentSide" data-action-arg="${side}" role="button" tabindex="0" style="
                            flex: 1;
                            cursor: pointer;
                            padding: 14px 10px;
                            border-radius: 12px;
                            border: 3px solid ${isSelected ? 'var(--ios-blue)' : isComplete ? 'var(--ios-green)' : 'var(--border-color)'};
                            background: ${isSelected ? 'var(--ios-blue)' : isComplete ? 'rgba(52,199,89,0.1)' : 'var(--bg-secondary)'};
                            text-align: center;
                            transition: all 0.2s;
                            ${isSelected ? 'transform: scale(1.05); box-shadow: 0 4px 12px rgba(0,122,255,0.3);' : ''}
                        ">
                            <div style="font-size: 20px; margin-bottom: 2px;">${emoji}</div>
                            <div style="font-size: 15px; font-weight: 700; text-transform: uppercase; color: ${isSelected ? 'white' : 'var(--text-primary)'}; margin-bottom: 4px;">
                                ${side}
                            </div>
                            <div style="font-size: 12px; font-weight: 600; color: ${isSelected ? 'rgba(255,255,255,0.9)' : isComplete ? 'var(--ios-green)' : 'var(--ios-gray)'};">
                                ${completed}/${targetSets} ${isComplete ? '‚úì' : ''}
                            </div>
                        </div>
                    `;
                }).join('');

                bindPointerHandlers(buttonsContainer);
                selectorContainer.style.display = 'block';
            } else {
                selectorContainer.style.display = 'none';
                currentWorkingSide = 'both';
            }
        }

        function selectCurrentSide(side) {
            currentWorkingSide = side;
            updateCurrentSideSelector();
            haptic('light');
            speak(`Working ${side} side`);
        }

        function showLogSetModal({ presetReps = null, presetDistance = null, presetSeconds = null } = {}) {
            const targetReps = currentExercise.repsPerSet || 0;
            const targetSeconds = currentExercise.secondsPerRep || 0;
            document.getElementById('log-set-title').textContent = `Log Set ${currentExercise.currentSet}`;

            // Show side selector for unilateral exercises
            const entry = getLibraryEntryById(currentExercise.id);
            const isBilateral = isBilateralPattern(entry.pattern);
            const sideOptions = entry.sideOptions || [];
            const modifiers = entry.pattern_modifiers || [];
            const hasDistance = modifiers.includes('distance_feet');
            // Duration exercises log seconds, regardless of modifiers.
            const isDuration = currentExercise.type === 'duration';
            const spec = entry.current || {};
            const targetDistance = spec.distanceFeet || currentExercise.distanceTarget || 0;

            // Show/hide reps vs distance fields
            const repsField = document.getElementById('log-set-reps');
            const distanceField = document.getElementById('log-set-distance');
            const secondsField = document.getElementById('log-set-seconds');
            if (hasDistance) {
                repsField.style.display = 'none';
                distanceField.style.display = 'block';
                secondsField.style.display = 'none';
                distanceField.value = presetDistance ?? targetDistance;
            } else if (isDuration) {
                // Duration: show seconds input only.
                repsField.style.display = 'none';
                distanceField.style.display = 'none';
                secondsField.style.display = 'block';
                secondsField.value = presetSeconds ?? targetSeconds;
            } else {
                repsField.style.display = 'block';
                distanceField.style.display = 'none';
                secondsField.style.display = 'none';
                repsField.value = presetReps ?? targetReps;
            }

            // For sided exercises, show which sides need more sets
            const hasAlternating = entry && (entry.pattern_modifiers || []).includes('alternating');
            let subtitleText = hasDistance
                ? `Target: ${targetDistance}ft ¬∑ Enter actual distance covered`
                : isDuration
                    ? `Target: ${targetSeconds}s ¬∑ Enter actual seconds performed`
                    : `Target: ${targetReps} reps ¬∑ Enter actual reps performed`;
            if (sideOptions.length > 0 && !isBilateral && currentExercise.baseSets) {
                // Count completed sets per side
                const sideProgress = {};
                sideOptions.forEach(side => sideProgress[side] = 0);
                currentExercise.sessionData.forEach(set => {
                    if (set.side && sideProgress[set.side] !== undefined) {
                        // Set with specific side (left or right)
                        sideProgress[set.side]++;
                    } else if (!set.side) {
                        // Set without side = alternating set, counts for ALL sides
                        sideOptions.forEach(side => sideProgress[side]++);
                    }
                });

                // Find which side needs more sets (for smart default selection)
                let suggestedSide = sideOptions[0];
                for (const side of sideOptions) {
                    if (sideProgress[side] < currentExercise.baseSets) {
                        suggestedSide = side;
                        break;
                    }
                }

                const progressText = sideOptions.map(side =>
                    `${side}: ${sideProgress[side]}/${currentExercise.baseSets}`
                ).join(', ');
                const fieldType = hasDistance ? 'distance' : isDuration ? 'seconds' : 'reps';
                subtitleText = `${progressText} ¬∑ Enter ${fieldType} for selected side`;
                if (hasAlternating) {
                    subtitleText += ' ¬∑ ‚ö° ALTERNATE sides each rep';
                }
                logSetSide = suggestedSide;
            } else {
                logSetSide = sideOptions[0] || 'both';
            }

            document.getElementById('log-set-subtitle').textContent = subtitleText;

            // Dynamic form parameters
            const formParams = entry.form_parameters_required || [];
            const formParamsContainer = document.getElementById('log-set-form-params');
            const formParamsFields = document.getElementById('log-set-form-params-fields');

            if (formParams.length > 0) {
                formParamsFields.innerHTML = formParams.map(param => {
                    if (param === 'weight') {
                        return `
                            <label style="font-size: 13px; margin-bottom: 4px; display: block;">${param.replace('_', ' ')}</label>
                            <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                                <input type="number" class="modal-input" id="log-param-${param}" placeholder="Weight" min="0" step="1" style="flex: 1; margin: 0;" data-param="${param}">
                                <select class="modal-select" id="log-param-${param}-unit" style="flex: 0 0 auto; width: 80px; margin: 0;">
                                    <option value="lb">lb</option>
                                </select>
                            </div>
                        `;
                    } else if (param === 'distance') {
                        return `
                            <label style="font-size: 13px; margin-bottom: 4px; display: block;">${param} (variable, e.g. step height)</label>
                            <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                                <input type="number" class="modal-input" id="log-param-${param}" placeholder="Distance" min="0" step="1" style="flex: 1; margin: 0;" data-param="${param}">
                                <select class="modal-select" id="log-param-${param}-unit" style="flex: 0 0 auto; width: 90px; margin: 0;">
                                    <option value="ft">ft</option>
                                    <option value="inch">inch</option>
                                    <option value="cm">cm</option>
                                    <option value="degree">degree</option>
                                </select>
                            </div>
                        `;
                    } else if (param === 'alternating') {
                        // Skip alternating (pattern modifier, not form param)
                        return '';
                    } else {
                        // Use smart select for all other parameters (band_resistance, eyes, surface, etc.)
                        const includeGlobal = param === 'band_position';
                        return renderSmartParamSelect(param, currentExercise.id, `log-param-${param}`, { includeGlobal });
                    }
                }).join('');
                formParamsContainer.style.display = 'block';
            } else {
                formParamsContainer.style.display = 'none';
            }

            const sideContainer = document.getElementById('log-set-side-selector');
            if (sideOptions.length > 0 && !isBilateral) {
                // Count completed sets per side for progress display
                const sideProgress = {};
                sideOptions.forEach(side => sideProgress[side] = 0);
                currentExercise.sessionData.forEach(set => {
                    if (set.side && sideProgress[set.side] !== undefined) {
                        sideProgress[set.side]++;
                    }
                });

                const targetSets = currentExercise.baseSets || 0;

                sideContainer.innerHTML = '<div style="font-size: 15px; font-weight: 700; margin-bottom: 12px; text-align: center; color: var(--text-primary);">üìç SELECT SIDE FOR THIS SET:</div>' +
                    '<div style="display: flex; gap: 12px;">' +
                    sideOptions.map(side => {
                        const completed = sideProgress[side];
                        const isSelected = logSetSide === side;
                        const isComplete = completed >= targetSets;
                        const emoji = side === 'left' ? 'üëà' : side === 'right' ? 'üëâ' : '';

                        return `
                            <div data-action="selectLogSetSide" data-action-arg="${side}" role="button" tabindex="0" style="
                                flex: 1;
                                cursor: pointer;
                                padding: 16px 12px;
                                border-radius: 12px;
                                border: 3px solid ${isSelected ? 'var(--ios-blue)' : isComplete ? 'var(--ios-green)' : 'var(--border-color)'};
                                background: ${isSelected ? 'var(--ios-blue)' : isComplete ? 'rgba(52,199,89,0.1)' : 'var(--bg-secondary)'};
                                text-align: center;
                                transition: all 0.2s;
                                ${isSelected ? 'transform: scale(1.05); box-shadow: 0 4px 12px rgba(0,122,255,0.3);' : ''}
                            ">
                                <div style="font-size: 24px; margin-bottom: 4px;">${emoji}</div>
                                <div style="font-size: 16px; font-weight: 700; text-transform: uppercase; color: ${isSelected ? 'white' : 'var(--text-primary)'}; margin-bottom: 6px;">
                                    ${side}
                                </div>
                                <div style="font-size: 13px; font-weight: 600; color: ${isSelected ? 'rgba(255,255,255,0.9)' : isComplete ? 'var(--ios-green)' : 'var(--ios-gray)'};">
                                    ${completed}/${targetSets} sets ${isComplete ? '‚úì' : ''}
                                </div>
                            </div>
                        `;
                    }).join('') +
                    '</div>';
                bindPointerHandlers(sideContainer);
            } else {
                sideContainer.innerHTML = '';
                logSetSide = 'both';
            }

            document.getElementById('log-set-modal').classList.add('active');
            haptic('medium');

            // Auto-focus the correct input field
            setTimeout(() => {
                const fieldToFocus = hasDistance ? distanceField : repsField;
                fieldToFocus.focus();
                fieldToFocus.select();
            }, 300);
        }

        function selectLogSetSide(side) {
            logSetSide = side;
            const entry = getLibraryEntryById(currentExercise.id);
            const sideOptions = entry.sideOptions || [];

            // Count completed sets per side for progress display
            const sideProgress = {};
            sideOptions.forEach(s => sideProgress[s] = 0);
            currentExercise.sessionData.forEach(set => {
                if (set.side && sideProgress[set.side] !== undefined) {
                    sideProgress[set.side]++;
                }
            });

            const targetSets = currentExercise.baseSets || 0;
            const sideContainer = document.getElementById('log-set-side-selector');

            sideContainer.innerHTML = '<div style="font-size: 15px; font-weight: 700; margin-bottom: 12px; text-align: center; color: var(--text-primary);">üìç SELECT SIDE FOR THIS SET:</div>' +
                '<div style="display: flex; gap: 12px;">' +
                sideOptions.map(s => {
                    const completed = sideProgress[s];
                    const isSelected = logSetSide === s;
                    const isComplete = completed >= targetSets;
                    const emoji = s === 'left' ? 'üëà' : s === 'right' ? 'üëâ' : '';

                    return `
                        <div data-action="selectLogSetSide" data-action-arg="${s}" role="button" tabindex="0" style="
                            flex: 1;
                            cursor: pointer;
                            padding: 16px 12px;
                            border-radius: 12px;
                            border: 3px solid ${isSelected ? 'var(--ios-blue)' : isComplete ? 'var(--ios-green)' : 'var(--border-color)'};
                            background: ${isSelected ? 'var(--ios-blue)' : isComplete ? 'rgba(52,199,89,0.1)' : 'var(--bg-secondary)'};
                            text-align: center;
                            transition: all 0.2s;
                            ${isSelected ? 'transform: scale(1.05); box-shadow: 0 4px 12px rgba(0,122,255,0.3);' : ''}
                        ">
                            <div style="font-size: 24px; margin-bottom: 4px;">${emoji}</div>
                            <div style="font-size: 16px; font-weight: 700; text-transform: uppercase; color: ${isSelected ? 'white' : 'var(--text-primary)'}; margin-bottom: 6px;">
                                ${s}
                            </div>
                            <div style="font-size: 13px; font-weight: 600; color: ${isSelected ? 'rgba(255,255,255,0.9)' : isComplete ? 'var(--ios-green)' : 'var(--ios-gray)'};">
                                ${completed}/${targetSets} sets ${isComplete ? '‚úì' : ''}
                            </div>
                        </div>
                    `;
                }).join('') +
                '</div>';
            bindPointerHandlers(sideContainer);

            haptic('light');
        }

        function closeLogSetModal() {
            document.getElementById('log-set-modal').classList.remove('active');
            haptic('medium');
        }

        function saveLoggedSet() {
            const entry = getLibraryEntryById(currentExercise.id);
            const modifiers = entry.pattern_modifiers || [];
            const hasDistance = modifiers.includes('distance_feet');
            // Duration exercises log seconds instead of reps.
            const isDuration = currentExercise.type === 'duration';

            let reps, distance, seconds, logMessage;

            if (hasDistance) {
                distance = parseInt(document.getElementById('log-set-distance').value);
                if (isNaN(distance) || distance < 0) {
                    alert('Please enter a valid distance (0 or more feet).');
                    return;
                }
                reps = 1; // Set to 1 for data structure, but not used
                logMessage = `Set ${currentExercise.currentSet} logged: ${distance}ft`;
            } else if (isDuration) {
                seconds = parseInt(document.getElementById('log-set-seconds').value);
                if (isNaN(seconds) || seconds < 0) {
                    alert('Please enter valid seconds (0 or more).');
                    return;
                }
                // Duration sets store seconds achieved/target; reps is a placeholder.
                reps = 1; // Keep data structure consistent for duration sets
                logMessage = `Set ${currentExercise.currentSet} logged: ${seconds}s`;
            } else {
                reps = parseInt(document.getElementById('log-set-reps').value);
                if (isNaN(reps) || reps < 0) {
                    alert('Please enter a valid number of reps (0 or more).');
                    return;
                }
                logMessage = `Set ${currentExercise.currentSet} logged: ${reps} reps`;
            }

            const setData = {
                set: currentExercise.currentSet,
                reps: reps,
                type: currentExercise.type,
                timestamp: new Date().toISOString(),
                manualLog: true
            };

            // Add distance if applicable
            if (hasDistance && distance >= 0) {
                setData.distanceFeet = distance;
            }
            if (isDuration && seconds >= 0) {
                // Preserve duration metrics for downstream analytics.
                setData.secondsAchieved = seconds;
                setData.secondsTarget = currentExercise.secondsPerRep || 0;
            }

            // Add side if applicable
            if (logSetSide && logSetSide !== 'both') {
                setData.side = logSetSide;
            }

            // Add dynamic form parameters
            const formParams = entry.form_parameters_required || [];
            const formParamsData = {};
            formParams.forEach(param => {
                if (param === 'alternating') return; // Skip alternating (will be in pattern_modifiers)

                const inputElement = document.getElementById(`log-param-${param}`);
                if (!inputElement) return;

                let value = inputElement.value;
                if (param === 'weight' && value) {
                    const weightValue = parseInt(value, 10);
                    if (!isNaN(weightValue) && weightValue >= 0) {
                        const unitElement = document.getElementById(`log-param-${param}-unit`);
                        formParamsData[param] = weightValue;
                        formParamsData[`${param}_unit`] = unitElement ? unitElement.value : 'lb';
                    }
                } else if (param === 'distance' && value) {
                    const distValue = parseInt(value, 10);
                    if (!isNaN(distValue) && distValue >= 0) {
                        formParamsData[param] = distValue;
                        const unitElement = document.getElementById(`log-param-${param}-unit`);
                        formParamsData[`${param}_unit`] = unitElement ? unitElement.value : 'ft';
                    }
                } else if (value && value !== '') {
                    if (inputElement.tagName === 'SELECT') {
                        const selectValue = readParamSelectValue(inputElement);
                        if (selectValue) {
                            formParamsData[param] = selectValue;
                        }
                    } else {
                        formParamsData[param] = value;
                    }
                }
            });

            if (Object.keys(formParamsData).length > 0) {
                setData.formParams = formParamsData;
            }

            currentExercise.sessionData.push(setData);

            closeLogSetModal();
            haptic('success');
            speak(logMessage);

            // Check for progress (duration uses seconds, distance uses feet).
            detectProgress(currentExercise.currentSet, isDuration ? seconds : hasDistance ? distance : reps);

            if (currentExercise.currentSet < currentExercise.sets) {
                currentExercise.currentSet++;
                currentExercise.currentRep = 0;
                seedTimerSeconds();
                stopTimer();
                updateDisplay();
            } else {
                speak('All sets complete');
                showSessionNotesModal();
            }
        }

        // Smart Progress Detection
        function detectProgress(setNumber, reps) {
            const sessions = loadHistory();
            const previousSessions = sessions.filter(s => s.exerciseId === currentExercise.id);

            if (previousSessions.length === 0) return; // First time doing this exercise

            const lastSession = previousSessions[previousSessions.length - 1];
            const lastSet = lastSession.sets && lastSession.sets[setNumber - 1];
            const lastSetReps = currentExercise.type === 'distance'
                ? lastSet?.distanceFeet
                : currentExercise.type === 'duration'
                    ? lastSet?.secondsAchieved ?? lastSet?.secondsTarget ?? lastSet?.reps
                    : lastSet?.reps;

            if (!lastSetReps) return; // No comparison data

            const diff = reps - lastSetReps;
            const unitLabel = currentExercise.type === 'duration' ? 'second' : 'rep';

            if (diff > 0) {
                setTimeout(() => {
                    speak(`${diff} more ${unitLabel}${diff > 1 ? 's' : ''} than last time!`);
                    haptic('success');
                }, 1500);
            } else if (diff < 0 && Math.abs(diff) > 2) {
                // Only mention if significantly fewer (more than 2 reps)
                setTimeout(() => {
                    speak(`${Math.abs(diff)} fewer ${unitLabel}${Math.abs(diff) > 1 ? 's' : ''} than last time`);
                }, 1500);
            }
        }

        function previousSet() {
            if (currentExercise.currentSet > 1) {
                currentExercise.currentSet--;
                currentExercise.currentRep = 0;
                seedTimerSeconds();
                stopTimer();
                haptic('medium');
                updateDisplay();
            }
        }

        // Form Parameters Modal (shown after completing all sets)
        let sessionFormParams = {}; // Store form parameters for the session

        // Parse value and unit from strings like "10 lb", "45 degrees", "5.5 kg"
        function parseValueAndUnit(str) {
            if (!str) return { value: '', unit: '' };
            const match = String(str).match(/^([\d.]+)\s*(.*)$/);
            if (match) {
                return { value: match[1], unit: match[2].trim() };
            }
            return { value: '', unit: str };
        }

        // Detect if parameter values are numeric based on historical data
        function isNumericParameter(exerciseId, paramName, side = null) {
            if (paramName === 'weight' || paramName === 'distance') return true;
            const historicalValues = getHistoricalParamValues(exerciseId, paramName, side);
            if (historicalValues.length === 0) return false;

            // Check if most values parse as numbers
            const numericCount = historicalValues.filter(val => {
                const { value } = parseValueAndUnit(val);
                return !isNaN(parseFloat(value));
            }).length;

            return numericCount > 0;
        }

        // Get available units from historical data
        function getHistoricalUnits(exerciseId, paramName, side = null) {
            const historicalValues = getHistoricalParamValues(exerciseId, paramName, side);
            const units = new Set();

            historicalValues.forEach(val => {
                const { unit } = parseValueAndUnit(val);
                if (unit) units.add(unit);
            });

            const sessions = loadHistory();
            const exerciseSessions = sessions.filter(s => s.exerciseId === exerciseId);
            exerciseSessions.forEach(session => {
                (session.sets || []).forEach(set => {
                    if (side && set.side !== side) return;
                    const unitValue = set.formParams?.[`${paramName}_unit`];
                    if (unitValue) units.add(unitValue);
                });
            });

            return Array.from(units);
        }

        function getParamUnitOptions(paramName, historicalUnits) {
            if (paramName === 'weight') return ['lb'];
            if (paramName === 'distance') return ['ft', 'inch', 'cm', 'degree'];
            const commonUnits = ['lb', 'kg', 'in', 'ft', 'cm', 'm', 'degrees', '%'];
            return [...new Set([...(historicalUnits || []), ...commonUnits])];
        }

        function showFormParamsModal() {
            const entry = getLibraryEntryById(currentExercise.id);
            const formParams = entry?.form_parameters_required || [];
            const fieldsContainer = document.getElementById('form-params-fields');

            // Common units offered for any numeric parameter
            const commonUnits = ['lb', 'kg', 'in', 'ft', 'cm', 'm', 'degrees', '%'];

            // Detect which sides were used in this session
            const sidesUsed = [...new Set(currentExercise.sessionData.map(s => s.side).filter(Boolean))];
            const isSided = sidesUsed.length > 0;

            // Build form fields dynamically
            if (isSided) {
                // For sided exercises, prompt parameters for each side
                fieldsContainer.innerHTML = sidesUsed.map(side => {
                    const sideLabel = side.charAt(0).toUpperCase() + side.slice(1);
                    const sideFields = formParams.map(param => {
                        const historicalValues = getHistoricalParamValues(currentExercise.id, param, side);
                        const lastUsed = getLastUsedParamValue(currentExercise.id, param, side);
                        const isNumeric = isNumericParameter(currentExercise.id, param, side);
                        const label = param.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

                        // For numeric parameters, use input + unit selector
                        if (isNumeric) {
                            const historicalUnits = getHistoricalUnits(currentExercise.id, param, side);
                            const allUnits = getParamUnitOptions(param, [...historicalUnits, ...commonUnits]);
                            const lastUnit = getLastUsedParamUnit(currentExercise.id, param, side);
                            const parsed = parseValueAndUnit(lastUsed);
                            const defaultValue = (param === 'weight' || param === 'distance')
                                ? (lastUsed ?? '')
                                : parsed.value;
                            const selectedUnit = lastUnit || parsed.unit || allUnits[0] || '';

                            return `
                                <label style="font-size: 13px; font-weight: 500; margin-bottom: 4px; display: block; color: var(--text-secondary);">${label}</label>
                                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                                    <input type="number" class="modal-input" id="session-param-${side}-${param}" placeholder="${label}" min="0" step="1" value="${defaultValue}" style="flex: 1; margin: 0;" data-param="${param}" data-side="${side}">
                                    <select class="modal-select" id="session-param-${side}-${param}-unit" style="flex: 0 0 auto; width: 90px; margin: 0;">
                                        ${allUnits.map(unit => `<option value="${unit}" ${unit === selectedUnit ? 'selected' : ''}>${unit}</option>`).join('')}
                                    </select>
                                </div>
                            `;
                        } else {
                            const includeGlobal = param === 'band_position';
                            return renderSmartParamSelect(param, currentExercise.id, `session-param-${side}-${param}`, { side, includeGlobal });
                        }
                    }).join('');

                    return `
                        <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 8px; margin-bottom: 12px;">
                            <div style="font-size: 15px; font-weight: 700; margin-bottom: 12px; color: var(--ios-blue);">${sideLabel} Side</div>
                            ${sideFields}
                        </div>
                    `;
                }).join('');
            } else {
                // For bilateral/non-sided exercises, use single set of fields
                fieldsContainer.innerHTML = formParams.map(param => {
                    const historicalValues = getHistoricalParamValues(currentExercise.id, param);
                    const lastUsed = getLastUsedParamValue(currentExercise.id, param);
                    const isNumeric = isNumericParameter(currentExercise.id, param);
                    const label = param.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

                    // For numeric parameters, use input + unit selector
                    if (isNumeric) {
                        const historicalUnits = getHistoricalUnits(currentExercise.id, param);
                        const allUnits = getParamUnitOptions(param, [...historicalUnits, ...commonUnits]);
                        const lastUnit = getLastUsedParamUnit(currentExercise.id, param);
                        const parsed = parseValueAndUnit(lastUsed);
                        const defaultValue = (param === 'weight' || param === 'distance')
                            ? (lastUsed ?? '')
                            : parsed.value;
                        const selectedUnit = lastUnit || parsed.unit || allUnits[0] || '';

                        return `
                            <label style="font-size: 14px; font-weight: 600; margin-bottom: 6px; display: block;">${label}</label>
                            <div style="display: flex; gap: 8px; margin-bottom: 16px;">
                                <input type="number" class="modal-input" id="session-param-${param}" placeholder="${label}" min="0" step="1" value="${defaultValue}" style="flex: 1; margin: 0;" data-param="${param}">
                                <select class="modal-select" id="session-param-${param}-unit" style="flex: 0 0 auto; width: 90px; margin: 0;">
                                    ${allUnits.map(unit => `<option value="${unit}" ${unit === selectedUnit ? 'selected' : ''}>${unit}</option>`).join('')}
                                </select>
                            </div>
                        `;
                    } else {
                        const includeGlobal = param === 'band_position';
                        return renderSmartParamSelect(param, currentExercise.id, `session-param-${param}`, { includeGlobal });
                    }
                }).join('');
            }

            document.getElementById('form-params-modal').classList.add('active');
            haptic('medium');
        }

        function closeFormParamsModal() {
            document.getElementById('form-params-modal').classList.remove('active');
            haptic('medium');
        }

        function skipFormParams() {
            sessionFormParams = {};
            closeFormParamsModal();
            showSessionNotesModal();
        }

        function saveFormParams() {
            const entry = getLibraryEntryById(currentExercise.id);
            const formParams = entry?.form_parameters_required || [];

            // Collect all input elements with data-param attribute
            const paramInputs = document.querySelectorAll('#form-params-modal [data-param]');
            const paramsBySide = {}; // { side: { param: value } } or { null: { param: value } }

            paramInputs.forEach(inputElement => {
                const param = inputElement.getAttribute('data-param');
                const side = inputElement.getAttribute('data-side'); // null for bilateral
                if (!param || !formParams.includes(param)) return;

                let finalValue = '';
                if (inputElement.tagName === 'SELECT') {
                    finalValue = readParamSelectValue(inputElement);
                } else {
                    const value = inputElement.value.trim();
                    if (!value) return;

                    if (param === 'weight') {
                        const parsed = parseInt(value, 10);
                        if (isNaN(parsed)) return;
                        finalValue = parsed;
                    } else if (param === 'distance') {
                        const parsed = parseInt(value, 10);
                        if (isNaN(parsed)) return;
                        finalValue = parsed;
                    } else {
                        // Check if there's a unit selector for this parameter
                        const elementId = inputElement.id;
                        const unitElement = document.getElementById(`${elementId}-unit`);
                        finalValue = unitElement ? `${value} ${unitElement.value}` : value;
                    }
                }

                if (finalValue === '' || finalValue === null || finalValue === undefined) return;

                // Group by side
                const sideKey = side || 'bilateral';
                if (!paramsBySide[sideKey]) {
                    paramsBySide[sideKey] = {};
                }
                paramsBySide[sideKey][param] = finalValue;

                if (param === 'weight') {
                    const unitElement = document.getElementById(`${inputElement.id}-unit`);
                    paramsBySide[sideKey][`${param}_unit`] = unitElement ? unitElement.value : 'lb';
                }

                if (param === 'distance') {
                    const unitElement = document.getElementById(`${inputElement.id}-unit`);
                    paramsBySide[sideKey][`${param}_unit`] = unitElement ? unitElement.value : 'ft';
                }
            });

            // Apply form parameters to sets based on their side
            currentExercise.sessionData.forEach(set => {
                const setSide = set.side || 'bilateral';
                if (paramsBySide[setSide]) {
                    set.formParams = { ...paramsBySide[setSide] };
                }
            });

            closeFormParamsModal();
            showSessionNotesModal();
        }

        function showSessionNotesModal() {
            document.getElementById('session-notes').value = '';
            document.getElementById('session-notes-modal').classList.add('active');
            haptic('medium');
        }

        function closeSessionNotesModal() {
            document.getElementById('session-notes-modal').classList.remove('active');
            haptic('medium');
        }

        function confirmSkipNotes() {
            const setsLogged = currentExercise.sessionData.length;
            const message = `‚úì Save exercise without notes?\n\n${setsLogged} set${setsLogged !== 1 ? 's' : ''} will be saved to your history.\n\nYou can add notes later if needed.`;

            showActionSheet(message, () => {
                saveSessionWithNotes('');
            });
        }

        async function saveSessionWithNotes(notes) {
            const finalizedSession = {
                sessionId: currentSessionId,
                exerciseId: currentExercise.id,
                exerciseName: currentExercise.name,
                exerciseType: currentExercise.type,
                date: new Date().toISOString(),
                notes: notes.trim(),
                exerciseSpec: {
                    sets: currentExercise.sets,
                    repsPerSet: currentExercise.repsPerSet,
                    secondsPerRep: currentExercise.secondsPerRep,
                    type: currentExercise.type
                },
                sets: currentExercise.sessionData
            };
            addSessionToCache(finalizedSession);
            enqueueFirestoreSession(finalizedSession);
            void syncRuntimeToFirestore();

            // BUG FIX: Wait for Firestore write to complete before showing success feedback
            // Write finalized session to Firestore (user-scoped)
            let firestoreSuccess = false;
            try {
                if (currentUser) {
                    // User is authenticated - attempt direct write
                    // TODO(firebase-write): replace session write with API
                    await addDoc(collection(db, `users/${currentUser.uid}/sessions`), sanitizeSessionForFirestore(finalizedSession));
                    console.log('[Firestore] Session synced immediately:', finalizedSession.sessionId);
                    removeQueuedSession(finalizedSession);
                    firestoreSuccess = true;
                } else {
                    // Not authenticated - queue for later
                    console.log('[Firestore] Not authenticated, queueing session');
                }
            } catch (error) {
                console.error('[Firestore] Write failed:', error);
                // Show error to user but allow localStorage flow to continue
                alert('Warning: Session saved locally but failed to sync to cloud. Will retry when online.');
            }

            haptic('success');
            closeSessionNotesModal();

            // Mark exercise as completed in session plan
            if (sessionPlan.includes(currentExercise.id)) {
                sessionPlanCompleted.add(currentExercise.id);
                updateSessionPlanDisplay();

                // Auto-advance to next exercise in plan
                const nextExercise = getNextPlannedExercise();
                if (nextExercise) {
                    currentExercise = toSessionExercise(nextExercise);
                    localStorage.setItem(LAST_EXERCISE_KEY, nextExercise.id);
                    seedTimerSeconds();
                    updateDisplay();
                    speak(`Next: ${nextExercise.name}`);
                    return;
                }
            }

            // Reset for new session
            currentExercise.currentSet = 1;
            currentExercise.currentRep = 0;
            currentExercise.sessionData = [];
            seedTimerSeconds();
            stopTimer();
            updateDisplay();
            updateStreakDisplay(); // Refresh streak after completing session
            // updateQuickStartShortcuts(); // REMOVED: Quick Start section removed
        }

        function updateQuickStartShortcuts() {
            const sessions = loadHistory();
            const container = document.getElementById('quick-start-container');
            const exercisesContainer = document.getElementById('quick-start-exercises');

            if (sessions.length === 0 || exerciseLibrary.length === 0) {
                container.style.display = 'none';
                return;
            }

            // Count exercise usage in last 30 days
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

            const usageCount = {};
            sessions.forEach(session => {
                const sessionDate = new Date(session.date);
                if (sessionDate >= thirtyDaysAgo) {
                    usageCount[session.exerciseId] = (usageCount[session.exerciseId] || 0) + 1;
                }
            });

            // Sort by usage and get top 5
            const sortedExercises = Object.entries(usageCount)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([id]) => id);

            if (sortedExercises.length === 0) {
                container.style.display = 'none';
                return;
            }

            // Render shortcuts
            exercisesContainer.innerHTML = sortedExercises.map(id => {
                const entry = getLibraryEntryById(id);
                if (!entry || entry.archived) return '';
                return `<button class="pill" data-action="quickStartExercise" data-action-arg="${id}" style="cursor: pointer; padding: 8px 14px; background: var(--ios-blue); color: white; font-weight: 500; white-space: normal; word-wrap: break-word; text-align: left; line-height: 1.4;">${entry.name}</button>`;
            }).filter(Boolean).join('');

            container.style.display = exercisesContainer.innerHTML ? 'block' : 'none';
            bindPointerHandlers(exercisesContainer);
        }

        function quickStartExercise(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            if (!entry) return;

            currentExercise = toSessionExercise(entry);
            localStorage.setItem(LAST_EXERCISE_KEY, exerciseId);
            seedTimerSeconds();
            updateDisplay();
            haptic('medium');
            speak(`Starting ${entry.name}`);
        }

        // Session Planning Functions
        function showPlanSessionModal() {
            closeExerciseList();
            renderPlanSessionList();
            document.getElementById('plan-session-modal').classList.add('active');
            haptic('medium');
        }

        function closePlanSessionModal() {
            document.getElementById('plan-session-modal').classList.remove('active');
            haptic('medium');
        }

        function renderPlanSessionList() {
            const container = document.getElementById('plan-session-list');
            const activeExercises = exerciseLibrary.filter(ex => !ex.archived);

            if (activeExercises.length === 0) {
                container.innerHTML = '<div class="history-item">No exercises available. Add some first!</div>';
                return;
            }

            container.innerHTML = activeExercises.map(ex => {
                const spec = ex.current || {};
                const isSelected = sessionPlan.includes(ex.id);
                return `
                    <div class="history-item" data-action="toggleExerciseInPlan" data-action-arg="${ex.id}" role="button" tabindex="0" style="cursor: pointer; background: ${isSelected ? 'rgba(0,122,255,0.1)' : 'transparent'}; border: 2px solid ${isSelected ? 'var(--ios-blue)' : 'transparent'};">
                        <div style="display: flex; align-items: center; justify-content: space-between;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600;">${ex.name}</div>
                                <div class="history-meta">${describeSpec(spec)}</div>
                            </div>
                            <div style="font-size: 20px; margin-left: 12px;">${isSelected ? '‚úì' : ''}</div>
                        </div>
                    </div>
                `;
            }).join('');
            bindPointerHandlers(container);

            // Update button state
            const btn = document.getElementById('start-session-btn');
            btn.disabled = sessionPlan.length === 0;
            btn.style.opacity = sessionPlan.length === 0 ? '0.5' : '1';
        }

        function toggleExerciseInPlan(exerciseId) {
            const index = sessionPlan.indexOf(exerciseId);
            if (index > -1) {
                sessionPlan.splice(index, 1);
            } else {
                sessionPlan.push(exerciseId);
            }
            renderPlanSessionList();
            haptic('light');
        }

        function startPlannedSession() {
            if (sessionPlan.length === 0) return;

            sessionPlanCompleted.clear();
            closePlanSessionModal();

            // Start with first exercise in plan
            const firstExercise = getLibraryEntryById(sessionPlan[0]);
            if (firstExercise) {
                currentExercise = toSessionExercise(firstExercise);
                localStorage.setItem(LAST_EXERCISE_KEY, firstExercise.id);
                seedTimerSeconds();
                updateDisplay();
                updateSessionPlanDisplay();
                speak(`Starting session: ${firstExercise.name}`);
                haptic('success');
            }
        }

        function updateSessionPlanDisplay() {
            const container = document.getElementById('session-plan-container');
            const listContainer = document.getElementById('session-plan-list');

            if (sessionPlan.length === 0) {
                container.style.display = 'none';
                return;
            }

            const planItems = sessionPlan.map(id => {
                const entry = getLibraryEntryById(id);
                if (!entry) return '';

                const isCompleted = sessionPlanCompleted.has(id);
                const isCurrent = currentExercise && currentExercise.id === id;

                return `
                    <div data-action="switchToPlannedExercise" data-action-arg="${id}" role="button" tabindex="0" style="padding: 8px 12px; border-radius: 8px; background: ${isCurrent ? 'var(--ios-blue)' : isCompleted ? 'var(--ios-green)' : 'var(--bg-primary)'}; color: ${isCurrent || isCompleted ? 'white' : 'var(--text-primary)'}; cursor: pointer; display: flex; align-items: center; gap: 8px; ${isCompleted ? 'opacity: 0.7;' : ''}">
                        <div style="font-size: 16px;">${isCompleted ? '‚úì' : isCurrent ? '‚ñ∂' : '‚óã'}</div>
                        <div style="flex: 1; font-size: 14px; font-weight: ${isCurrent ? '600' : '500'};">${entry.name}</div>
                    </div>
                `;
            }).filter(Boolean).join('');

            listContainer.innerHTML = planItems;
            container.style.display = 'block';
            bindPointerHandlers(listContainer);
        }

        function switchToPlannedExercise(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            if (!entry) return;

            // Save current progress if switching mid-exercise
            if (currentExercise && currentExercise.sessionData.length > 0) {
                if (!confirm('Switch exercises? Current progress will be lost.')) {
                    return;
                }
            }

            currentExercise = toSessionExercise(entry);
            localStorage.setItem(LAST_EXERCISE_KEY, exerciseId);
            seedTimerSeconds();
            updateDisplay();
            updateSessionPlanDisplay();
            haptic('medium');
            speak(`Switched to ${entry.name}`);
        }

        function getNextPlannedExercise() {
            const remaining = sessionPlan.filter(id => !sessionPlanCompleted.has(id));
            if (remaining.length === 0) return null;
            return getLibraryEntryById(remaining[0]);
        }

        function endSessionEarly() {
            const completed = sessionPlanCompleted.size;
            const total = sessionPlan.length;
            const message = `End session early?\n\nCompleted: ${completed}/${total} exercises\n\nSession plan will be cleared.`;

            showActionSheet(message, () => {
                sessionPlan = [];
                sessionPlanCompleted.clear();
                updateSessionPlanDisplay();
                haptic('medium');
                speak('Session ended');
            });
        }

        // All Sessions Functions
        function showAllSessions() {
            closeWeeklyStats();
            const sessions = loadHistory();

            console.log('[All Sessions] Total sessions loaded:', sessions.length);

            // Group by sessionId
            const sessionGroups = {};
            sessions.forEach(session => {
                const sid = session.sessionId || 'unknown';
                if (!sessionGroups[sid]) {
                    sessionGroups[sid] = [];
                }
                sessionGroups[sid].push(session);
            });

            console.log('[All Sessions] Unique workout sessions:', Object.keys(sessionGroups).length);

            // Sort session groups by date (most recent first)
            const sortedGroups = Object.entries(sessionGroups).sort((a, b) => {
                const aDate = new Date(a[1][0].date);
                const bDate = new Date(b[1][0].date);
                return bDate - aDate;
            });

            const container = document.getElementById('all-sessions-list');

            if (sortedGroups.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">No sessions recorded yet.</div>';
            } else {
                container.innerHTML = sortedGroups.map(([sessionId, exercises]) => {
                    const sessionDate = new Date(exercises[0].date);
                    const totalExercises = exercises.length;
                    const totalSets = exercises.reduce((sum, ex) => sum + (ex.sets?.length || 0), 0);
                    const totalReps = exercises.reduce((sum, ex) => sum + ex.sets.reduce((rs, set) => rs + (set.reps || 0), 0), 0);

                    // Check if this is today's session
                    const isToday = sessionDate.toDateString() === new Date().toDateString();

                    return `
                        <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 12px; ${isToday ? 'border: 2px solid var(--ios-blue);' : ''}">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <div>
                                    <div style="font-weight: 600; font-size: 15px;">
                                        ${sessionDate.toLocaleDateString()}
                                        ${isToday ? '<span style="color: var(--ios-blue); margin-left: 8px;">‚Ä¢ Today</span>' : ''}
                                    </div>
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-top: 2px;">
                                        ${sessionDate.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}
                                    </div>
                                </div>
                                <div style="text-align: right; font-size: 12px; color: var(--text-secondary);">
                                    <div>${totalExercises} exercise${totalExercises !== 1 ? 's' : ''}</div>
                                    <div>${totalSets} sets ¬∑ ${totalReps} reps</div>
                                </div>
                            </div>
                            <div style="border-top: 1px solid var(--border-color); padding-top: 8px;">
                                ${exercises.map(ex => {
                                    const exTotalReps = ex.sets.reduce((sum, set) => sum + (set.reps || 0), 0);
                                    const avgReps = (exTotalReps / ex.sets.length).toFixed(1);
                                    return `
                                        <div style="padding: 6px 0; border-bottom: 1px solid rgba(0,0,0,0.05); cursor: pointer;" data-action="showExerciseProgress" data-action-arg="${ex.exerciseId}" role="button" tabindex="0">
                                            <div style="font-weight: 600; font-size: 13px; margin-bottom: 2px;">${ex.exerciseName}</div>
                                            <div style="font-size: 11px; color: var(--text-secondary);">
                                                ${ex.sets.length} sets √ó ${avgReps} avg = ${exTotalReps} total reps
                                            </div>
                                            ${ex.notes ? `<div style="font-size: 11px; color: var(--ios-gray); margin-top: 2px; font-style: italic;">"${ex.notes}"</div>` : ''}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }).join('');
                bindPointerHandlers(container);
            }

            document.getElementById('all-sessions-modal').classList.add('active');
            haptic('medium');
        }

        function closeAllSessions() {
            document.getElementById('all-sessions-modal').classList.remove('active');
            haptic('medium');
        }

        // Weekly Stats Functions (Rolling 7-Day Window)
        function showWeeklyStats() {
            const sessions = loadHistory();
            const now = new Date();
            const sevenDaysAgo = new Date(now - (7 * 24 * 60 * 60 * 1000));
            sevenDaysAgo.setHours(0, 0, 0, 0);

            const weekSessions = sessions.filter(s => new Date(s.date) >= sevenDaysAgo);

            // Debug logging
            console.log('[Weekly Stats] Total sessions in history:', sessions.length);
            console.log('[Weekly Stats] Rolling 7 days starts:', sevenDaysAgo.toLocaleString());
            console.log('[Weekly Stats] Sessions in last 7 days:', weekSessions.length);
            if (weekSessions.length > 0) {
                console.log('[Weekly Stats] Session dates:', weekSessions.map(s => new Date(s.date).toLocaleString()));
            }

            renderWeeklyOverview(weekSessions, sevenDaysAgo);
            renderWeeklyVolumeChart(sessions);
            renderWeeklyExercises(weekSessions);
            renderWeeklyAdherence(sessions);

            document.getElementById('weekly-stats-modal').classList.add('active');
            haptic('medium');
        }

        function closeWeeklyStats() {
            document.getElementById('weekly-stats-modal').classList.remove('active');
            haptic('medium');
        }

        function renderWeeklyOverview(weekSessions, startOfWeek) {
            const container = document.getElementById('weekly-overview');

            const totalSessions = weekSessions.length;
            const uniqueExercises = new Set(weekSessions.map(s => s.exerciseId)).size;
            const totalSets = weekSessions.reduce((sum, s) => sum + (s.sets?.length || 0), 0);
            const totalReps = weekSessions.reduce((sum, s) => sum + s.sets.reduce((rs, set) => rs + (set.reps || 0), 0), 0);

            // Days trained in rolling 7-day window
            const daysWithSessions = new Set(weekSessions.map(s => new Date(s.date).toDateString())).size;

            const today = new Date();

            container.innerHTML = `
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="font-weight: 600; font-size: 15px; margin-bottom: 4px; color: var(--ios-blue);">
                        Last 7 Days (Rolling)
                    </div>
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 12px;">
                        ${startOfWeek.toLocaleDateString()} - ${today.toLocaleDateString()}
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; font-size: 13px;">
                        <div>
                            <div style="color: var(--text-secondary); font-size: 11px;">Sessions</div>
                            <div style="font-size: 24px; font-weight: 700;">${totalSessions}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 11px;">Days Trained</div>
                            <div style="font-size: 24px; font-weight: 700;">${daysWithSessions}<span style="font-size: 14px;">/7</span></div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 11px;">Total Volume</div>
                            <div style="font-size: 24px; font-weight: 700;">${totalReps}<span style="font-size: 14px;"> reps</span></div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 11px;">Exercises</div>
                            <div style="font-size: 24px; font-weight: 700;">${uniqueExercises}</div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderWeeklyVolumeChart(allSessions) {
            const container = document.getElementById('weekly-volume-chart');

            // Calculate volume for past 8 weeks
            const weeks = [];
            for (let i = 7; i >= 0; i--) {
                const weekStart = new Date();
                weekStart.setDate(weekStart.getDate() - weekStart.getDay() - (i * 7));
                weekStart.setHours(0, 0, 0, 0);

                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekStart.getDate() + 7);

                const weekSessions = allSessions.filter(s => {
                    const sessionDate = new Date(s.date);
                    return sessionDate >= weekStart && sessionDate < weekEnd;
                });

                const totalReps = weekSessions.reduce((sum, s) => sum + s.sets.reduce((rs, set) => rs + (set.reps || 0), 0), 0);
                const totalSets = weekSessions.reduce((sum, s) => sum + s.sets.length, 0);

                weeks.push({
                    label: i === 0 ? 'This week' : `${i}w ago`,
                    date: weekStart.toLocaleDateString([], {month: 'short', day: 'numeric'}),
                    reps: totalReps,
                    sets: totalSets,
                    sessions: weekSessions.length
                });
            }

            const maxReps = Math.max(...weeks.map(w => w.reps), 1);

            container.innerHTML = `
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px; color: var(--ios-blue);">Volume Trend (8 Weeks)</div>
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        ${weeks.map(week => {
                            const barWidth = (week.reps / maxReps * 100).toFixed(1);
                            const color = week.reps > 0 ? 'var(--ios-blue)' : 'var(--ios-gray)';
                            return `
                                <div style="display: flex; align-items: center; gap: 8px; font-size: 12px;">
                                    <div style="width: 60px; color: var(--text-secondary); flex-shrink: 0; font-size: 11px;">${week.date}</div>
                                    <div style="flex: 1; background: rgba(0,122,255,0.1); border-radius: 4px; height: 28px; position: relative;">
                                        <div style="background: ${color}; border-radius: 4px; height: 100%; width: ${barWidth}%; transition: width 0.3s;"></div>
                                        <div style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); font-weight: 600; color: var(--text-primary); font-size: 11px;">
                                            ${week.reps > 0 ? `${week.reps} reps` : '‚Äî'}
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); font-size: 11px; color: var(--text-secondary); text-align: center;">
                        Total weekly volume helps PTs monitor training load progression
                    </div>
                </div>
            `;
        }

        function renderWeeklyExercises(weekSessions) {
            const container = document.getElementById('weekly-exercises');

            if (weekSessions.length === 0) {
                container.innerHTML = `
                    <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 16px; text-align: center; color: var(--text-secondary);">
                        No sessions in the last 7 days. Start training!
                    </div>
                `;
                return;
            }

            // Group by exercise
            const exerciseGroups = {};
            weekSessions.forEach(session => {
                const exId = session.exerciseId;
                if (!exerciseGroups[exId]) {
                    exerciseGroups[exId] = {
                        name: session.exerciseName,
                        sessions: [],
                        totalReps: 0,
                        totalSets: 0
                    };
                }
                exerciseGroups[exId].sessions.push(session);
                exerciseGroups[exId].totalSets += session.sets.length;
                exerciseGroups[exId].totalReps += session.sets.reduce((sum, set) => sum + (set.reps || 0), 0);
            });

            const sortedExercises = Object.entries(exerciseGroups).sort((a, b) => b[1].sessions.length - a[1].sessions.length);

            container.innerHTML = `
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px; color: var(--ios-blue);">Exercises (Last 7 Days)</div>
                    ${sortedExercises.map(([exId, group]) => `
                        <div style="padding: 8px; border-bottom: 1px solid var(--border-color); cursor: pointer;" data-action="showExerciseProgress" data-action-arg="${exId}" role="button" tabindex="0">
                            <div style="font-weight: 600; font-size: 14px; margin-bottom: 4px;">${group.name}</div>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                ${group.sessions.length}√ó sessions ¬∑ ${group.totalSets} sets ¬∑ ${group.totalReps} reps
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
            bindPointerHandlers(container);
        }

        function renderWeeklyAdherence(allSessions) {
            const container = document.getElementById('weekly-adherence');

            // Last 4 weeks
            const weeks = [];
            for (let i = 0; i < 4; i++) {
                const weekStart = new Date();
                weekStart.setDate(weekStart.getDate() - weekStart.getDay() - (i * 7));
                weekStart.setHours(0, 0, 0, 0);

                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekStart.getDate() + 7);

                const weekSessions = allSessions.filter(s => {
                    const sessionDate = new Date(s.date);
                    return sessionDate >= weekStart && sessionDate < weekEnd;
                });

                const daysWithSessions = new Set(weekSessions.map(s => new Date(s.date).toDateString())).size;

                weeks.push({
                    label: i === 0 ? 'This week' : `${i} week${i > 1 ? 's' : ''} ago`,
                    sessions: weekSessions.length,
                    days: daysWithSessions
                });
            }

            weeks.reverse();

            container.innerHTML = `
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px;">
                    <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px; color: var(--ios-blue);">Adherence Trend</div>
                    ${weeks.map(week => {
                        const barWidth = (week.days / 7 * 100).toFixed(1);
                        const color = week.days >= 3 ? 'var(--ios-green)' : week.days >= 1 ? 'var(--ios-orange)' : 'var(--ios-gray)';
                        return `
                            <div style="margin-bottom: 12px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; font-size: 12px;">
                                    <div style="color: var(--text-secondary);">${week.label}</div>
                                    <div style="font-weight: 600;">${week.days} day${week.days !== 1 ? 's' : ''} ¬∑ ${week.sessions} sessions</div>
                                </div>
                                <div style="background: rgba(0,122,255,0.1); border-radius: 4px; height: 20px; position: relative;">
                                    <div style="background: ${color}; border-radius: 4px; height: 100%; width: ${barWidth}%; transition: width 0.3s;"></div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                    <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--border-color); font-size: 12px; color: var(--text-secondary); text-align: center;">
                        Aim for 3-5 training days per week for best results
                    </div>
                </div>
            `;
        }

        // Exercise Progress Tracking Functions
        function showExerciseProgress(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            if (!entry) return;

            const sessions = loadHistory();
            const exerciseSessions = sessions.filter(s => s.exerciseId === exerciseId || s.exerciseName === entry.name);

            if (exerciseSessions.length === 0) {
                alert('No sessions recorded yet for this exercise.');
                return;
            }

            document.getElementById('progress-modal-title').textContent = `${entry.name} - Progress`;
            renderProgressSummary(entry, exerciseSessions);
            renderProgressChart(exerciseSessions);
            renderProgressSessions(exerciseSessions);

            document.getElementById('exercise-progress-modal').classList.add('active');
            haptic('medium');
        }

        function closeExerciseProgress() {
            document.getElementById('exercise-progress-modal').classList.remove('active');
            haptic('medium');
        }

        function renderProgressSummary(entry, sessions) {
            const container = document.getElementById('progress-summary');

            const totalSessions = sessions.length;
            const allSets = sessions.flatMap(s => s.sets);
            const totalSets = allSets.length;

            // Check if this is a distance-based exercise
            const hasDistance = allSets.some(set => set.distanceFeet);
            let volumeMetric, avgMetric;

            if (hasDistance) {
                const totalDistance = allSets.reduce((sum, set) => sum + (set.distanceFeet || 0), 0);
                const avgDistance = (totalDistance / totalSets).toFixed(1);
                volumeMetric = `${totalDistance} ft`;
                avgMetric = `${avgDistance} ft`;
            } else {
                const totalReps = allSets.reduce((sum, set) => sum + (set.reps || 0), 0);
                const avgReps = (totalReps / totalSets).toFixed(1);
                volumeMetric = `${totalReps} reps`;
                avgMetric = `${avgReps} reps`;
            }

            // First vs last comparison
            const firstSession = sessions[0];
            const lastSession = sessions[sessions.length - 1];
            const firstAvgReps = firstSession.sets.reduce((sum, set) => sum + (set.reps || 0), 0) / firstSession.sets.length;
            const lastAvgReps = lastSession.sets.reduce((sum, set) => sum + (set.reps || 0), 0) / lastSession.sets.length;
            const improvement = ((lastAvgReps - firstAvgReps) / firstAvgReps * 100).toFixed(1);
            const improvementColor = improvement >= 0 ? 'var(--ios-green)' : 'var(--ios-red)';

            // Frequency
            const firstDate = new Date(firstSession.date);
            const lastDate = new Date(lastSession.date);
            const daySpan = Math.ceil((lastDate - firstDate) / (1000 * 60 * 60 * 24)) || 1;
            const sessionsPerWeek = ((totalSessions / daySpan) * 7).toFixed(1);

            container.innerHTML = `
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px;">
                    <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px; color: var(--ios-blue);">Summary</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 13px;">
                        <div>
                            <div style="color: var(--text-secondary); font-size: 11px;">Total Sessions</div>
                            <div style="font-size: 20px; font-weight: 700;">${totalSessions}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 11px;">Frequency</div>
                            <div style="font-size: 20px; font-weight: 700;">${sessionsPerWeek}√ó<span style="font-size: 14px;">/week</span></div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 11px;">Total Volume</div>
                            <div style="font-size: 20px; font-weight: 700;">${volumeMetric}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); font-size: 11px;">Avg per Set</div>
                            <div style="font-size: 20px; font-weight: 700;">${avgMetric}</div>
                        </div>
                    </div>
                    ${totalSessions > 1 ? `
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color);">
                            <div style="color: var(--text-secondary); font-size: 11px; margin-bottom: 4px;">Progress (first ‚Üí most recent)</div>
                            <div style="font-size: 18px; font-weight: 700; color: ${improvementColor};">
                                ${firstAvgReps.toFixed(1)} ‚Üí ${lastAvgReps.toFixed(1)} reps
                                <span style="font-size: 14px; margin-left: 8px;">(${improvement > 0 ? '+' : ''}${improvement}%)</span>
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderProgressChart(sessions) {
            const container = document.getElementById('progress-chart');

            // Simple text-based chart showing trend
            const last10 = sessions.slice(-10);
            const maxReps = Math.max(...last10.map(s => s.sets.reduce((sum, set) => sum + (set.reps || 0), 0) / s.sets.length));

            const chartHtml = `
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px;">
                    <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px; color: var(--ios-blue);">Recent Trend (Last ${last10.length} Sessions)</div>
                    <div style="display: flex; flex-direction: column; gap: 4px;">
                        ${last10.map((session, idx) => {
                            const avgReps = session.sets.reduce((sum, set) => sum + (set.reps || 0), 0) / session.sets.length;
                            const barWidth = (avgReps / maxReps * 100).toFixed(1);
                            const date = new Date(session.date).toLocaleDateString();
                            return `
                                <div style="display: flex; align-items: center; gap: 8px; font-size: 12px;">
                                    <div style="width: 70px; color: var(--text-secondary); flex-shrink: 0;">${date}</div>
                                    <div style="flex: 1; background: rgba(0,122,255,0.1); border-radius: 4px; height: 24px; position: relative;">
                                        <div style="background: var(--ios-blue); border-radius: 4px; height: 100%; width: ${barWidth}%; transition: width 0.3s;"></div>
                                        <div style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); font-weight: 600; color: var(--text-primary);">${avgReps.toFixed(1)}</div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;

            container.innerHTML = chartHtml;
        }

        function renderProgressSessions(sessions) {
            const container = document.getElementById('progress-sessions');

            const sessionsHtml = `
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px;">
                    <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px; color: var(--ios-blue);">Session History</div>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${sessions.slice().reverse().map((session, idx) => {
                            const date = new Date(session.date);
                            const hasDistance = session.sets.some(set => set.distanceFeet);

                            let volumeDisplay;
                            if (hasDistance) {
                                const totalDistance = session.sets.reduce((sum, set) => sum + (set.distanceFeet || 0), 0);
                                const avgDistance = (totalDistance / session.sets.length).toFixed(1);
                                volumeDisplay = `${session.sets.length} sets √ó ${avgDistance}ft avg = ${totalDistance}ft total`;
                            } else {
                                const totalReps = session.sets.reduce((sum, set) => sum + (set.reps || 0), 0);
                                const avgReps = (totalReps / session.sets.length).toFixed(1);
                                volumeDisplay = `${session.sets.length} sets √ó ${avgReps} avg reps = ${totalReps} total reps`;
                            }

                            return `
                                <div style="padding: 8px; border-bottom: 1px solid var(--border-color); ${idx === 0 ? 'background: rgba(0,122,255,0.05);' : ''}">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                        <div style="font-weight: 600; font-size: 13px;">${date.toLocaleDateString()}</div>
                                        <div style="font-size: 12px; color: var(--text-secondary);">${date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}</div>
                                    </div>
                                    <div style="font-size: 12px; color: var(--text-secondary);">
                                        ${volumeDisplay}
                                    </div>
                                    ${session.notes ? `<div style="font-size: 11px; color: var(--ios-gray); margin-top: 4px; font-style: italic;">"${session.notes}"</div>` : ''}
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;

            container.innerHTML = sessionsHtml;
        }

        // Modal Functions
        function showExerciseModal() {
            populateExerciseSelect();
            applyLibraryEntryToForm(currentExercise.id);
            document.getElementById('exercise-modal').classList.add('active');
            haptic('medium');
        }

        function closeExerciseModal() {
            document.getElementById('exercise-modal').classList.remove('active');
            haptic('medium');
        }

        function updateTargetLabel() {
            const type = document.getElementById('exercise-type').value;
            const targetInput = document.getElementById('target-input');

            const placeholders = {
                timed: 'Seconds per rep (timed reps)',
                hold: 'Seconds to hold',
                duration: 'Seconds per set (duration)',
                amrap: 'AMRAP window (seconds, optional)',
                distance: 'Distance goal (steps/meters)',
                reps: 'Target (seconds optional)'
            };

            targetInput.placeholder = placeholders[type] || 'Target (seconds or distance)';
            targetInput.disabled = type === 'reps';
        }

        function updateExerciseType() {
            const select = document.getElementById('exercise-select');
            applyLibraryEntryToForm(select.value);
        }

        function saveExercise() {
            const select = document.getElementById('exercise-select');
            const exerciseName = select.options[select.selectedIndex].text;
            const exerciseId = select.value;
            const type = document.getElementById('exercise-type').value;
            const sets = parseInt(document.getElementById('sets-input').value);
            const reps = parseInt(document.getElementById('reps-input').value);
            const seconds = parseInt(document.getElementById('target-input').value);

            if (!sets) {
                alert('Please enter a valid number for sets.');
                return;
            }

            if (COUNTER_TYPES.includes(type) && type !== 'amrap' && (!reps && reps !== 0)) {
                alert('Please enter a valid number for reps/distance.');
                return;
            }

            if (type === 'distance' && (!reps || reps <= 0)) {
                alert('Please enter a distance goal.');
                return;
            }

            if (isTimerType(type) && (!seconds || seconds <= 0)) {
                alert('Please enter seconds for the timer-based exercise.');
                return;
            }

            const entry = getLibraryEntryById(exerciseId);
            const nextSpec = {
                type: type,
                sets: sets,
                repsPerSet: reps,
                secondsPerRep: (isTimerType(type) || type === 'amrap') ? (seconds || 0) : 0
            };

            const prevSpec = entry.current || {};
            if (
                prevSpec.type !== nextSpec.type ||
                prevSpec.sets !== nextSpec.sets ||
                prevSpec.repsPerSet !== nextSpec.repsPerSet ||
                (prevSpec.secondsPerRep ?? null) !== (nextSpec.secondsPerRep ?? null)
            ) {
                recordRevision(entry, nextSpec, 'Manual exercise update');
            } else {
                entry.current = nextSpec;
                persistExerciseLibrary();
            }

            currentExercise = toSessionExercise({ ...entry, name: exerciseName, id: exerciseId });

            // Remember this exercise for next session
            localStorage.setItem(LAST_EXERCISE_KEY, exerciseId);

            seedTimerSeconds();
            stopTimer();

            haptic('success');
            updateDisplay();
            closeExerciseModal();
        }

        function showHistory() {
            // No longer require an exercise to be selected - can view full history anytime
            renderHistory();
            document.getElementById('history-modal').classList.add('active');
            haptic('medium');
        }

        function closeHistoryModal() {
            document.getElementById('history-modal').classList.remove('active');
            haptic('medium');
        }

        function describeSpec(spec) {
            if (!spec) return 'No spec available';
            const parts = [`${spec.sets || 0} sets`];

            // Show distance if present (replaces reps)
            if (spec.distanceFeet && spec.distanceFeet > 0) {
                parts.push(`${spec.distanceFeet}ft`);
            }
            // Show duration if type is duration or timed (replaces reps)
            else if (spec.type === 'duration') {
                parts.push(`${spec.secondsPerRep || 0}s`);
            }
            // Show reps with optional hold time
            else {
                const repsText = `${spec.repsPerSet || 0} reps`;
                if (spec.type === 'hold' && spec.secondsPerRep > 0) {
                    parts.push(`${repsText} √ó ${spec.secondsPerRep}s hold`);
                } else if (spec.type === 'timed' && spec.secondsPerRep > 0) {
                    parts.push(`${repsText} √ó ${spec.secondsPerRep}s`);
                } else {
                    parts.push(repsText);
                }
            }

            return parts.join(' ¬∑ ');
        }

        // Standardized session summary formatting
        function formatSessionSummary(session, options = {}) {
            const {
                includeDate = true,
                includeExerciseName = false,
                includeSets = true,
                includeFormParams = true
            } = options;

            const parts = [];

            // Date
            if (includeDate) {
                parts.push(formatDateTime(session.date));
            }

            // Exercise name (if requested)
            if (includeExerciseName && session.exerciseName) {
                parts.push(session.exerciseName);
            }

            // Sets summary
            if (includeSets && session.sets && session.sets.length > 0) {
                const totalSets = session.sets.length;
                const hasDistance = session.sets.some(s => s.distanceFeet);

                if (hasDistance) {
                    const totalDistance = session.sets.reduce((sum, s) => sum + (s.distanceFeet || 0), 0);
                    parts.push(`${totalSets} sets ¬∑ ${totalDistance}ft total`);
                } else {
                    const totalReps = session.sets.reduce((sum, s) => sum + (s.reps || 0), 0);
                    parts.push(`${totalSets} sets ¬∑ ${totalReps} reps total`);
                }
            }

            // Form params (if requested and present)
            if (includeFormParams && session.sets && session.sets.length > 0) {
                const firstSet = session.sets[0];
                if (firstSet.formParams) {
                    const params = [];
                    if (firstSet.formParams.weight) params.push(`${firstSet.formParams.weight}${firstSet.formParams.weight_unit || 'lb'}`);
                    if (firstSet.formParams.band_resistance) params.push(`[${firstSet.formParams.band_resistance}]`);
                    if (params.length > 0) {
                        parts.push(params.join(', '));
                    }
                }
            }

            return parts.join(' ¬∑ ');
        }

        function renderHistory() {
            const sessions = loadHistory();
            const exerciseHistoryList = document.getElementById('exercise-history-list');
            const sessionHistoryList = document.getElementById('session-history-list');

            // Exercise revisions - only show if an exercise is selected
            if (!currentExercise) {
                exerciseHistoryList.innerHTML = '<div class="history-item">Select an exercise to view its revision history.</div>';
            } else {
                const exerciseEntry = getLibraryEntryById(currentExercise.id);
                if (!exerciseEntry.history || exerciseEntry.history.length === 0) {
                    exerciseHistoryList.innerHTML = '<div class="history-item">No revisions logged yet.</div>';
                } else {
                    exerciseHistoryList.innerHTML = exerciseEntry.history
                        .slice()
                        .reverse()
                        .map(revision => {
                            const supersedesLabel = revision.supersedes && revision.supersedes.length
                                ? `<span class="pill">Supersedes ${revision.supersedes.join(', ')}</span>`
                                : '';
                            return `
                                <div class="history-item">
                                    <div>${revision.summary}</div>
                                    ${supersedesLabel}
                                    <div class="history-meta">${formatDateTime(revision.timestamp)} ¬∑ ${describeSpec(revision.next)}</div>
                                </div>
                            `;
                        })
                        .join('');
                }
            }

            // Session history - show all or filtered by current exercise
            const relevantSessions = currentExercise
                ? sessions.filter(s => (s.exerciseId && s.exerciseId === currentExercise.id) || s.exerciseName === currentExercise.name)
                : sessions;

            const reversedSessions = relevantSessions.slice().reverse();

            if (relevantSessions.length === 0) {
                sessionHistoryList.innerHTML = '<div class="history-item">No sessions tracked yet.</div>';
            } else {
                sessionHistoryList.innerHTML = reversedSessions
                    .slice(0, 10)
                    .map(session => {
                        const sessionSummary = formatSessionSummary(session, { includeDate: true, includeSets: true, includeFormParams: false });

                        // Show side info for unilateral exercises and form parameters
                        const setDetails = (session.sets || []).map((set, idx) => {
                            const sideLabel = set.side ? ` (${set.side})` : '';
                            const manualLabel = set.manualLog ? ' üìù' : '';
                            const distanceLabel = set.distanceFeet !== undefined ? `${set.distanceFeet}ft` : `${set.reps} reps`;

                            // Build form parameters label
                            let formParamsLabel = '';
                            if (set.formParams) {
                                const params = [];
                                if (set.formParams.weight) {
                                    params.push(`${set.formParams.weight}${set.formParams.weight_unit || 'lb'}`);
                                }
                                if (set.formParams.band_resistance) {
                                    params.push(`[${set.formParams.band_resistance}]`);
                                }
                                if (set.formParams.band_position) {
                                    params.push(`@${set.formParams.band_position.replace('_', ' ')}`);
                                }
                                if (set.formParams.surface) {
                                    params.push(`on ${set.formParams.surface}`);
                                }
                                if (set.formParams.eyes) {
                                    params.push(`eyes ${set.formParams.eyes}`);
                                }
                                if (set.formParams.slope) {
                                    params.push(set.formParams.slope);
                                }
                                if (set.formParams.distance) {
                                    const distanceUnit = set.formParams.distance_unit || 'ft';
                                    params.push(`${set.formParams.distance}${distanceUnit}`);
                                }
                                if (params.length > 0) {
                                    formParamsLabel = ' ' + params.join(' ');
                                }
                            }

                            // Legacy support for old weight/resistance fields
                            if (!formParamsLabel) {
                                const weightLabel = set.weight ? ` ${set.weight}${set.weightUnit || 'lb'}` : '';
                                const resistanceLabel = set.resistance ? ` [${set.resistance}]` : '';
                                formParamsLabel = weightLabel + resistanceLabel;
                            }

                            return `Set ${idx + 1}: ${distanceLabel}${sideLabel}${formParamsLabel}${manualLabel}`;
                        }).join(' ¬∑ ');

                        const notesHtml = session.notes ? `<div style="margin-top: 6px; font-style: italic; color: var(--text-secondary);">"${session.notes}"</div>` : '';
                        const sessionIndex = sessions.indexOf(session);
                        return `
                            <div class="history-item" style="position: relative;">
                                <div style="display: flex; justify-content: space-between; align-items: start;">
                                    <div style="flex: 1;">
                                        <div>${session.exerciseName}</div>
                                        <div class="history-meta">${sessionSummary}</div>
                                        <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">${setDetails}</div>
                                        ${notesHtml}
                                    </div>
                                    <button data-action="editSession" data-action-arg-number="${sessionIndex}" data-stop-propagation="true" style="background: rgba(0,122,255,0.1); color: var(--ios-blue); border: none; padding: 6px 12px; border-radius: 6px; font-size: 12px; cursor: pointer; white-space: nowrap;">Edit</button>
                                </div>
                            </div>
                        `;
                    })
                    .join('');
            }
            bindPointerHandlers(sessionHistoryList);
        }

        // Session Editing
        let editingSessionIndex = null;

        function editSession(sessionIndex) {
            const sessions = loadHistory();
            const session = sessions[sessionIndex];
            if (!session) {
                alert('Session not found');
                return;
            }

            editingSessionIndex = sessionIndex;

            // Populate date
            const date = new Date(session.date);
            const dateString = date.toISOString().slice(0, 16); // Format for datetime-local
            document.getElementById('edit-session-date').value = dateString;

            // Populate exercise info
            document.getElementById('edit-session-exercise-name').textContent = session.exerciseName;
            const exerciseEntry = getLibraryEntryById(session.exerciseId) || {};
            const patternInfo = exerciseEntry.pattern ? `${getPatternBadge(exerciseEntry.pattern)} ${getPatternLabel(exerciseEntry.pattern)}` : '';
            document.getElementById('edit-session-exercise-pattern').textContent = patternInfo;

            // Populate sets
            renderEditSessionSets(session.sets || [], exerciseEntry);

            // Populate notes
            document.getElementById('edit-session-notes').value = session.notes || '';

            // Show modal
            document.getElementById('edit-session-modal').classList.add('active');
            haptic('medium');
        }

        function closeEditSession() {
            document.getElementById('edit-session-modal').classList.remove('active');
            editingSessionIndex = null;
            haptic('medium');
        }

        function renderEditSessionSets(sets, exerciseEntry) {
            const container = document.getElementById('edit-session-sets-container');
            const isSided = exerciseEntry.pattern && isSidedPattern(exerciseEntry.pattern);
            const hasDistance = sets.length > 0 && sets[0].distanceFeet !== undefined;

            container.innerHTML = sets.map((set, idx) => {
                const sideSelect = isSided ? `
                    <select class="modal-input" data-set-index="${idx}" data-field="side" onchange="updateEditSessionSet(this)" style="flex: 1;">
                        <option value="">No side</option>
                        <option value="left" ${set.side === 'left' ? 'selected' : ''}>Left</option>
                        <option value="right" ${set.side === 'right' ? 'selected' : ''}>Right</option>
                    </select>
                ` : '';

                const valueField = hasDistance ? `
                    <div style="flex: 1;">
                        <label style="font-size: 12px; color: var(--ios-gray);">Distance (ft)</label>
                        <input type="number" class="modal-input" value="${set.distanceFeet || 0}" data-set-index="${idx}" data-field="distanceFeet" onchange="updateEditSessionSet(this)">
                    </div>
                ` : `
                    <div style="flex: 1;">
                        <label style="font-size: 12px; color: var(--ios-gray);">Reps</label>
                        <input type="number" class="modal-input" value="${set.reps || 0}" data-set-index="${idx}" data-field="reps" onchange="updateEditSessionSet(this)">
                    </div>
                `;

                // Form parameters summary
                let formParamsSummary = '';
                if (set.formParams) {
                    const params = [];
                    if (set.formParams.weight) params.push(`${set.formParams.weight}${set.formParams.weight_unit || 'lb'}`);
                    if (set.formParams.band_resistance) params.push(`[${set.formParams.band_resistance}]`);
                    if (set.formParams.band_position) params.push(`@${set.formParams.band_position}`);
                    if (set.formParams.surface) params.push(set.formParams.surface);
                    if (set.formParams.eyes) params.push(`eyes ${set.formParams.eyes}`);
                    if (set.formParams.slope) params.push(set.formParams.slope);
                    if (set.formParams.distance) {
                        const distanceUnit = set.formParams.distance_unit || 'ft';
                        params.push(`${set.formParams.distance}${distanceUnit}`);
                    }
                    if (params.length > 0) {
                        formParamsSummary = `<div style="font-size: 11px; color: var(--ios-gray); margin-top: 4px;">${params.join(' ¬∑ ')}</div>`;
                    }
                }

                return `
                    <div style="padding: 12px; background: rgba(0,0,0,0.02); border-radius: 8px; margin-bottom: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-weight: 600;">Set ${idx + 1}</span>
                            <button data-action="deleteEditSessionSet" data-action-arg-number="${idx}" style="background: rgba(255,59,48,0.1); color: var(--ios-red); border: none; padding: 4px 8px; border-radius: 4px; font-size: 11px; cursor: pointer;">Delete</button>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            ${valueField}
                            ${sideSelect}
                        </div>
                        ${formParamsSummary}
                    </div>
                `;
            }).join('');
            bindPointerHandlers(container);
        }

        function updateEditSessionSet(input) {
            const sessions = loadHistory();
            const session = sessions[editingSessionIndex];
            const setIndex = parseInt(input.dataset.setIndex);
            const field = input.dataset.field;
            const value = input.value;

            if (field === 'reps' || field === 'distanceFeet') {
                session.sets[setIndex][field] = parseInt(value) || 0;
            } else {
                session.sets[setIndex][field] = value;
            }

            haptic('light');
        }

        function deleteEditSessionSet(setIndex) {
            if (!confirm('Delete this set?')) return;

            const sessions = loadHistory();
            const session = sessions[editingSessionIndex];
            const exerciseEntry = getLibraryEntryById(session.exerciseId) || {};

            session.sets.splice(setIndex, 1);
            renderEditSessionSets(session.sets, exerciseEntry);
            haptic('medium');
        }

        function addSetToEditSession() {
            const sessions = loadHistory();
            const session = sessions[editingSessionIndex];
            const exerciseEntry = getLibraryEntryById(session.exerciseId) || {};

            // Determine if distance-based
            const hasDistance = session.sets.length > 0 && session.sets[0].distanceFeet !== undefined;

            const newSet = hasDistance ? { distanceFeet: 0 } : { reps: 0 };
            session.sets.push(newSet);
            renderEditSessionSets(session.sets, exerciseEntry);
            haptic('light');
        }

        // BUG FIX: Convert to async to wait for Firestore delete before showing success
        async function deleteSession() {
            if (!confirm('Are you sure you want to delete this session?\n\nThis cannot be undone.')) return;

            const sessions = loadHistory();
            const sessionToDelete = sessions[editingSessionIndex];
            sessions.splice(editingSessionIndex, 1);
            setSessionHistoryCache(sessions, { source: 'local-delete', syncLocalStorage: true });
            void syncRuntimeToFirestore();

            // BUG FIX: Await Firestore delete before showing success feedback
            if (currentUser && sessionToDelete) {
                try {
                    const docId = await resolveFirestoreDocId(sessionToDelete);
                    if (!docId) {
                        console.warn('[Firestore] Unable to delete session: missing doc ID');
                    } else {
                        // TODO(firebase-write): replace session delete with API
                        await deleteDoc(doc(db, `users/${currentUser.uid}/sessions`, docId));
                        console.log('[Firestore] Session deleted:', sessionToDelete.sessionId);
                    }
                } catch (error) {
                    console.error('[Firestore] Failed to delete session:', error);
                    alert('Warning: Session deleted locally but failed to delete from cloud: ' + error.message);
                    return; // Don't show success if cloud delete failed
                }
            }

            closeEditSession();
            renderHistory(); // Refresh the history display
            haptic('success');
            alert('Session deleted');
        }

        // BUG FIX: Convert to async to wait for Firestore update before showing success
        async function saveEditedSession() {
            const sessions = loadHistory();
            const session = sessions[editingSessionIndex];

            // Update date
            const newDate = document.getElementById('edit-session-date').value;
            if (newDate) {
                session.date = new Date(newDate).toISOString();
            }

            // Update notes
            session.notes = document.getElementById('edit-session-notes').value;

            setSessionHistoryCache(sessions, { source: 'local-edit', syncLocalStorage: true });
            void syncRuntimeToFirestore();

            // BUG FIX: Await Firestore update and show error feedback if it fails
            if (currentUser) {
                try {
                    const docId = await resolveFirestoreDocId(session);
                    if (!docId) {
                        console.warn('[Firestore] Unable to update session: missing doc ID');
                        alert('Warning: Session saved locally but could not sync to cloud (missing doc ID).');
                    } else {
                        // TODO(firebase-write): replace session update with API
                        await updateDoc(doc(db, `users/${currentUser.uid}/sessions`, docId), sanitizeSessionForFirestore(session));
                        console.log('[Firestore] Session updated:', session.sessionId);
                    }
                } catch (error) {
                    console.error('[Firestore] Failed to update session:', error);
                    alert('Warning: Session saved locally but failed to sync to cloud: ' + error.message);
                }
            }

            closeEditSession();
            renderHistory(); // Refresh the history display
            haptic('success');
        }

        // Exercise List Management
        function showExerciseList() {
            renderRecentExercises();
            renderExerciseList();
            renderTagFilters();

            document.getElementById('exercise-list-modal').classList.add('active');
            haptic('medium');
        }

        function renderRecentExercises() {
            const sessions = loadHistory();
            if (sessions.length === 0) {
                document.getElementById('recent-exercises-container').innerHTML = '';
                return;
            }

            // Get unique exercises from most recent sessions
            const recentExerciseIds = new Set();
            const recentExercises = [];

            sessions.slice().reverse().forEach(session => {
                if (session.exerciseId && !recentExerciseIds.has(session.exerciseId) && recentExercises.length < 5) {
                    recentExerciseIds.add(session.exerciseId);
                    const entry = getLibraryEntryById(session.exerciseId);
                    if (entry) {
                        recentExercises.push(entry);
                    }
                }
            });

            if (recentExercises.length === 0) {
                document.getElementById('recent-exercises-container').innerHTML = '';
                return;
            }

            const container = document.getElementById('recent-exercises-container');
            container.innerHTML = `
                <div style="font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px;">‚ö° Recent Exercises</div>
                <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 8px;">
                    ${recentExercises.map(ex =>
                        `<button class="pill" data-action="selectExerciseFromList" data-action-arg="${ex.id}" data-stop-propagation="true" style="cursor: pointer; padding: 6px 12px; background: var(--ios-blue); color: white;">${ex.name}</button>`
                    ).join('')}
                </div>
            `;
            bindPointerHandlers(container);
        }

        function closeExerciseList() {
            document.getElementById('exercise-list-modal').classList.remove('active');
            document.getElementById('exercise-search').value = '';
            filterTags = [];
            haptic('medium');
        }

        // DATA EXPORT FUNCTIONS
        function showDataBackup() {
            document.getElementById('data-backup-modal').classList.add('active');
            haptic('medium');
        }

        function closeDataBackup() {
            document.getElementById('data-backup-modal').classList.remove('active');
            haptic('medium');
        }

        // SETTINGS FUNCTIONS
        const PREFERENCES_KEY = 'pt_preferences';
        let preferences = {
            hapticEnabled: true,
            voiceEnabled: true
        };

        function loadPreferences() {
            try {
                const stored = localStorage.getItem(PREFERENCES_KEY);
                if (stored) {
                    preferences = JSON.parse(stored);
                }
            } catch (e) {
                console.error('Failed to load preferences:', e);
            }
            // Update UI toggles
            document.getElementById('haptic-toggle').checked = preferences.hapticEnabled;
            document.getElementById('voice-toggle').checked = preferences.voiceEnabled;
        }

        function savePreferences() {
            localStorage.setItem(PREFERENCES_KEY, JSON.stringify(preferences));
            void syncRuntimeToFirestore();
        }

        function showSettings() {
            loadPreferences();
            document.getElementById('app-version-display').textContent = APP_VERSION;
            document.getElementById('settings-modal').classList.add('active');
            haptic('medium');
        }

        function closeSettings() {
            document.getElementById('settings-modal').classList.remove('active');
            haptic('medium');
        }

        function toggleHamburgerMenu() {
            const overlay = document.getElementById('hamburger-overlay');
            const menu = document.getElementById('hamburger-menu');
            const isVisible = overlay.style.display !== 'none';

            if (isVisible) {
                overlay.style.display = 'none';
                menu.style.display = 'none';
            } else {
                overlay.style.display = 'block';
                menu.style.display = 'block';
            }
            haptic('medium');
        }

        // Debug helper: summarize library samples so we can compare counts across sources.
        function formatExercisePreview(exercises, label) {
            const formatEntry = (exercise) => {
                const name = exercise.canonical_name || exercise.name || exercise.title || 'Unnamed';
                const id = exercise.id || exercise.exercise_id || 'no-id';
                return `${name} (${id})`;
            };

            if (!exercises || exercises.length === 0) {
                return `${label}: 0\n  (no exercises loaded)\n`;
            }

            const firstThree = exercises.slice(0, 3).map(formatEntry);
            const lastThree = exercises.slice(-3).map(formatEntry);

            return `${label}: ${exercises.length}\n` +
                `  First 3:\n    - ${firstThree.join('\n    - ')}\n` +
                `  Last 3:\n    - ${lastThree.join('\n    - ')}\n`;
        }

        // Debug helper: mirror the rehab coverage localStorage key summary.
        function formatLocalStorageSummary() {
            const lines = [];
            lines.push(`localStorage keys: ${localStorage.length}`);
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                const value = localStorage.getItem(key) || '';
                lines.push(`  - ${key}: ${value.length} chars`);
            }
            return lines.join('\n');
        }

        // Debug modal: compare local storage vs shared library sources in one snapshot.
        async function showLibraryDiagnostics() {
            const modal = document.getElementById('library-debug-modal');
            const output = document.getElementById('library-debug-output');
            modal.classList.add('active');
            output.textContent = 'Loading debug snapshot...';
            haptic('medium');

            // Inspect raw localStorage payload to detect schema vs legacy arrays.
            const localStored = localStorage.getItem(LIBRARY_KEY);
            let localStoredType = 'missing';
            let localStoredCount = 0;
            if (localStored) {
                try {
                    const parsed = JSON.parse(localStored);
                    if (Array.isArray(parsed)) {
                        localStoredType = 'array';
                        localStoredCount = parsed.length;
                    } else if (Array.isArray(parsed?.exercises)) {
                        localStoredType = 'schema';
                        localStoredCount = parsed.exercises.length;
                    } else {
                        localStoredType = typeof parsed;
                    }
                } catch (error) {
                    localStoredType = 'invalid JSON';
                }
            }

            // Normalize local library for the tracker view.
            const localExercises = loadExerciseLibrary();
            // Load shared library (Firestore) for cross-page parity checks.
            let sharedExercises = [];
            let sharedError = null;
            try {
                const result = await fetch('/api/exercises').then(r => r.json());
                sharedExercises = result || [];
                sharedDocSource.sharedLibrary = 'api';
                setFirestoreReadSucceeded('sharedLibrary');
                markDocHydrated('sharedLibrary');
            } catch (error) {
                sharedError = error;
            }

            const lines = [];
            lines.push('PT Tracker Library Debug');
            lines.push(`Timestamp: ${new Date().toLocaleString()}`);
            lines.push('');
            lines.push(`Local storage payload (pt_exercise_library):`);
            lines.push(`  - type: ${localStoredType}`);
            lines.push(`  - count (raw): ${localStoredCount}`);
            lines.push(`  - count (normalized): ${localExercises.length}`);
            lines.push('');
            lines.push(formatExercisePreview(localExercises, 'Local library (normalized)'));

            if (sharedError) {
                lines.push(`Shared library: ERROR`);
                lines.push(`  - ${sharedError.message}`);
            } else {
                lines.push(formatExercisePreview(sharedExercises, 'Shared library (Firestore)'));
            }

            lines.push('');
            lines.push(formatLocalStorageSummary());

            output.textContent = lines.join('\n');
        }

        function closeLibraryDiagnostics() {
            document.getElementById('library-debug-modal').classList.remove('active');
            haptic('medium');
        }

        function toggleHaptic() {
            preferences.hapticEnabled = document.getElementById('haptic-toggle').checked;
            savePreferences();
            haptic('light');
        }

        function toggleVoice() {
            preferences.voiceEnabled = document.getElementById('voice-toggle').checked;
            savePreferences();
            haptic('light');
        }

        // DOSAGE PROMPT FUNCTIONS
        let pendingExerciseImport = null;

        function showDosagePrompt(exercise) {
            pendingExerciseImport = exercise;

            document.getElementById('dosage-exercise-name').textContent = exercise.canonical_name;
            document.getElementById('dosage-sets').value = '';
            document.getElementById('dosage-reps').value = '';
            document.getElementById('dosage-seconds').value = '';
            document.getElementById('dosage-distance').value = '';

            // Dynamically show/hide fields based on pattern_modifiers
            const modifiers = exercise.pattern_modifiers || [];
            const repsContainer = document.getElementById('dosage-reps-container');
            const secondsContainer = document.getElementById('dosage-seconds-container');
            const secondsLabel = document.getElementById('dosage-seconds-label');
            const distanceContainer = document.getElementById('dosage-distance-container');

            // duration_seconds or distance_feet REPLACE reps entirely
            const replacesReps = modifiers.includes('duration_seconds') || modifiers.includes('distance_feet');

            if (replacesReps) {
                repsContainer.style.display = 'none';
            } else {
                repsContainer.style.display = 'block';
            }

            // hold_seconds MODIFIES reps (shown alongside)
            // duration_seconds REPLACES reps
            if (modifiers.includes('hold_seconds')) {
                secondsContainer.style.display = 'block';
                secondsLabel.textContent = 'Hold Seconds (per rep)';
            } else if (modifiers.includes('duration_seconds')) {
                secondsContainer.style.display = 'block';
                secondsLabel.textContent = 'Duration (seconds per set)';
            } else {
                secondsContainer.style.display = 'none';
            }

            if (modifiers.includes('distance_feet')) {
                distanceContainer.style.display = 'block';
            } else {
                distanceContainer.style.display = 'none';
            }

            document.getElementById('dosage-prompt-modal').classList.add('active');
            haptic('medium');
        }

        function closeDosagePrompt() {
            document.getElementById('dosage-prompt-modal').classList.remove('active');
            pendingExerciseImport = null;
            haptic('medium');
        }

        function confirmDosage() {
            const sets = parseInt(document.getElementById('dosage-sets').value);
            let reps = parseInt(document.getElementById('dosage-reps').value);
            const seconds = parseInt(document.getElementById('dosage-seconds').value) || 0;
            const distance = parseInt(document.getElementById('dosage-distance').value) || 0;

            if (!sets || sets < 1) {
                alert('Please enter valid sets');
                return;
            }

            if (!pendingExerciseImport) return;

            const ex = pendingExerciseImport;
            const modifiers = ex.pattern_modifiers || [];
            const hasDistance = modifiers.includes('distance_feet');

            // duration_seconds or distance_feet REPLACE reps
            const replacesReps = modifiers.includes('duration_seconds') || modifiers.includes('distance_feet');

            if (replacesReps) {
                // Set reps to 1 (not used, but required for data structure)
                reps = 1;
            } else {
                // Normal reps-based exercise
                if (!reps || reps < 1) {
                    alert('Please enter valid reps');
                    return;
                }
            }

            // Validate required fields based on modifiers
            if (modifiers.includes('hold_seconds') && (!seconds || seconds < 1)) {
                alert('Please enter valid seconds for this hold exercise');
                return;
            }
            if (modifiers.includes('duration_seconds') && (!seconds || seconds < 1)) {
                alert('Please enter valid duration in seconds');
                return;
            }
            if (modifiers.includes('distance_feet') && (!distance || distance < 1)) {
                alert('Please enter valid distance in feet');
                return;
            }

            // Build dosage spec from user input
            const dosageSpec = {
                type: hasDistance ? 'distance' : modifiers.includes('hold_seconds') ? 'hold' : modifiers.includes('duration_seconds') ? 'duration' : 'reps',
                sets: sets,
                repsPerSet: hasDistance ? distance : reps,
                secondsPerRep: seconds
            };

            // Add distance if applicable
            if (modifiers.includes('distance_feet') && distance > 0) {
                dosageSpec.distanceFeet = distance;
            }

            // Import using helper
            importExerciseWithDosage(ex, dosageSpec, 'Imported from exercise library');
            const dosageSummary = buildDosageSummary(dosageSpec, modifiers);

            closeDosagePrompt();
            closeExerciseDetail();

            // Check if we're in bulk import mode
            if (bulkImportQueue && bulkImportQueue.length > 0) {
                // More exercises to import, continue to next
                processNextBulkImport();
            } else {
                // Single import or last in bulk - show success message
                closeLibraryBrowser();
                const hasAlternating = (ex.pattern_modifiers || []).includes('alternating');
                let patternMsg = isSidedPattern(ex.pattern)
                    ? 'üîÑ Side tracking enabled: Will log left and right separately'
                    : '‚úì Bilateral exercise: Both sides work together';
                if (hasAlternating && isSidedPattern(ex.pattern)) {
                    patternMsg += '\n‚ö° ALTERNATING: Switch sides on each rep within the set';
                }
                alert(`"${ex.canonical_name}" added to your program!\n\n${dosageSummary}\n\n${patternMsg}`);
                haptic('success');
            }
        }

        // EDIT DOSAGE FUNCTIONS
        let editingDosageExerciseId = null;

        function showEditDosageModal(exerciseId) {
            const ex = exerciseLibrary.find(e => e.id === exerciseId);
            if (!ex) return;

            editingDosageExerciseId = exerciseId;
            const spec = ex.current || {};
            const modifiers = ex.pattern_modifiers || [];

            document.getElementById('edit-dosage-exercise-name').textContent = ex.name;
            document.getElementById('edit-dosage-sets').value = spec.sets || '';
            document.getElementById('edit-dosage-reps').value = spec.repsPerSet || '';
            document.getElementById('edit-dosage-seconds').value = spec.secondsPerRep || '';
            document.getElementById('edit-dosage-distance').value = spec.distanceFeet || '';

            // Show/hide fields based on modifiers
            const repsContainer = document.getElementById('edit-dosage-reps-container');
            const secondsContainer = document.getElementById('edit-dosage-seconds-container');
            const secondsLabel = document.getElementById('edit-dosage-seconds-label');
            const distanceContainer = document.getElementById('edit-dosage-distance-container');

            const hasHold = modifiers.includes('hold_seconds');
            const hasDuration = modifiers.includes('duration_seconds');
            const hasDistance = modifiers.includes('distance_feet');

            if (hasDuration || hasDistance) {
                repsContainer.style.display = 'none';
            } else {
                repsContainer.style.display = 'block';
            }

            if (hasHold || hasDuration) {
                secondsContainer.style.display = 'block';
                secondsLabel.textContent = hasHold ? 'Hold Seconds (per rep)' : 'Duration (seconds)';
            } else {
                secondsContainer.style.display = 'none';
            }

            distanceContainer.style.display = hasDistance ? 'block' : 'none';

            document.getElementById('edit-dosage-modal').classList.add('active');
            haptic('medium');
        }

        function closeEditDosage() {
            document.getElementById('edit-dosage-modal').classList.remove('active');
            editingDosageExerciseId = null;
            haptic('medium');
        }

        function saveEditedDosage() {
            if (!editingDosageExerciseId) return;

            const sets = parseInt(document.getElementById('edit-dosage-sets').value);
            let reps = parseInt(document.getElementById('edit-dosage-reps').value);
            const seconds = parseInt(document.getElementById('edit-dosage-seconds').value) || 0;
            const distance = parseInt(document.getElementById('edit-dosage-distance').value) || 0;

            if (!sets || sets < 1) {
                alert('Please enter valid sets');
                return;
            }

            const ex = exerciseLibrary.find(e => e.id === editingDosageExerciseId);
            if (!ex) return;

            const modifiers = ex.pattern_modifiers || [];
            const replacesReps = modifiers.includes('duration_seconds') || modifiers.includes('distance_feet');
            const hasDistance = modifiers.includes('distance_feet');

            if (replacesReps) {
                reps = 1;
            } else {
                if (!reps || reps < 1) {
                    alert('Please enter valid reps');
                    return;
                }
            }

            // Validate required fields
            if (modifiers.includes('hold_seconds') && (!seconds || seconds < 1)) {
                alert('Please enter valid seconds for this hold exercise');
                return;
            }
            if (modifiers.includes('duration_seconds') && (!seconds || seconds < 1)) {
                alert('Please enter valid duration in seconds');
                return;
            }
            if (modifiers.includes('distance_feet') && (!distance || distance < 1)) {
                alert('Please enter valid distance in feet');
                return;
            }

            const previousSpec = ex.current || {};
            const newSpec = {
                type: hasDistance ? 'distance' : modifiers.includes('hold_seconds') ? 'hold' : modifiers.includes('duration_seconds') ? 'duration' : 'reps',
                sets: sets,
                repsPerSet: hasDistance ? distance : reps,
                secondsPerRep: seconds
            };

            if (modifiers.includes('distance_feet') && distance > 0) {
                newSpec.distanceFeet = distance;
            }

            // Build dosage summary
            let dosageSummary = `${sets} sets`;
            if (!replacesReps) dosageSummary += ` √ó ${reps} reps`;
            if (seconds > 0) dosageSummary += ` √ó ${seconds}s`;
            if (distance > 0) dosageSummary += ` √ó ${distance}ft`;

            // Update current spec
            ex.current = newSpec;

            // Add to history
            if (!ex.history) ex.history = [];
            ex.history.push({
                timestamp: new Date().toISOString(),
                summary: `Dosage updated to ${dosageSummary}`,
                previous: previousSpec,
                next: newSpec,
                supersedes: []
            });

            persistExerciseLibrary();
            closeEditDosage();
            renderExerciseList();

            alert(`Dosage updated!\n\n${dosageSummary}`);
            haptic('success');
        }

        function buildExerciseLibrarySchemaData(internalLibrary, { includeDosage = false } = {}) {
            // Convert from internal format to schema format
            const exercises = internalLibrary.map(ex => {
                // Parse anatomicRegions back to array
                const heatmapTags = ex.anatomicRegions
                    ? ex.anatomicRegions.split(',').map(s => s.trim()).filter(Boolean)
                    : [];

                const schemaExercise = {
                    id: ex.id,
                    canonical_name: ex.name,
                    description: ex.description || '',
                    pt_category: ex.pt_category || 'other',
                    primary_muscles: ex.primary_muscles || [],
                    secondary_muscles: ex.secondary_muscles || [],
                    pattern: ex.pattern || 'both',
                    pattern_modifiers: ex.pattern_modifiers || [],
                    equipment: {
                        required: ex.equipment || [],
                        optional: ex.equipmentOptional || []
                    },
                    form_parameters_required: ex.form_parameters_required || [],
                    tags: {
                        functional: ex.tags || [],
                        format: [], // Not tracked in internal format
                        heatmap: heatmapTags
                    },
                    guidance: ex.guidance || {
                        external_cues: [],
                        motor_cues: [],
                        compensation_warnings: [],
                        safety_flags: []
                    },
                    lifecycle: {
                        status: ex.lifecycle?.status || (ex.archived ? 'archived' : 'active'),
                        effective_start_date: ex.lifecycle?.effective_start_date || null,
                        effective_end_date: ex.lifecycle?.effective_end_date
                            || (ex.archived && ex.superseded_date
                                ? ex.superseded_date.split('T')[0]
                                : null)
                    },
                    added_date: null,
                    updated_date: ex.history && ex.history.length > 0
                        ? ex.history[ex.history.length - 1].timestamp.split('T')[0]
                        : null,
                    // Supersedes metadata (CRITICAL for maintenance workflow)
                    supersedes: ex.supersedes || [],
                    superseded_by: ex.superseded_by || null,
                    superseded_date: ex.superseded_date || null
                };
                // Optionally include dosage so Firebase reflects PT tracker updates.
                if (includeDosage && ex.current) {
                    schemaExercise.current = ex.current;
                }
                return schemaExercise;
            });

            return {
                exercises: exercises
            };
        }

        function exportExerciseLibrary() {
            const stored = localStorage.getItem(LIBRARY_KEY);
            if (!stored) {
                alert('No exercise library data found.');
                return;
            }

            try {
                const internalLibrary = JSON.parse(stored);
                const schemaData = buildExerciseLibrarySchemaData(internalLibrary);
                const dateStamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                const filename = `pt_exercise_library-${dateStamp}.json`;
                downloadJSON(schemaData, filename);
                haptic('success');

                const archivedCount = internalLibrary.filter(ex => ex.lifecycle && ex.lifecycle.status === 'archived').length;
                const supersedesCount = internalLibrary.filter(ex => ex.supersedes && ex.supersedes.length > 0).length;
                alert(`‚úì Exported ${internalLibrary.length} exercises\n\n${archivedCount} archived\n${supersedesCount} with supersedes relationships\n\nReady for library maintenance!`);
            } catch (e) {
                console.error('Failed to export exercise library:', e);
                alert('Unable to export exercise library. Data may be corrupt.');
            }
        }

        function exportExerciseHistory() {
            const sessions = getSessionHistoryFromCache();
            if (!sessions || sessions.length === 0) {
                alert('No exercise history data found.');
                return;
            }

            try {
                const serializedSessions = serializeSessionHistory(sessions);

                // Calculate summary statistics
                const uniqueExercises = new Set(serializedSessions.map(s => s.exerciseId)).size;
                const totalSets = serializedSessions.reduce((sum, s) => sum + (s.sets?.length || 0), 0);
                const dateRange = serializedSessions.length > 0 ? {
                    first: serializedSessions[0].date,
                    last: serializedSessions[serializedSessions.length - 1].date
                } : null;

                // Build export with metadata
                const exportData = {
                    export_date: new Date().toISOString(),
                    export_type: 'pt_exercise_history',
                    data_version: localStorage.getItem(PT_VERSION_KEY) || PT_DATA_VERSION,
                    stats: {
                        total_sessions: serializedSessions.length,
                        unique_exercises: uniqueExercises,
                        total_sets: totalSets,
                        date_range: dateRange
                    },
                    sessions: serializedSessions
                };

                const dateStamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                const filename = `pt_exercise_history-${dateStamp}.json`;
                downloadJSON(exportData, filename);

                console.log(`[Export] History exported: ${serializedSessions.length} sessions, ${uniqueExercises} exercises`);
                haptic('success');
            } catch (e) {
                console.error('Failed to export exercise history:', e);
                alert('Unable to export exercise history. Data may be corrupt.');
            }
        }

        function exportAllData() {
            const library = localStorage.getItem(LIBRARY_KEY);
            const history = serializeSessionHistory(getSessionHistoryFromCache());
            const version = localStorage.getItem(PT_VERSION_KEY);

            if (!library && history.length === 0) {
                alert('No data found to export.');
                return;
            }

            try {
                const allData = {
                    pt_data_version: version || PT_DATA_VERSION,
                    pt_exercise_library: library ? JSON.parse(library) : [],
                    pt_tracker_data: history,
                    exported_at: new Date().toISOString()
                };

                const dateStamp = new Date().toISOString().slice(0, 10).replace(/-/g, '');
                const zipFiles = [];
                zipFiles.push({
                    name: `pt_all_data-${dateStamp}.json`,
                    content: JSON.stringify(allData, null, 2)
                });

                if (library) {
                    const libraryData = buildExerciseLibrarySchemaData(JSON.parse(library));
                    zipFiles.push({
                        name: `pt_exercise_library-${dateStamp}.json`,
                        content: JSON.stringify(libraryData, null, 2)
                    });
                }

                if (history.length > 0) {
                    zipFiles.push({
                        name: `pt_exercise_history-${dateStamp}.json`,
                        content: JSON.stringify(history, null, 2)
                    });
                }

                const zipBlob = createZip(zipFiles);
                const zipName = `pt_all_data-${dateStamp}.zip`;
                downloadBlob(zipName, zipBlob);
                haptic('success');
            } catch (e) {
                console.error('Failed to export all data:', e);
                alert('Unable to export data. One or more data sources may be corrupt.');
            }
        }

        // Mobile Safari compatible download helper
        function downloadJSON(data, filename) {
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            downloadBlob(filename, blob);
        }

        async function downloadBlob(filename, blob) {
            try {
                const file = new File([blob], filename, { type: blob.type || 'application/octet-stream' });
                if (navigator.canShare && navigator.canShare({ files: [file] })) {
                    await navigator.share({ files: [file] });
                    return;
                }
            } catch (err) {
                console.warn('Share failed, falling back to download.', err);
            }

            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.rel = 'noopener';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        }

        function createZip(files) {
            const encoder = new TextEncoder();
            const localChunks = [];
            const centralChunks = [];
            let offset = 0;

            for (const file of files) {
                const nameBytes = encoder.encode(file.name);
                const dataBytes = encoder.encode(file.content);
                const crc = crc32(dataBytes);
                const localHeader = new Uint8Array(30 + nameBytes.length);
                const view = new DataView(localHeader.buffer);
                view.setUint32(0, 0x04034b50, true);
                view.setUint16(4, 20, true);
                view.setUint16(6, 0, true);
                view.setUint16(8, 0, true);
                view.setUint16(10, 0, true);
                view.setUint16(12, 0, true);
                view.setUint32(14, crc, true);
                view.setUint32(18, dataBytes.length, true);
                view.setUint32(22, dataBytes.length, true);
                view.setUint16(26, nameBytes.length, true);
                view.setUint16(28, 0, true);
                localHeader.set(nameBytes, 30);

                localChunks.push(localHeader, dataBytes);

                const centralHeader = new Uint8Array(46 + nameBytes.length);
                const centralView = new DataView(centralHeader.buffer);
                centralView.setUint32(0, 0x02014b50, true);
                centralView.setUint16(4, 20, true);
                centralView.setUint16(6, 20, true);
                centralView.setUint16(8, 0, true);
                centralView.setUint16(10, 0, true);
                centralView.setUint16(12, 0, true);
                centralView.setUint16(14, 0, true);
                centralView.setUint32(16, crc, true);
                centralView.setUint32(20, dataBytes.length, true);
                centralView.setUint32(24, dataBytes.length, true);
                centralView.setUint16(28, nameBytes.length, true);
                centralView.setUint16(30, 0, true);
                centralView.setUint16(32, 0, true);
                centralView.setUint16(34, 0, true);
                centralView.setUint16(36, 0, true);
                centralView.setUint32(38, 0, true);
                centralView.setUint32(42, offset, true);
                centralHeader.set(nameBytes, 46);
                centralChunks.push(centralHeader);

                offset += localHeader.length + dataBytes.length;
            }

            const centralSize = centralChunks.reduce((sum, chunk) => sum + chunk.length, 0);
            const endRecord = new Uint8Array(22);
            const endView = new DataView(endRecord.buffer);
            endView.setUint32(0, 0x06054b50, true);
            endView.setUint16(4, 0, true);
            endView.setUint16(6, 0, true);
            endView.setUint16(8, files.length, true);
            endView.setUint16(10, files.length, true);
            endView.setUint32(12, centralSize, true);
            endView.setUint32(16, offset, true);
            endView.setUint16(20, 0, true);

            const allChunks = [...localChunks, ...centralChunks, endRecord];
            return new Blob(allChunks, { type: 'application/zip' });
        }

        function crc32(data) {
            let crc = 0xFFFFFFFF;
            for (let i = 0; i < data.length; i += 1) {
                crc ^= data[i];
                for (let j = 0; j < 8; j += 1) {
                    const mask = -(crc & 1);
                    crc = (crc >>> 1) ^ (0xEDB88320 & mask);
                }
            }
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }

        function handleImportFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Detect file type and import accordingly
                    if (data.pt_data_version !== undefined && data.pt_exercise_library !== undefined) {
                        // All-data export format
                        importAllData(data);
                    } else if (data.export_type === 'pt_exercise_history' && data.sessions) {
                        // New enhanced history format with metadata
                        importHistory(data.sessions, data.stats);
                    } else if (Array.isArray(data)) {
                        // Legacy individual export format (library or history)
                        // Try to detect which one based on structure
                        if (data.length > 0 && data[0].exerciseId !== undefined) {
                            // History format (legacy)
                            importHistory(data);
                        } else {
                            // Library format
                            importLibrary(data);
                        }
                    } else {
                        alert('Unrecognized file format. Please use a valid PT Tracker export file.');
                    }
                } catch (e) {
                    console.error('Failed to import file:', e);
                    alert('Unable to read file. Make sure it\'s a valid JSON export.');
                }

                // Reset file input
                event.target.value = '';
            };
            reader.readAsText(file);
        }

        function importAllData(data) {
            const message = `Import all data?\n\nThis will REPLACE:\n‚Ä¢ Exercise library (${data.pt_exercise_library?.length || 0} exercises)\n‚Ä¢ Exercise history (${data.pt_tracker_data?.length || 0} sessions)\n\nCurrent data will be overwritten. Continue?`;

            showActionSheet(message, () => {
                if (data.pt_exercise_library) {
                    // Update global exerciseLibrary and sync to Firestore
                    exerciseLibrary = data.pt_exercise_library;
                    window.exerciseLibrary = exerciseLibrary;
                    scheduleRuntimeSync('import-all');
                    scheduleSharedLibrarySync('import-all');
                }
                if (data.pt_tracker_data) {
                    setSessionHistoryCache(data.pt_tracker_data, { source: 'import-all', syncLocalStorage: true });
                    queueSessionsForFirestore(data.pt_tracker_data, 'import-all');
                    void syncRuntimeToFirestore();
                }
                if (data.pt_data_version) {
                    localStorage.setItem(PT_VERSION_KEY, data.pt_data_version);
                }

                // Update display
                renderExerciseList();
                renderLibraryExercises();
                closeDataBackup();
                alert('Data imported successfully! Syncing to Firestore...');
                haptic('success');
            });
        }

        function importLibrary(data) {
            const message = `Import exercise library?\n\nThis will REPLACE your current library with ${data.length} exercises.\n\nCurrent library will be overwritten. Continue?`;

            showActionSheet(message, () => {
                // Update global exerciseLibrary and sync to Firestore
                exerciseLibrary = data;
                window.exerciseLibrary = exerciseLibrary;
                scheduleRuntimeSync('import-library');
                scheduleSharedLibrarySync('import-library');
                renderExerciseList();
                renderLibraryExercises();
                closeDataBackup();
                alert('Exercise library imported successfully! Syncing to Firestore...');
                haptic('success');
            });
        }

        function importHistory(importedSessions, stats) {
            const currentSessions = loadHistory();
            const statsInfo = stats ? ` (${stats.total_sessions} sessions, ${stats.unique_exercises} exercises)` : '';

            // Build action sheet with merge and replace options
            const message = `Import ${importedSessions.length} sessions${statsInfo}?\n\nCurrent history: ${currentSessions.length} sessions\n\nChoose import method:`;

            const actions = [
                {
                    label: 'üîÄ Merge (keep both, remove duplicates)',
                    style: 'primary',
                    callback: () => mergeHistory(currentSessions, importedSessions)
                },
                {
                    label: '‚ö†Ô∏è Replace (delete current history)',
                    style: 'destructive',
                    callback: () => replaceHistory(importedSessions)
                }
            ];

            showActionSheetWithOptions(message, actions);
        }

        function mergeHistory(currentSessions, importedSessions) {
            // Create map of existing sessions by sessionId for fast lookup
            const sessionMap = new Map();
            currentSessions.forEach(s => {
                if (s.sessionId) {
                    sessionMap.set(s.sessionId, s);
                }
            });

            // Add imported sessions, deduplicating by sessionId
            let added = 0;
            let duplicates = 0;

            importedSessions.forEach(session => {
                if (session.sessionId && sessionMap.has(session.sessionId)) {
                    // Duplicate - keep newer one
                    const existing = sessionMap.get(session.sessionId);
                    if (new Date(session.date) > new Date(existing.date)) {
                        sessionMap.set(session.sessionId, session);
                        console.log(`[Import] Updated duplicate session: ${session.sessionId}`);
                    }
                    duplicates++;
                } else {
                    // New session
                    sessionMap.set(session.sessionId || `import-${Date.now()}-${added}`, session);
                    added++;
                }
            });

            // Convert map back to array and sort by date
            const mergedSessions = Array.from(sessionMap.values())
                .sort((a, b) => new Date(a.date) - new Date(b.date));

            // Save merged history
            setSessionHistoryCache(mergedSessions, { source: 'import-merge', syncLocalStorage: true });
            queueSessionsForFirestore(mergedSessions, 'import-merge');
            void syncRuntimeToFirestore();

            closeDataBackup();
            const message = `History merged successfully!\n\n‚Ä¢ Added: ${added} new sessions\n‚Ä¢ Duplicates skipped: ${duplicates}\n‚Ä¢ Total sessions: ${mergedSessions.length}`;
            alert(message);
            console.log(`[Import] Merge complete - Added: ${added}, Skipped: ${duplicates}, Total: ${mergedSessions.length}`);
            haptic('success');
        }

        function replaceHistory(importedSessions) {
            const confirmMsg = `‚ö†Ô∏è Are you sure?\n\nThis will permanently delete your current ${loadHistory().length} sessions and replace with ${importedSessions.length} imported sessions.\n\nThis cannot be undone!`;

            showActionSheet(confirmMsg, () => {
                setSessionHistoryCache(importedSessions, { source: 'import-replace', syncLocalStorage: true });
                queueSessionsForFirestore(importedSessions, 'import-replace');
                void syncRuntimeToFirestore();
                closeDataBackup();
                alert(`History replaced!\n\n${importedSessions.length} sessions imported.`);
                console.log(`[Import] History replaced with ${importedSessions.length} sessions`);
                haptic('success');
            });
        }

        function showActionSheetWithOptions(message, actions) {
            const sheet = document.createElement('div');
            sheet.className = 'action-sheet active';
            sheet.setAttribute('role', 'button');
            sheet.setAttribute('tabindex', '0');
            sheet.innerHTML = `
                <div class="action-sheet-content">
                    <div class="action-sheet-message">${message}</div>
                    ${actions.map(action => `
                        <button class="action-sheet-button ${action.style === 'destructive' ? 'destructive' : action.style === 'primary' ? 'primary' : ''}">${action.label}</button>
                    `).join('')}
                    <button class="action-sheet-button cancel">Cancel</button>
                </div>
            `;

            document.body.appendChild(sheet);

            const buttons = sheet.querySelectorAll('.action-sheet-button');
            buttons.forEach((btn, idx) => {
                btn.addEventListener('pointerup', () => {
                    if (idx < actions.length) {
                        actions[idx].callback();
                    }
                    document.body.removeChild(sheet);
                });
            });

            sheet.addEventListener('pointerup', (e) => {
                if (e.target === sheet) {
                    document.body.removeChild(sheet);
                }
            });

            sheet.addEventListener('keydown', (e) => {
                if ((e.key === 'Enter' || e.key === ' ') && e.target === sheet) {
                    document.body.removeChild(sheet);
                }
            });
        }

        function renderTagFilters() {
            const container = document.getElementById('tag-filter-container');
            const availableTags = getAvailableTags();
            container.innerHTML = availableTags.map(tag => {
                const active = filterTags.includes(tag);
                return `<span class="pill" data-action="toggleFilterTag" data-action-arg="${tag}" role="button" tabindex="0" style="cursor: pointer; background: ${active ? 'var(--ios-blue)' : 'rgba(0,122,255,0.1)'}; color: ${active ? 'white' : 'var(--ios-blue)'};">${tag}</span>`;
            }).join(' ');
            bindPointerHandlers(container);
        }

        function toggleFilterTag(tag) {
            if (filterTags.includes(tag)) {
                filterTags = filterTags.filter(t => t !== tag);
            } else {
                filterTags.push(tag);
            }
            renderTagFilters();
            filterExercises();
        }

        function filterExercises() {
            const searchTerm = document.getElementById('exercise-search').value.toLowerCase();
            const filtered = exerciseLibrary.filter(ex => {
                const matchesSearch = !searchTerm || ex.name.toLowerCase().includes(searchTerm);
                const matchesTags = filterTags.length === 0 || (ex.tags && filterTags.some(tag => ex.tags.includes(tag)));
                const notArchived = !ex.archived;
                return matchesSearch && matchesTags && notArchived;
            });
            renderExerciseList(filtered);
        }

        function toggleFavorite(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            entry.favorite = !entry.favorite;
            persistExerciseLibrary();
            renderExerciseList();
            haptic('medium');
        }

        function archiveExercise(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            showActionSheet(`Archive "${entry.name}"? You can restore it later from archived exercises.`, () => {
                entry.archived = true;
                updateExerciseLifecycle(entry, { archived: true });
                persistExerciseLibrary();
                renderExerciseList();
                haptic('success');
                void syncExerciseLibraryToFirestore('archive');
            });
        }

        let viewingArchived = false;

        function showArchivedExercises() {
            viewingArchived = !viewingArchived;
            const btn = document.getElementById('archived-btn');

            if (viewingArchived) {
                const archived = exerciseLibrary.filter(ex => ex.archived);
                btn.textContent = '‚Üê Back';
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
                renderArchivedList(archived);
            } else {
                btn.textContent = 'üì¶ Archived';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
                renderExerciseList();
            }
        }

        function renderArchivedList(archivedExercises) {
            const container = document.getElementById('exercise-list-content');

            if (archivedExercises.length === 0) {
                container.innerHTML = '<div class="history-item">No archived exercises.</div>';
                return;
            }

            container.innerHTML = archivedExercises.map(ex => {
                const spec = ex.current || {};
                return `
                    <div class="history-item">
                        <div>${ex.name}</div>
                        <div class="history-meta">${describeSpec(spec)}</div>
                        <div style="margin-top: 8px; display: flex; gap: 8px;">
                            <button class="control-btn btn-success" data-action="unarchiveExercise" data-action-arg="${ex.id}" data-stop-propagation="true" style="flex: 1; padding: 8px; font-size: 14px;">Restore</button>
                            <button class="control-btn btn-danger" data-action="permanentlyDeleteExercise" data-action-arg="${ex.id}" data-stop-propagation="true" style="flex: 1; padding: 8px; font-size: 14px;">Delete Forever</button>
                        </div>
                    </div>
                `;
            }).join('');
            bindPointerHandlers(container);
        }

        function unarchiveExercise(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            entry.archived = false;
            updateExerciseLifecycle(entry, { archived: false });
            persistExerciseLibrary();
            haptic('success');
            speak('Exercise restored');
            showArchivedExercises(); // Refresh archived view
            void syncExerciseLibraryToFirestore('unarchive');
        }

        // PT Notes functionality
        let lastReadNoteTime = localStorage.getItem('lastReadNoteTime') || new Date(0).toISOString();

        async function showNotesModal() {
            if (!currentUser) {
                showAuthModal();
                return;
            }

            document.getElementById('notes-modal').classList.add('active');
            await loadNotes();

            // Mark notes as read
            lastReadNoteTime = new Date().toISOString();
            localStorage.setItem('lastReadNoteTime', lastReadNoteTime);

            // Hide all note indicators
            const badge = document.getElementById('notes-badge');
            if (badge) badge.style.display = 'none';

            const menuBadge = document.getElementById('menu-notes-badge');
            if (menuBadge) menuBadge.style.display = 'none';

            const notesIndicator = document.getElementById('notes-indicator');
            if (notesIndicator) notesIndicator.style.display = 'none';

            // Reset button styling
            const notesButton = document.getElementById('notes-btn');
            if (notesButton) {
                notesButton.style.background = '';
                notesButton.style.color = '';
                notesButton.style.fontWeight = '';
            }
        }

        async function checkForNewNotes() {
            if (!currentUser) return;

            try {
                const notesRef = collection(db, `users/${currentUser.uid}/notes`);
                const q = query(notesRef, where('createdBy', '==', 'therapist'), where('createdAt', '>', lastReadNoteTime));
                // TODO(firebase-read): notes check requires API endpoint mapping
                const snapshot = await getDocs(q);

                if (!snapshot.empty) {
                    const count = snapshot.size;

                    // Update modal badge
                    const badge = document.getElementById('notes-badge');
                    const notesButton = document.getElementById('notes-btn');
                    if (badge) {
                        badge.textContent = count;
                        badge.style.display = 'block';
                    }

                    // Update menu badge
                    const menuBadge = document.getElementById('menu-notes-badge');
                    if (menuBadge) {
                        menuBadge.textContent = count;
                        menuBadge.style.display = 'block';
                    }

                    // Update header indicator
                    const notesIndicator = document.getElementById('notes-indicator');
                    const notesCountBadge = document.getElementById('notes-count-badge');
                    if (notesIndicator && notesCountBadge) {
                        notesIndicator.style.display = 'block';
                        notesCountBadge.textContent = count;
                    }

                    // Make button more prominent with highlighted styling
                    if (notesButton) {
                        notesButton.style.background = 'var(--ios-blue)';
                        notesButton.style.color = 'white';
                        notesButton.style.fontWeight = '600';
                    }
                }
            } catch (error) {
                console.error('[Firestore] Failed to check new notes:', error);
            }
        }

        function closeNotesModal() {
            document.getElementById('notes-modal').classList.remove('active');
        }

        async function loadNotes() {
            if (!currentUser) {
                console.log('[Notes] No current user, cannot load notes');
                return;
            }

            console.log('[Notes] Loading notes for user:', currentUser.uid);

            try {
                const notesRef = collection(db, `users/${currentUser.uid}/notes`);
                const q = query(notesRef, orderBy('createdAt', 'desc'));
                // TODO(firebase-read): notes load requires API endpoint mapping
                const snapshot = await getDocs(q);

                console.log('[Notes] Fetched notes, total count:', snapshot.size);

                const notesList = document.getElementById('notes-list');

                const now = Date.now();
                const oneHour = 60 * 60 * 1000;

                // Filter out archived notes (patient only sees their own archives)
                const visibleNotes = [];
                snapshot.docs.forEach(docSnap => {
                    const note = docSnap.data();
                    if (!note.deleted && (!note.archivedByPatient)) {
                        visibleNotes.push({ id: docSnap.id, data: note });
                    }
                });

                console.log('[Notes] Visible notes after filtering:', visibleNotes.length);

                // Mark therapist notes as read by patient
                const unreadTherapistNotes = visibleNotes.filter(noteDoc =>
                    noteDoc.data.createdBy === 'therapist' && !noteDoc.data.readByPatient
                );
                for (const noteDoc of unreadTherapistNotes) {
                    try {
                        const noteRef = doc(db, `users/${currentUser.uid}/notes/${noteDoc.id}`);
                        // TODO(firebase-write): replace note read status update with API
                        await updateDoc(noteRef, { readByPatient: true });
                    } catch (error) {
                        console.error('[Firestore] Failed to mark note as read:', error);
                    }
                }

                if (visibleNotes.length === 0) {
                    console.log('[Notes] No visible notes, showing empty message');
                    notesList.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">No notes yet</div>';
                    return;
                }

                let html = '';
                visibleNotes.forEach(noteDoc => {
                    const note = noteDoc.data;
                    const noteId = noteDoc.id;
                    const date = new Date(note.createdAt);
                    const dateStr = date.toLocaleString();
                    const isPatient = note.createdBy === 'patient';
                    const canUndo = (now - date.getTime() < oneHour); // Allow undo for any note within 1 hour

                    // Show read status for both sides
                    let readStatus = '';
                    if (isPatient) {
                        readStatus = note.readByTherapist ? '‚úì Read by PT' : '‚óã Sent';
                    } else {
                        readStatus = note.readByPatient ? '‚úì Read by you' : '‚óã New';
                    }

                    html += `
                        <div style="margin-bottom: 16px; padding: 12px; border-radius: 8px; background: ${isPatient ? 'var(--bg-tertiary)' : 'var(--bg-secondary)'}; border-left: 3px solid ${isPatient ? 'var(--ios-green)' : 'var(--ios-blue)'};">
                            <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
                                <div><strong>${isPatient ? 'You' : 'PT'}</strong> ‚Ä¢ ${dateStr}</div>
                                <span style="font-size: 10px; color: var(--text-secondary);">${readStatus}</span>
                            </div>
                            <div style="white-space: pre-wrap; margin-bottom: 8px;">${note.text}</div>
                            <div style="display: flex; gap: 8px; font-size: 12px;">
                                <button data-action="archiveNote" data-action-arg="${noteId}" style="background: transparent; border: none; color: var(--ios-red); cursor: pointer; padding: 4px 8px; font-size: 11px;">Hide</button>
                                ${canUndo ? `<button data-action="undoSendNote" data-action-arg="${noteId}" style="background: transparent; border: none; color: var(--ios-orange); cursor: pointer; padding: 4px 8px; font-size: 11px;">Undo Send</button>` : ''}
                            </div>
                        </div>
                    `;
                });

                notesList.innerHTML = html;

                // Bind event handlers to dynamically created buttons
                bindPointerHandlers(notesList);
            } catch (error) {
                console.error('[Firestore] Failed to load notes:', error);
            }
        }

        async function sendNote() {
            const text = document.getElementById('new-note-text').value.trim();

            if (!text) {
                alert('Please enter a note');
                return;
            }

            if (!currentUser) {
                alert('Please sign in to send notes');
                return;
            }

            console.log('[Notes] Sending note for user:', currentUser.uid);

            try {
                const notesRef = collection(db, `users/${currentUser.uid}/notes`);

                const noteData = {
                    text: text,
                    createdBy: 'patient',
                    createdAt: new Date().toISOString(),
                    authorUid: currentUser.uid
                };

                console.log('[Notes] Note data:', noteData);

                // TODO(firebase-write): replace note creation with API
                await addDoc(notesRef, noteData);

                console.log('[Notes] Note sent successfully');

                document.getElementById('new-note-text').value = '';
                await loadNotes();
                haptic('success');
            } catch (error) {
                console.error('[Firestore] Failed to send note:', error);
                alert('Failed to send note: ' + error.message);
            }
        }

        async function archiveNote(noteId) {
            if (!currentUser) return;

            try {
                const noteRef = doc(db, `users/${currentUser.uid}/notes/${noteId}`);
                // TODO(firebase-write): replace note archive update with API
                await updateDoc(noteRef, {
                    archivedByPatient: true
                });
                await loadNotes();
                haptic('success');
            } catch (error) {
                console.error('[Firestore] Failed to archive note:', error);
                alert('Failed to hide note');
            }
        }

        async function undoSendNote(noteId) {
            if (!currentUser) return;

            if (!confirm('Delete this note? It will be removed for both you and your PT.')) {
                return;
            }

            try {
                const noteRef = doc(db, `users/${currentUser.uid}/notes/${noteId}`);
                // TODO(firebase-write): replace note delete update with API
                await updateDoc(noteRef, {
                    deleted: true,
                    deletedAt: new Date().toISOString(),
                    deletedBy: 'patient'
                });
                await loadNotes();
                haptic('success');
            } catch (error) {
                console.error('[Firestore] Failed to delete note:', error);
                alert('Failed to delete note');
            }
        }

        // Expose note functions to window for bindPointerHandlers
        window.archiveNote = archiveNote;
        window.undoSendNote = undoSendNote;

        function permanentlyDeleteExercise(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            showActionSheet(`PERMANENTLY delete "${entry.name}"? This cannot be undone!`, () => {
                exerciseLibrary = exerciseLibrary.filter(ex => ex.id !== exerciseId);
                window.exerciseLibrary = exerciseLibrary;
                persistExerciseLibrary();
                haptic('success');
                showArchivedExercises(); // Refresh archived view
                void syncExerciseLibraryToFirestore('delete');
            });
        }

        function renderExerciseList(filteredLibrary = null) {
            let list = filteredLibrary || exerciseLibrary.filter(ex => !ex.archived);
            const container = document.getElementById('exercise-list-content');

            if (list.length === 0) {
                container.innerHTML = '<div class="history-item">No exercises found.</div>';
                return;
            }

            // Sort: favorites first, then by last used, then alphabetically
            const sessions = loadHistory();
            list = list.slice().sort((a, b) => {
                // Favorites first
                if (a.favorite && !b.favorite) return -1;
                if (!a.favorite && b.favorite) return 1;

                // Then by most recently used
                const aSession = sessions.filter(s => s.exerciseId === a.id).pop();
                const bSession = sessions.filter(s => s.exerciseId === b.id).pop();
                const aDate = aSession ? new Date(aSession.date).getTime() : 0;
                const bDate = bSession ? new Date(bSession.date).getTime() : 0;
                if (aDate !== bDate) return bDate - aDate;

                // Then alphabetically
                return a.name.localeCompare(b.name);
            });

            container.innerHTML = list.map(ex => {
                const spec = ex.current || {};
                const tags = ex.tags || [];
                const tagHtml = tags.length ? tags.map(t => `<span class="pill">${t}</span>`).join('') : '';
                const hasDetails = ex.details && (ex.details.description || ex.details.executionTips);
                const detailsIndicator = hasDetails ? ' üìã' : '';

                // Calculate quick stats and adherence
                const exerciseSessions = sessions.filter(s => s.exerciseId === ex.id || s.exerciseName === ex.name);
                const totalSessions = exerciseSessions.length;
                const lastSession = exerciseSessions.length ? new Date(exerciseSessions[exerciseSessions.length - 1].date) : null;

                // PT Adherence indicators
                let adherenceColor = '#999';
                let adherenceText = '';
                let adherenceIcon = '';

                if (lastSession) {
                    const daysSince = getLocalDayDiff(new Date(), lastSession);
                    if (daysSince === 0) {
                        adherenceText = 'Done today ‚úì';
                        adherenceColor = '#34C759';
                    } else if (daysSince <= 3) {
                        adherenceText = `${daysSince} day${daysSince > 1 ? 's' : ''} ago`;
                        adherenceColor = '#34C759';
                    } else if (daysSince <= 7) {
                        adherenceText = `${daysSince} days ago`;
                        adherenceColor = '#FF9500';
                        adherenceIcon = '‚ö†Ô∏è ';
                    } else {
                        adherenceText = `${daysSince} days ago`;
                        adherenceColor = '#FF3B30';
                        adherenceIcon = '‚ùó ';
                    }
                } else {
                    adherenceText = 'Never done';
                    adherenceColor = '#8E8E93';
                    adherenceIcon = '‚óã ';
                }

                const statsHtml = `<div style="font-size: 12px; color: ${adherenceColor}; margin-top: 4px; font-weight: 600;">${adherenceIcon}${adherenceText}${totalSessions > 0 ? ` ¬∑ ${totalSessions} session${totalSessions > 1 ? 's' : ''} total` : ''}</div>`;

                // Show alternating indicator
                const hasAlternating = (ex.pattern_modifiers || []).includes('alternating');
                const alternatingIndicator = hasAlternating && isSidedPattern(ex.pattern) ? ' ‚ö°' : '';

                // Show archived indicator
                const isArchived = ex.lifecycle?.status === 'archived' || ex.archived === true;
                const archivedIndicator = isArchived ? ' (archived)' : '';

                return `
                    <div class="history-item" style="cursor: pointer; border-left: 4px solid ${adherenceColor};">
                        <div data-action="selectExerciseFromList" data-action-arg="${ex.id}" role="button" tabindex="0">${ex.name}${archivedIndicator}${detailsIndicator}${alternatingIndicator}</div>
                        ${tagHtml ? `<div style="margin-top: 4px;">${tagHtml}</div>` : ''}
                        <div class="history-meta">${describeSpec(spec)}</div>
                        ${statsHtml}
                        <div style="margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap;">
                            <button class="control-btn ${ex.favorite ? 'btn-primary' : 'btn-secondary'}" data-action="toggleFavorite" data-action-arg="${ex.id}" data-stop-propagation="true" style="flex: 0 0 auto; padding: 8px 12px; font-size: 18px;">${ex.favorite ? '‚≠ê' : '‚òÜ'}</button>
                            <button class="control-btn btn-primary" data-action="showEditDosageModal" data-action-arg="${ex.id}" data-stop-propagation="true" style="flex: 1; padding: 8px; font-size: 14px;">üíä Dosage</button>
                            ${totalSessions > 0 ? `<button class="control-btn btn-success" data-action="showExerciseProgress" data-action-arg="${ex.id}" data-stop-propagation="true" style="flex: 1; padding: 8px; font-size: 14px;">üìä Progress</button>` : ''}
                            <button class="control-btn btn-secondary" data-action="showExerciseDetailsModal" data-action-arg="${ex.id}" data-stop-propagation="true" style="flex: 1; padding: 8px; font-size: 14px;">Details</button>
                            <button class="control-btn btn-danger" data-action="archiveExercise" data-action-arg="${ex.id}" data-stop-propagation="true" style="flex: 1; padding: 8px; font-size: 14px;">Archive</button>
                        </div>
                    </div>
                `;
            }).join('');
            bindPointerHandlers(container);
        }

        function selectExerciseFromList(exerciseId) {
            // Check for unsaved progress
            if (currentExercise && currentExercise.sessionData && currentExercise.sessionData.length > 0) {
                const setsLogged = currentExercise.sessionData.length;
                const message = `‚ö†Ô∏è Switch exercises?\n\nYou have ${setsLogged} unsaved set${setsLogged !== 1 ? 's' : ''} for "${currentExercise.name}".\n\nProgress will be lost if you switch now.`;

                showActionSheet(message, () => {
                    proceedToSwitchExercise(exerciseId);
                });
                return;
            }

            proceedToSwitchExercise(exerciseId);
        }

        function proceedToSwitchExercise(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            currentExercise = toSessionExercise(entry);

            // Remember this exercise for next session
            localStorage.setItem(LAST_EXERCISE_KEY, exerciseId);

            seedTimerSeconds();
            stopTimer();
            updateDisplay();
            closeExerciseList();
            haptic('success');

            // Announce last session info if available
            const sessions = loadHistory();
            const lastSession = sessions.filter(s => s.exerciseId === exerciseId).pop();
            if (lastSession) {
                const daysSince = getLocalDayDiff(new Date(), new Date(lastSession.date));
                if (daysSince === 0) {
                    speak('Last session: today');
                } else if (daysSince === 1) {
                    speak('Last session: yesterday');
                } else if (daysSince < 7) {
                    speak(`Last session: ${daysSince} days ago`);
                }
            }
        }

        function deleteExerciseFromList(exerciseId) {
            const entry = getLibraryEntryById(exerciseId);
            showActionSheet(`Delete "${entry.name}"? This cannot be undone.`, () => {
                exerciseLibrary = exerciseLibrary.filter(ex => ex.id !== exerciseId);
                window.exerciseLibrary = exerciseLibrary;
                persistExerciseLibrary();
                renderExerciseList();
                haptic('success');
            });
        }

        // Exercise Details Modal
        let editingDetailsExerciseId = null;

        function showExerciseDetailsModal(exerciseId = null) {
            if (!exerciseId && !currentExercise) {
                alert('Please select an exercise first');
                return;
            }
            editingDetailsExerciseId = exerciseId || currentExercise.id;
            const entry = getLibraryEntryById(editingDetailsExerciseId);
            const details = entry.details || {};

            // Use exact same rendering as exercise library detail view
            document.getElementById('exercise-details-title').textContent = entry.name || entry.canonical_name;

            const guidanceSection = document.getElementById('professional-guidance-section');
            const guidanceContent = document.getElementById('professional-guidance-content');

            // Build detail content using same format as showExerciseDetail() - lines 9022-9107
            const detailHtml = `
                ${entry.description ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Description</div>
                    <div style="font-size: 14px; color: var(--ios-gray);">${entry.description}</div>
                </div>
                ` : ''}

                ${entry.pattern ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Pattern</div>
                    <div style="font-size: 14px;">
                        <span class="pill" style="background: ${getPatternColor(entry.pattern)}; color: white;">
                            ${getPatternBadge(entry.pattern)} ${isSidedPattern(entry.pattern) ? 'Sided Exercise (work left and right separately)' : 'Bilateral Exercise (both sides together)'}
                        </span>
                        ${(entry.pattern_modifiers || []).includes('alternating') && isSidedPattern(entry.pattern) ? `
                        <span class="pill" style="background: var(--ios-orange); color: white; margin-left: 6px;">
                            ‚ö° ALTERNATING (switch sides each rep within set)
                        </span>
                        ` : ''}
                    </div>
                </div>
                ` : ''}

                ${entry.primary_muscles && entry.primary_muscles.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Primary Muscles</div>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        ${entry.primary_muscles.map(m => `<span class="pill" style="background: rgba(0,122,255,0.1); color: var(--ios-blue); font-size: 13px;">${m}</span>`).join('')}
                    </div>
                </div>
                ` : ''}

                ${entry.secondary_muscles && entry.secondary_muscles.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Secondary Muscles</div>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        ${entry.secondary_muscles.map(m => `<span class="pill" style="background: rgba(0,122,255,0.05); color: var(--ios-gray); font-size: 12px;">${m}</span>`).join('')}
                    </div>
                </div>
                ` : ''}

                ${entry.equipment && entry.equipment.required && entry.equipment.required.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Equipment Required</div>
                    <div style="font-size: 14px; color: var(--ios-gray);">${entry.equipment.required.join(', ')}</div>
                </div>
                ` : ''}

                ${entry.equipment && entry.equipment.optional && entry.equipment.optional.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Optional Equipment</div>
                    <div style="font-size: 14px; color: var(--ios-gray);">${entry.equipment.optional.join(', ')}</div>
                </div>
                ` : ''}

                ${entry.guidance && entry.guidance.external_cues && entry.guidance.external_cues.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">üëÄ External Cues</div>
                    <ul style="font-size: 13px; color: var(--ios-gray); margin: 0; padding-left: 20px;">
                        ${entry.guidance.external_cues.map(cue => `<li style="margin-bottom: 6px;">${cue}</li>`).join('')}
                    </ul>
                </div>
                ` : ''}

                ${entry.guidance && entry.guidance.motor_cues && entry.guidance.motor_cues.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">üí™ Motor Cues</div>
                    <ul style="font-size: 13px; color: var(--ios-gray); margin: 0; padding-left: 20px;">
                        ${entry.guidance.motor_cues.map(cue => `<li style="margin-bottom: 6px;">${cue}</li>`).join('')}
                    </ul>
                </div>
                ` : ''}

                ${entry.guidance && entry.guidance.compensation_warnings && entry.guidance.compensation_warnings.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px; color: var(--ios-orange);">‚ö†Ô∏è Compensation Warnings</div>
                    <ul style="font-size: 13px; color: var(--ios-gray); margin: 0; padding-left: 20px;">
                        ${entry.guidance.compensation_warnings.map(warning => `<li style="margin-bottom: 6px;">${warning}</li>`).join('')}
                    </ul>
                </div>
                ` : ''}

                ${entry.guidance && entry.guidance.safety_flags && entry.guidance.safety_flags.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px; color: var(--ios-red);">üõë Safety Flags</div>
                    <ul style="font-size: 13px; color: var(--ios-red); margin: 0; padding-left: 20px;">
                        ${entry.guidance.safety_flags.map(flag => `<li style="margin-bottom: 6px;">${flag}</li>`).join('')}
                    </ul>
                </div>
                ` : ''}
            `;

            guidanceContent.innerHTML = detailHtml;
            guidanceSection.style.display = detailHtml.trim() ? 'block' : 'none';

            // Keep hidden fields for data persistence
            document.getElementById('exercise-description').value = details.description || '';
            document.getElementById('exercise-tips').value = details.executionTips || '';
            document.getElementById('exercise-feel').value = details.shouldFeel || '';
            document.getElementById('exercise-not-feel').value = details.shouldNotFeel || '';
            document.getElementById('exercise-modifications').value = details.modifications || '';
            document.getElementById('exercise-rest-seconds').value = details.restSeconds || '';

            document.getElementById('exercise-details-modal').classList.add('active');
            haptic('medium');
        }

        function closeExerciseDetailsModal() {
            document.getElementById('exercise-details-modal').classList.remove('active');
            haptic('medium');
        }

        function saveExerciseDetails() {
            const entry = getLibraryEntryById(editingDetailsExerciseId);
            const details = {
                description: document.getElementById('exercise-description').value.trim(),
                executionTips: document.getElementById('exercise-tips').value.trim(),
                shouldFeel: document.getElementById('exercise-feel').value.trim(),
                shouldNotFeel: document.getElementById('exercise-not-feel').value.trim(),
                modifications: document.getElementById('exercise-modifications').value.trim(),
                restSeconds: parseInt(document.getElementById('exercise-rest-seconds').value) || null
            };

            entry.details = details;
            persistExerciseLibrary();

            closeExerciseDetailsModal();
            haptic('success');
        }

        // Rest Timer
        let restTimerInterval = null;
        let restSecondsRemaining = 0;
        let restSecondsTotal = 0;

        function showRestTimer(seconds) {
            restSecondsTotal = seconds;
            restSecondsRemaining = seconds;
            document.getElementById('rest-countdown').textContent = restSecondsRemaining;
            document.getElementById('rest-progress-bar').style.width = '100%';
            document.getElementById('rest-timer-modal').classList.add('active');
            haptic('medium');

            restTimerInterval = setInterval(() => {
                restSecondsRemaining--;
                document.getElementById('rest-countdown').textContent = restSecondsRemaining;
                const progress = (restSecondsRemaining / restSecondsTotal) * 100;
                document.getElementById('rest-progress-bar').style.width = progress + '%';

                // Countdown beeps
                if (restSecondsRemaining <= 3 && restSecondsRemaining > 0) {
                    playBeep(500, 100);
                    haptic('medium');
                }

                if (restSecondsRemaining <= 0) {
                    clearInterval(restTimerInterval);
                    restTimerInterval = null;
                    playCompletionSound();
                    haptic('success');
                    speak('Rest complete');
                    closeRestTimer();
                }
            }, 1000);
        }

        function closeRestTimer() {
            if (restTimerInterval) {
                clearInterval(restTimerInterval);
                restTimerInterval = null;
            }
            document.getElementById('rest-timer-modal').classList.remove('active');
            haptic('medium');
        }

        function skipRest() {
            if (restTimerInterval) {
                clearInterval(restTimerInterval);
                restTimerInterval = null;
            }
            closeRestTimer();
            haptic('medium');
        }

        // Session Recovery
        const RECOVERY_KEY = 'pt_session_recovery';

        function saveSessionRecovery() {
            //Escape if currentExercise is null or partially initialized
            if (
                !currentExercise ||
                !Array.isArray(currentExercise.sessionData)
            ) {
                localStorage.removeItem(RECOVERY_KEY);
                void syncRuntimeToFirestore();
                return;
            }
            
            if (currentExercise.sessionData.length > 0 || currentExercise.currentSet > 1 || currentExercise.currentRep > 0) {
                const recovery = {
                    exerciseId: currentExercise.id,
                    exerciseName: currentExercise.name,
                    currentSet: currentExercise.currentSet,
                    currentRep: currentExercise.currentRep,
                    sessionData: currentExercise.sessionData,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem(RECOVERY_KEY, JSON.stringify(recovery));
                void syncRuntimeToFirestore();
            } else {
                localStorage.removeItem(RECOVERY_KEY);
                void syncRuntimeToFirestore();
            }
        }

        function checkSessionRecovery() {
            const recoveryData = localStorage.getItem(RECOVERY_KEY);
            if (!recoveryData) return;

            try {
                const recovery = JSON.parse(recoveryData);
                const timeDiff = Date.now() - new Date(recovery.timestamp).getTime();
                const hoursSince = timeDiff / (1000 * 60 * 60);

                // Only offer recovery if less than 24 hours old
                if (hoursSince < 24 && recovery.sessionData.length > 0) {
                    showActionSheet(
                        `Recover incomplete session for "${recovery.exerciseName}"? (${recovery.sessionData.length} sets completed)`,
                        () => {
                            const entry = getLibraryEntryById(recovery.exerciseId);
                            if (entry) {
                                currentExercise = toSessionExercise(entry);
                                currentExercise.currentSet = recovery.currentSet;
                                currentExercise.currentRep = recovery.currentRep;
                                currentExercise.sessionData = recovery.sessionData;
                                seedTimerSeconds();
                                updateDisplay();
                                haptic('success');
                                speak(`Recovered session: Set ${recovery.currentSet}`);
                            } else {
                                localStorage.removeItem(RECOVERY_KEY);
                                void syncRuntimeToFirestore();
                            }
                        }
                    );
                } else {
                    localStorage.removeItem(RECOVERY_KEY);
                    void syncRuntimeToFirestore();
                }
            } catch (e) {
                console.warn('Failed to parse recovery data:', e);
                localStorage.removeItem(RECOVERY_KEY);
                void syncRuntimeToFirestore();
            }
        }

        // Auto-save recovery every time session data changes
        window.addEventListener('beforeunload', saveSessionRecovery);
        setInterval(saveSessionRecovery, 5000); // Save every 5 seconds

        // PT Export Function
        function exportForPT() {
            // Load saved PT email if exists
            const savedEmail = localStorage.getItem('pt_email_address');
            if (savedEmail) {
                document.getElementById('pt-email-address').value = savedEmail;
            }
            document.getElementById('pt-note').value = '';
            document.getElementById('export-pt-modal').classList.add('active');
            haptic('medium');
        }

        function closeExportPTModal() {
            document.getElementById('export-pt-modal').classList.remove('active');
        }

        async function buildPtDataExport(note) {
            return {
                exportDate: new Date().toLocaleDateString('en-US', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                }),
                noteForPT: note || null,
                sessionHistory: serializeSessionHistory(loadHistory()),
                exerciseLibrary: loadExerciseLibrary(),
                rolesData: await loadRolesData(),
                schema: await loadSchema(),
                vocabulary: await loadVocabulary()
            };
        }

        async function copyPtPayloadOnly() {
            const note = document.getElementById('pt-note').value.trim();
            const exportData = await buildPtDataExport(note);
            const payload = await ptPayloadUtils.buildV2Block({ type: 'PT_DATA', obj: exportData });
            try {
                await navigator.clipboard.writeText(payload);
                alert('Payload copied to clipboard. Paste it into your PT editor.');
            } catch (err) {
                console.warn('Clipboard copy failed:', err);
                alert('Unable to copy to clipboard in this browser. Please use Send Email instead.');
            }
        }

        async function sendToPT() {
            const ptEmail = document.getElementById('pt-email-address').value.trim();
            const note = document.getElementById('pt-note').value.trim();

            // Save PT email for next time
            if (ptEmail) {
                localStorage.setItem('pt_email_address', ptEmail);
            }

            const exportData = await buildPtDataExport(note);
            const payload = await ptPayloadUtils.buildV2Block({ type: 'PT_DATA', obj: exportData });
            const dateStr = new Date().toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });

            // Build current dosage summary
            const activeExercises = loadExerciseLibrary().filter(ex => !ex.archived);
            let dosageSummary = '';
            if (activeExercises.length > 0) {
                dosageSummary = '\nCURRENT PROGRAM (Active Exercises):\n';
                dosageSummary += '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n';
                activeExercises.forEach(ex => {
                    const spec = ex.current || {};
                    dosageSummary += `‚Ä¢ ${ex.name}: ${describeSpec(spec)}\n`;
                });
                dosageSummary += '\n';
            }

            // Format email body with V2 block
            const emailBody = `Hi,

${note ? note + '\n\n' : ''}Please paste the data below into the PT Editor to review my progress.
${dosageSummary}
${payload}`;

            const subject = `PT Tracker Data - ${dateStr}`;

            // Create mailto link
            const mailtoLink = `mailto:${encodeURIComponent(ptEmail)}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(emailBody)}`;

            // Open email client
            window.location.href = mailtoLink;

            closeExportPTModal();
            haptic('success');
        }

        // Import PT Modifications from PT
        function importPTModifications() {
            document.getElementById('import-pt-content').value = '';
            document.getElementById('import-pt-modal').classList.add('active');
            haptic('medium');
        }

        function closeImportPTModal() {
            document.getElementById('import-pt-modal').classList.remove('active');
        }

        async function processPastedImport() {
            const pastedContent = document.getElementById('import-pt-content').value;

            if (!pastedContent.trim()) {
                alert('Please paste the email content from your PT');
                return;
            }

            try {
                const parsed = await ptPayloadUtils.parseV2FromText(pastedContent, 'PT_MODIFICATIONS');
                if (parsed.errors.length > 0) {
                    alert(parsed.errors.join('\n\n'));
                    return;
                }

                if (parsed.type !== 'PT_MODIFICATIONS') {
                    alert(`Invalid payload type: ${parsed.type}. Expected PT_MODIFICATIONS.`);
                    return;
                }

                const data = parsed.obj;

                if (!data || data.modificationType !== 'PT_MODIFICATIONS') {
                    alert('Invalid data: This is not a PT modifications payload.');
                    return;
                }

                closeImportPTModal();
                showModificationReview(data.modifications);
            } catch (err) {
                alert('Error parsing data: ' + err.message + '\n\nMake sure you pasted the complete email content.');
                console.error('Import error:', err);
            }
        }

        function mergeExerciseLibraries(sharedLibrary, localLibrary) {
            const exerciseMap = new Map();

            (sharedLibrary || []).forEach(ex => {
                if (!ex?.id) return;
                exerciseMap.set(ex.id, normalizeExerciseEntry(ex));
            });

            (localLibrary || []).forEach(ex => {
                if (!ex?.id) return;
                exerciseMap.set(ex.id, normalizeExerciseEntry(ex));
            });

            return Array.from(exerciseMap.values());
        }

        function shouldSyncSharedData({ label, existingCount, nextCount, sharedLoaded }) {
            if (!sharedLoaded) {
                console.warn(`[Import] Skipping ${label} sync to Firestore because shared data failed to load.`);
                return false;
            }

            if (existingCount > 0 && nextCount === 0) {
                console.warn(`[Import] Skipping ${label} sync to Firestore to prevent wipe (${existingCount} -> 0).`);
                return false;
            }

            return true;
        }

        async function showModificationReview(mods) {
            const newExCount = mods.newExercises?.length || 0;
            const editedExCount = Object.keys(mods.editedExercises || {}).length;
            const archivedExCount = mods.archivedExercises?.length || 0;
            const newRoleCount = Object.values(mods.newRoles || {}).reduce((sum, roles) => sum + roles.length, 0);
            const deletedRoleCount = Object.values(mods.deletedRoles || {}).reduce((sum, roles) => sum + roles.length, 0);
            const editedRoleCount = Object.keys(mods.editedRoles || {}).length;
            const dosageChangeCount = Object.keys(mods.dosageChanges || {}).length;
            const updatedVocabCount = Object.values(mods.updatedVocab || {}).reduce((sum, terms) => sum + Object.keys(terms).length, 0);

            let message = `PT Modifications Summary:\n\n`;
            if (newExCount > 0) message += `‚Ä¢ ${newExCount} new exercise${newExCount !== 1 ? 's' : ''}\n`;
            if (editedExCount > 0) message += `‚Ä¢ ${editedExCount} edited exercise${editedExCount !== 1 ? 's' : ''}\n`;
            if (archivedExCount > 0) message += `‚Ä¢ ${archivedExCount} archived exercise${archivedExCount !== 1 ? 's' : ''}\n`;
            if (newRoleCount > 0) message += `‚Ä¢ ${newRoleCount} new role${newRoleCount !== 1 ? 's' : ''}\n`;
            if (deletedRoleCount > 0) message += `‚Ä¢ ${deletedRoleCount} deleted role${deletedRoleCount !== 1 ? 's' : ''}\n`;
            if (editedRoleCount > 0) message += `‚Ä¢ ${editedRoleCount} edited role set${editedRoleCount !== 1 ? 's' : ''}\n`;
            if (dosageChangeCount > 0) message += `‚Ä¢ ${dosageChangeCount} dosage${dosageChangeCount !== 1 ? 's' : ''} updated\n`;
            if (updatedVocabCount > 0) message += `‚Ä¢ ${updatedVocabCount} vocabulary update${updatedVocabCount !== 1 ? 's' : ''}\n`;
            message += `\nAccept and merge all changes?`;

            if (!confirm(message)) {
                return;
            }

            // Load current data (prefer shared Firestore, fallback to localStorage)
            const localExerciseLibrary = loadExerciseLibrary();
            let sharedExerciseLibrary = [];
            let sharedExerciseLibraryLoaded = false;
            let rolesData = null;
            let rolesDataLoaded = false;
            let sharedRolesCount = 0;
            let vocabulary = null;
            let vocabularyLoaded = false;
            let sharedVocabularyCount = 0;

            try {
                const result = await fetch('/api/exercises').then(r => r.json());
                sharedExerciseLibrary = result || [];
                sharedDocSource.sharedLibrary = 'api';
                setFirestoreReadSucceeded('sharedLibrary');
                markDocHydrated('sharedLibrary');
                sharedExerciseLibraryLoaded = true;
            } catch (error) {
                console.warn('[Import] Failed to load exercise library from Firestore; using local storage:', error);
            }

            const exerciseLibrary = mergeExerciseLibraries(sharedExerciseLibrary, localExerciseLibrary);

            try {
                // TODO(firebase-read): roles shared data requires API endpoint mapping
                const result = await loadExerciseRolesShared();
                rolesData = result?.data || { exercise_roles: {} };
                sharedDocSource.sharedRoles = result?.source || sharedDocSource.sharedRoles;
                if (result?.hasFirestoreReadSucceeded) {
                    setFirestoreReadSucceeded('sharedRoles');
                    markDocHydrated('sharedRoles');
                }
                rolesDataLoaded = true;
                sharedRolesCount = Object.keys(rolesData?.exercise_roles || {}).length;
            } catch (error) {
                console.warn('[Import] Failed to load roles from Firestore; using local storage:', error);
                rolesData = loadRolesDataSync();
            }

            try {
                // TODO(firebase-read): vocabulary shared data requires API endpoint mapping
                const result = await loadExerciseVocabularyShared();
                vocabulary = result?.data || {};
                sharedDocSource.sharedVocab = result?.source || sharedDocSource.sharedVocab;
                if (result?.hasFirestoreReadSucceeded) {
                    setFirestoreReadSucceeded('sharedVocab');
                    markDocHydrated('sharedVocab');
                }
                vocabularyLoaded = true;
                sharedVocabularyCount = Object.keys(vocabulary || {}).length;
            } catch (error) {
                console.warn('[Import] Failed to load vocabulary from Firestore; using local storage:', error);
                vocabulary = loadVocabularySync();
            }

            const localRoles = loadRolesDataSync();
            if (localRoles?.exercise_roles) {
                rolesData.exercise_roles = {
                    ...rolesData.exercise_roles,
                    ...localRoles.exercise_roles
                };
            }

            const localVocabulary = loadVocabularySync();
            if (localVocabulary && Object.keys(localVocabulary).length > 0) {
                vocabulary = {
                    ...vocabulary,
                    ...localVocabulary
                };
            }
            let mergedCount = 0;

            // 1. Add new exercises to library
            if (mods.newExercises && mods.newExercises.length > 0) {
                mods.newExercises.forEach(ex => {
                    const exists = exerciseLibrary.find(e => e.id === ex.id);
                    if (!exists) {
                        exerciseLibrary.push(ex);
                        mergedCount++;
                    }
                });
            }

            // 2. Update edited exercises in library
            if (mods.editedExercises && Object.keys(mods.editedExercises).length > 0) {
                Object.keys(mods.editedExercises).forEach(exerciseId => {
                    const updatedExercise = mods.editedExercises[exerciseId];
                    const index = exerciseLibrary.findIndex(e => e.id === exerciseId);
                    if (index !== -1) {
                        exerciseLibrary[index] = updatedExercise;
                        mergedCount++;
                    } else {
                        console.warn(`[Import] Edited exercise not found: ${exerciseId}`);
                    }
                });
            }

            // 3. Archive exercises (remove from library)
            if (mods.archivedExercises && mods.archivedExercises.length > 0) {
                mods.archivedExercises.forEach(exerciseId => {
                    const index = exerciseLibrary.findIndex(e => e.id === exerciseId);
                    if (index !== -1) {
                        exerciseLibrary.splice(index, 1);
                        mergedCount++;
                    }
                    // Also remove role data
                    if (rolesData.exercise_roles[exerciseId]) {
                        delete rolesData.exercise_roles[exerciseId];
                    }
                });
            }

            // 4. Add new roles
            if (mods.newRoles && Object.keys(mods.newRoles).length > 0) {
                Object.keys(mods.newRoles).forEach(exerciseId => {
                    // Find the exercise to get its name
                    const exercise = exerciseLibrary.find(e => e.id === exerciseId);
                    const exerciseName = exercise ? (exercise.name || exercise.canonical_name || exercise.title || exerciseId) : exerciseId;

                    if (!rolesData.exercise_roles[exerciseId]) {
                        rolesData.exercise_roles[exerciseId] = { name: exerciseName, roles: [] };
                    }
                    const newRoles = mods.newRoles[exerciseId];
                    newRoles.forEach(role => {
                        rolesData.exercise_roles[exerciseId].roles.push(role);
                        mergedCount++;
                    });
                });
            }

            // 5. Delete roles
            if (mods.deletedRoles && Object.keys(mods.deletedRoles).length > 0) {
                Object.keys(mods.deletedRoles).forEach(exerciseId => {
                    if (rolesData.exercise_roles[exerciseId]) {
                        const rolesToDelete = mods.deletedRoles[exerciseId];
                        rolesToDelete.forEach(roleToDelete => {
                            const index = rolesData.exercise_roles[exerciseId].roles.findIndex(r =>
                                r.region === roleToDelete.region &&
                                r.capacity === roleToDelete.capacity &&
                                (r.focus || '') === (roleToDelete.focus || '')
                            );
                            if (index !== -1) {
                                rolesData.exercise_roles[exerciseId].roles.splice(index, 1);
                                mergedCount++;
                            }
                        });
                    } else {
                        console.warn(`[Import] Role data not found for exercise: ${exerciseId}`);
                    }
                });
            }

            // 6. Update edited roles (replace entire role set for exercise)
            if (mods.editedRoles && Object.keys(mods.editedRoles).length > 0) {
                Object.keys(mods.editedRoles).forEach(exerciseId => {
                    if (rolesData.exercise_roles[exerciseId]) {
                        rolesData.exercise_roles[exerciseId].roles = mods.editedRoles[exerciseId];
                        mergedCount++;
                    } else {
                        // Create new entry if it doesn't exist
                        const exercise = exerciseLibrary.find(e => e.id === exerciseId);
                        const exerciseName = exercise ? (exercise.name || exercise.canonical_name || exercise.title || exerciseId) : exerciseId;
                        rolesData.exercise_roles[exerciseId] = {
                            name: exerciseName,
                            roles: mods.editedRoles[exerciseId]
                        };
                        mergedCount++;
                    }
                });
            }

            // 7. Update dosages
            if (mods.dosageChanges && Object.keys(mods.dosageChanges).length > 0) {
                Object.keys(mods.dosageChanges).forEach(exerciseId => {
                    const exercise = exerciseLibrary.find(e => e.id === exerciseId);
                    if (exercise) {
                        const previousSpec = exercise.current || {};
                        exercise.current = mods.dosageChanges[exerciseId];

                        // Add to history
                        if (!exercise.history) exercise.history = [];
                        exercise.history.push({
                            timestamp: new Date().toISOString(),
                            summary: `Dosage updated by PT`,
                            previous: previousSpec,
                            next: mods.dosageChanges[exerciseId],
                            supersedes: []
                        });
                        mergedCount++;
                    } else {
                        console.warn(`[Import] Dosage change for unknown exercise: ${exerciseId}`);
                    }
                });
            }

            // 8. Update vocabulary
            if (mods.updatedVocab && Object.keys(mods.updatedVocab).length > 0) {
                Object.keys(mods.updatedVocab).forEach(category => {
                    if (!vocabulary[category]) {
                        vocabulary[category] = {};
                    }
                    Object.assign(vocabulary[category], mods.updatedVocab[category]);
                    mergedCount++;
                });
            }

            // Save all updated data - update global and sync to Firestore
            window.exerciseLibrary = exerciseLibrary;
            saveRolesDataSync(rolesData);
            saveVocabularySync(vocabulary);

            const schemaFormattedLibrary = buildExerciseLibrarySchemaData(exerciseLibrary, { includeDosage: true });
            try {
                const sharedLibraryCount = sharedExerciseLibrary.length;
                const nextLibraryCount = schemaFormattedLibrary.exercises?.length || 0;
                const nextRolesCount = Object.keys(rolesData?.exercise_roles || {}).length;
                const nextVocabularyCount = Object.keys(vocabulary || {}).length;

                const syncTasks = [];

                if (shouldSyncSharedData({
                    label: 'exercise library',
                    existingCount: sharedLibraryCount,
                    nextCount: nextLibraryCount,
                    sharedLoaded: sharedExerciseLibraryLoaded
                })) {
                    syncTasks.push((async () => {
                        const canWrite = await confirmCanonicalWrite({
                            docKey: 'sharedLibrary',
                            source: sharedDocSource.sharedLibrary
                        });
                        if (!canWrite) {
                            if (sharedDocSource.sharedLibrary !== 'fallback' && sharedDocSource.sharedLibrary !== 'cache') {
                                pendingWriteFlags.sharedLibrary = true;
                            }
                            return;
                        }
                        // TODO(firebase-write): replace shared library write with API
                        await saveExerciseLibraryShared(schemaFormattedLibrary);
                    })());
                }

                if (shouldSyncSharedData({
                    label: 'exercise roles',
                    existingCount: sharedRolesCount,
                    nextCount: nextRolesCount,
                    sharedLoaded: rolesDataLoaded
                })) {
                    syncTasks.push((async () => {
                        const canWrite = await confirmCanonicalWrite({
                            docKey: 'sharedRoles',
                            source: sharedDocSource.sharedRoles
                        });
                        if (!canWrite) {
                            if (sharedDocSource.sharedRoles !== 'fallback' && sharedDocSource.sharedRoles !== 'cache') {
                                pendingWriteFlags.sharedRoles = true;
                            }
                            return;
                        }
                        // TODO(firebase-write): replace shared roles write with API
                        await saveExerciseRolesShared(rolesData);
                    })());
                }

                if (shouldSyncSharedData({
                    label: 'exercise vocabulary',
                    existingCount: sharedVocabularyCount,
                    nextCount: nextVocabularyCount,
                    sharedLoaded: vocabularyLoaded
                })) {
                    syncTasks.push((async () => {
                        const canWrite = await confirmCanonicalWrite({
                            docKey: 'sharedVocab',
                            source: sharedDocSource.sharedVocab
                        });
                        if (!canWrite) {
                            if (sharedDocSource.sharedVocab !== 'fallback' && sharedDocSource.sharedVocab !== 'cache') {
                                pendingWriteFlags.sharedVocab = true;
                            }
                            return;
                        }
                        // TODO(firebase-write): replace shared vocabulary write with API
                        await saveExerciseVocabularyShared(vocabulary);
                    })());
                }

                if (syncTasks.length > 0) {
                    await Promise.all(syncTasks);
                }
                console.log('[Import] Shared data synced to Firestore');
            } catch (error) {
                console.warn('[Import] Failed to sync shared data to Firestore:', error);
            }

            haptic('success');

            // Export backup package (library + roles + schemas) after successful import
            try {
                const dateStr = new Date().toISOString().split('T')[0];

                // Convert library to schema format (remove internal fields like history, current, bilateral)
                const schemaFormattedLibrary = buildExerciseLibrarySchemaData(exerciseLibrary);

                // Load schema files
                // TODO(firebase-read): schema shared data requires API endpoint mapping
                Promise.all([
                    loadExerciseFileSchemaShared(),
                    loadExerciseRolesSchemaShared()
                ]).then(([exerciseSchemaResult, rolesSchemaResult]) => {
                    const exerciseSchema = exerciseSchemaResult?.data || {};
                    const rolesSchema = rolesSchemaResult?.data || {};
                    const zipFiles = [
                        {
                            name: `exercise_library-${dateStr}.json`,
                            content: JSON.stringify(schemaFormattedLibrary, null, 2)
                        },
                        {
                            name: `exercise_roles-${dateStr}.json`,
                            content: JSON.stringify(rolesData, null, 2)
                        },
                        {
                            name: `exercise_file.schema-${dateStr}.json`,
                            content: JSON.stringify(exerciseSchema, null, 2)
                        },
                        {
                            name: `exercise_roles.schema-${dateStr}.json`,
                            content: JSON.stringify(rolesSchema, null, 2)
                        },
                        {
                            name: `exercise_roles_vocabulary-${dateStr}.json`,
                            content: JSON.stringify(vocabulary, null, 2)
                        }
                    ];

                    const zipBlob = createZip(zipFiles);
                    downloadBlob(`pt-import-backup-${dateStr}.zip`, zipBlob);

                    // Delay reload to allow download to start
                    setTimeout(() => {
                        alert(`Successfully merged ${mergedCount} changes from your PT!\n\nBackup downloaded. The app will now reload to apply all changes.`);
                        location.reload();
                    }, 1500);
                }).catch(err => {
                    console.error('[Import] Failed to load schemas for backup:', err);
                    // Still reload even if backup fails
                    alert(`Successfully merged ${mergedCount} changes from your PT!\n\n(Backup download failed - please export manually)\n\nThe app will now reload to apply all changes.`);
                    location.reload();
                });
            } catch (e) {
                console.error('[Import] Failed to export backup:', e);
                // Still reload even if backup fails
                alert(`Successfully merged ${mergedCount} changes from your PT!\n\n(Backup download failed - please export manually)\n\nThe app will now reload to apply all changes.`);
                location.reload();
            }
        }

        // Weekly Summary for PT - Quick Overview
        function exportWeeklySummary() {
            const sessions = loadHistory();
            const now = new Date();
            const sevenDaysAgo = new Date(now - (7 * 24 * 60 * 60 * 1000));
            sevenDaysAgo.setHours(0, 0, 0, 0);

            const weekSessions = sessions.filter(s => new Date(s.date) >= sevenDaysAgo);

            if (weekSessions.length === 0) {
                alert('No sessions in the last 7 days.');
                return;
            }

            let summary = `PT 7-DAY SUMMARY (ROLLING)\n`;
            summary += `${sevenDaysAgo.toLocaleDateString()} - ${now.toLocaleDateString()}\n`;
            summary += `Generated: ${new Date().toLocaleDateString()}\n\n`;

            summary += `${'='.repeat(40)}\n`;
            summary += `OVERVIEW\n`;
            summary += `${'='.repeat(40)}\n`;
            summary += `Total sessions (last 7 days): ${weekSessions.length}\n`;

            // Count unique exercises
            const uniqueExercises = new Set(weekSessions.map(s => s.exerciseId));
            summary += `Exercises performed: ${uniqueExercises.size}\n`;

            // Total work
            const totalSets = weekSessions.reduce((sum, s) => sum + (s.sets?.length || 0), 0);
            const totalReps = weekSessions.reduce((sum, s) => sum + s.sets.reduce((rs, set) => rs + (set.reps || 0), 0), 0);
            summary += `Total sets: ${totalSets}\n`;
            summary += `Total reps: ${totalReps}\n\n`;

            // Group by exercise
            summary += `${'='.repeat(40)}\n`;
            summary += `EXERCISES THIS WEEK\n`;
            summary += `${'='.repeat(40)}\n`;

            const exerciseGroups = {};
            weekSessions.forEach(session => {
                const exName = session.exerciseName;
                if (!exerciseGroups[exName]) {
                    exerciseGroups[exName] = {
                        sessions: [],
                        totalSets: 0,
                        totalReps: 0
                    };
                }
                exerciseGroups[exName].sessions.push(session);
                exerciseGroups[exName].totalSets += session.sets.length;
                exerciseGroups[exName].totalReps += session.sets.reduce((sum, set) => sum + (set.reps || 0), 0);
            });

            Object.keys(exerciseGroups).sort().forEach(exName => {
                const group = exerciseGroups[exName];
                summary += `\n${exName}\n`;
                summary += `  Sessions: ${group.sessions.length}√ó (last 7 days)\n`;
                summary += `  Total: ${group.totalSets} sets, ${group.totalReps} reps\n`;

                // Show dates
                const dates = group.sessions.map(s => new Date(s.date).toLocaleDateString());
                summary += `  Dates: ${dates.join(', ')}\n`;

                // Show notes if any
                const notes = group.sessions.filter(s => s.notes).map(s => s.notes);
                if (notes.length > 0) {
                    summary += `  Notes: ${notes.join(' | ')}\n`;
                }
            });

            summary += `\n${'='.repeat(40)}\n`;
            summary += `BODY PARTS WORKED\n`;
            summary += `${'='.repeat(40)}\n`;

            // Count body parts
            const bodyParts = {};
            weekSessions.forEach(session => {
                const exercise = getLibraryEntryById(session.exerciseId);
                if (exercise && exercise.tags) {
                    exercise.tags.forEach(tag => {
                        bodyParts[tag] = (bodyParts[tag] || 0) + 1;
                    });
                }
            });

            if (Object.keys(bodyParts).length > 0) {
                Object.keys(bodyParts).sort((a, b) => bodyParts[b] - bodyParts[a]).forEach(part => {
                    summary += `  ${part}: ${bodyParts[part]}√ó (last 7 days)\n`;
                });
            } else {
                summary += `  (No body part tags set)\n`;
            }

            summary += `\n${'='.repeat(40)}\n`;
            summary += `END OF 7-DAY SUMMARY\n`;

            // Copy to clipboard
            navigator.clipboard.writeText(summary).then(() => {
                speak('Summary copied');
                haptic('success');
                alert('7-day summary copied! Share with your PT.');
            }).catch(() => {
                const textarea = document.createElement('textarea');
                textarea.value = summary;
                textarea.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; font-family: monospace; font-size: 12px; padding: 20px;';
                document.body.appendChild(textarea);
                textarea.select();
                alert('7-day summary generated! Copy and share with your PT.');
            });
        }

        // PT-Appropriate Progress Tracking (Weekly Sessions, not daily streaks)
        function calculateWeeklyProgress() {
            const sessions = loadHistory();
            if (sessions.length === 0) return { thisWeek: 0, lastWeek: 0, totalWeeks: 0 };

            const now = new Date();
            const startOfThisWeek = new Date(now);
            startOfThisWeek.setDate(now.getDate() - now.getDay()); // Sunday
            startOfThisWeek.setHours(0, 0, 0, 0);

            const startOfLastWeek = new Date(startOfThisWeek);
            startOfLastWeek.setDate(startOfLastWeek.getDate() - 7);

            const thisWeekSessions = sessions.filter(s => new Date(s.date) >= startOfThisWeek);
            const lastWeekSessions = sessions.filter(s => {
                const date = new Date(s.date);
                return date >= startOfLastWeek && date < startOfThisWeek;
            });

            // Count unique workout weeks
            const uniqueWeeks = new Set();
            sessions.forEach(s => {
                const date = new Date(s.date);
                const weekStart = new Date(date);
                weekStart.setDate(date.getDate() - date.getDay());
                uniqueWeeks.add(weekStart.toDateString());
            });

            return {
                thisWeek: thisWeekSessions.length,
                lastWeek: lastWeekSessions.length,
                totalWeeks: uniqueWeeks.size
            };
        }

        function updateStreakDisplay() {
            const { thisWeek, lastWeek, totalWeeks } = calculateWeeklyProgress();
            const display = document.getElementById('streak-display');

            if (thisWeek > 0) {
                display.textContent = `üìÖ ${thisWeek}`;
            } else {
                display.textContent = '';
            }
        }

        // Body Heatmap - REPLACED BY REHAB COVERAGE VIEW
        /*
        const BODY_PART_COORDS = {
            neck: { top: '8%', left: '40%', width: '20%', height: '8%' },
            shoulder: { top: '16%', left: '20%', width: '60%', height: '10%' },
            arm: { top: '18%', left: '10%', width: '15%', height: '18%' },
            core: { top: '28%', left: '35%', width: '30%', height: '16%' },
            back: { top: '17%', left: '35%', width: '30%', height: '20%' },
            hip: { top: '38%', left: '32%', width: '36%', height: '12%' },
            glute: { top: '44%', left: '32%', width: '36%', height: '10%' },
            leg: { top: '50%', left: '30%', width: '18%', height: '25%' },
            knee: { top: '62%', left: '30%', width: '18%', height: '10%' },
            ankle: { top: '88%', left: '30%', width: '18%', height: '8%' },
            wrist: { top: '34%', left: '8%', width: '12%', height: '6%' },
            elbow: { top: '28%', left: '8%', width: '12%', height: '6%' }
        };

        function getBodyPartHeatLevel(sessions, bodyPart) {
            // Count sessions in last 7 days that worked this body part
            const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
            const recentSessions = sessions.filter(s => new Date(s.date).getTime() > sevenDaysAgo);

            let count = 0;
            recentSessions.forEach(session => {
                const exercise = getLibraryEntryById(session.exerciseId);
                if (!exercise) return;

                // Check tags
                if (exercise.tags && exercise.tags.includes(bodyPart)) count++;

                // Check anatomic regions
                if (exercise.anatomicRegions && exercise.anatomicRegions.toLowerCase().includes(bodyPart)) count++;
            });

            if (count === 0) return 'heat-none';
            if (count <= 2) return 'heat-low';
            if (count <= 4) return 'heat-medium';
            if (count <= 6) return 'heat-high';
            return 'heat-very-high';
        }

        function showBodyHeatmap() {
            const sessions = loadHistory();
            const diagram = document.getElementById('body-diagram');

            // Clear previous overlays
            diagram.innerHTML = '';

            // Add overlays for each body part
            Object.keys(BODY_PART_COORDS).forEach(part => {
                const coords = BODY_PART_COORDS[part];
                const heatLevel = getBodyPartHeatLevel(sessions, part);

                const overlay = document.createElement('div');
                overlay.className = `body-part-overlay ${heatLevel}`;
                overlay.style.top = coords.top;
                overlay.style.left = coords.left;
                overlay.style.width = coords.width;
                overlay.style.height = coords.height;
                overlay.textContent = part === 'leg' ? 'leg' : '';
                overlay.addEventListener('pointerup', () => showBodyPartDetails(part, sessions));

                diagram.appendChild(overlay);
            });

            document.getElementById('body-heatmap-modal').classList.add('active');
            document.getElementById('body-part-details').innerHTML = '';
            haptic('medium');
        }

        function closeBodyHeatmap() {
            document.getElementById('body-heatmap-modal').classList.remove('active');
            haptic('medium');
        }

        function showBodyPartDetails(bodyPart, sessions) {
            const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
            const recentSessions = sessions.filter(s => new Date(s.date).getTime() > sevenDaysAgo);

            const relevantExercises = [];
            recentSessions.forEach(session => {
                const exercise = getLibraryEntryById(session.exerciseId);
                if (!exercise) return;

                const matchesTags = exercise.tags && exercise.tags.includes(bodyPart);
                const matchesRegions = exercise.anatomicRegions && exercise.anatomicRegions.toLowerCase().includes(bodyPart);

                if (matchesTags || matchesRegions) {
                    const existing = relevantExercises.find(e => e.id === exercise.id);
                    if (existing) {
                        existing.count++;
                        existing.lastDate = new Date(Math.max(new Date(existing.lastDate), new Date(session.date)));
                    } else {
                        relevantExercises.push({
                            id: exercise.id,
                            name: exercise.name,
                            count: 1,
                            lastDate: new Date(session.date)
                        });
                    }
                }
            });

            const detailsDiv = document.getElementById('body-part-details');

            if (relevantExercises.length === 0) {
                detailsDiv.innerHTML = `
                    <div class="history-list">
                        <div class="history-item">
                            <strong>${bodyPart.toUpperCase()}</strong>
                            <div class="history-meta">No exercises in last 7 days</div>
                        </div>
                    </div>
                `;
            } else {
                detailsDiv.innerHTML = `
                    <div class="history-list">
                        <div class="history-item">
                            <strong>${bodyPart.toUpperCase()}</strong>
                            <div style="margin-top: 8px;">
                                ${relevantExercises.map(ex => `
                                    <div style="font-size: 14px; padding: 4px 0;">
                                        ${ex.name} <span class="pill">${ex.count}√ó this week</span>
                                        <div style="font-size: 11px; color: var(--text-secondary);">Last: ${ex.lastDate.toLocaleDateString()}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }

            haptic('medium');
        }
        */

        // Quick Exercise Switcher
        function showQuickSwitcher() {
            // If no exercise selected, go straight to exercise list
            if (!currentExercise) {
                showExerciseList();
                return;
            }

            const container = document.getElementById('quick-switcher-list');
            const activeExercises = exerciseLibrary.filter(ex => !ex.archived && (ex.favorite || ex.id === currentExercise.id));

            if (activeExercises.length <= 1) {
                // Show full exercise list if only one active
                showExerciseList();
                return;
            }

            container.innerHTML = activeExercises.map(ex => {
                const isCurrent = ex.id === currentExercise.id;
                const patternBadge = ' ' + getPatternBadge(ex.pattern);
                return `
                    <div class="history-item" style="cursor: pointer; background: ${isCurrent ? 'rgba(0,122,255,0.1)' : 'white'};" data-action="quickSwitchTo" data-action-arg="${ex.id}" role="button" tabindex="0">
                        <div>${isCurrent ? '‚ñ∂ ' : ''}${ex.name}${patternBadge}${ex.favorite ? ' ‚≠ê' : ''}</div>
                        <div class="history-meta">${describeSpec(ex.current || {})}</div>
                    </div>
                `;
            }).join('');
            bindPointerHandlers(container);

            document.getElementById('quick-switcher-modal').classList.add('active');
            haptic('medium');
        }

        function closeQuickSwitcher() {
            document.getElementById('quick-switcher-modal').classList.remove('active');
            haptic('medium');
        }

        function quickSwitchTo(exerciseId) {
            if (exerciseId === currentExercise.id) {
                closeQuickSwitcher();
                return;
            }

            // Save current progress before switching
            saveSessionRecovery();

            const entry = getLibraryEntryById(exerciseId);
            currentExercise = toSessionExercise(entry);

            // Remember this exercise for next session
            localStorage.setItem(LAST_EXERCISE_KEY, exerciseId);

            seedTimerSeconds();
            stopTimer();
            updateDisplay();
            closeQuickSwitcher();
            haptic('success');
            speak(`Switched to ${entry.name}`);
        }

        // Exercise Library Browser Functions
        let libraryExercises = [];
        let selectedLibraryExercise = null;
        let showOnlyNewExercises = true;  // Default: filter out already-imported
        let selectedExercisesForImport = new Set();  // Track checked exercises
        let isLoadingLibraryExercises = false;

        async function loadExerciseLibraryData() {
            isLoadingLibraryExercises = true;
            try {
                const timeoutMs = 7000;
                const result = await Promise.race([
                    fetch('/api/exercises').then(r => r.json()),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Request timed out.')), timeoutMs))
                ]);
                libraryExercises = result || [];
                sharedDocSource.sharedLibrary = 'api';
                setFirestoreReadSucceeded('sharedLibrary');
                markDocHydrated('sharedLibrary');
                console.log(`Loaded ${libraryExercises.length} exercises from shared library`);
                return libraryExercises;
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.error('Exercise library request timed out.');
                    alert('Failed to load exercise library:\nRequest timed out.\n\nCheck your connection and try again.');
                } else {
                console.error('Failed to load exercise library:', error);
                alert(`Failed to load exercise library:\n${error.message}\n\nCheck your connection and try again.`);
                }
                libraryExercises = [];
                return [];
            } finally {
                isLoadingLibraryExercises = false;
            }
        }

        // BUG FIX: Change console.warn to console.error for better visibility
        async function syncRolesToFirestore(rolesData) {
            if (!currentUser) return;
            try {
                const canWrite = await confirmCanonicalWrite({
                    docKey: 'sharedRoles',
                    source: sharedDocSource.sharedRoles
                });
                if (!canWrite) {
                    if (sharedDocSource.sharedRoles !== 'fallback' && sharedDocSource.sharedRoles !== 'cache') {
                        pendingWriteFlags.sharedRoles = true;
                    }
                    return;
                }
                // TODO(firebase-write): replace shared roles write with API
                await saveExerciseRolesShared(rolesData);
            } catch (error) {
                console.error('[Roles] Failed to sync roles to Firestore:', error);
                // Note: Silent failure acceptable here as this is called from background sync
            }
        }

        // BUG FIX: Change console.warn to console.error for better visibility
        async function syncVocabularyToFirestore(vocabulary) {
            if (!currentUser) return;
            try {
                const canWrite = await confirmCanonicalWrite({
                    docKey: 'sharedVocab',
                    source: sharedDocSource.sharedVocab
                });
                if (!canWrite) {
                    if (sharedDocSource.sharedVocab !== 'fallback' && sharedDocSource.sharedVocab !== 'cache') {
                        pendingWriteFlags.sharedVocab = true;
                    }
                    return;
                }
                // TODO(firebase-write): replace shared vocabulary write with API
                await saveExerciseVocabularyShared(vocabulary);
            } catch (error) {
                console.error('[Vocabulary] Failed to sync vocabulary to Firestore:', error);
                // Note: Silent failure acceptable here as this is called from background sync
            }
        }

        async function showLibraryBrowser() {
            console.log('Opening library browser...');
            try {
                // Show loading message immediately
                document.getElementById('library-exercises-list').innerHTML = '<div class="history-item">Loading exercise library‚Ä¶</div>';
                document.getElementById('library-browser-modal').classList.add('active');

                if (libraryExercises.length === 0) {
                    console.log('Loading exercise library...');
                    await loadExerciseLibraryData();
                }

                console.log(`Library exercises loaded: ${libraryExercises.length}`);
                selectedExercisesForImport.clear();
                document.getElementById('bulk-import-btn').style.display = 'none';
                renderLibraryExercises();
                haptic('medium');
            } catch (error) {
                console.error('Error showing library browser:', error);
                alert(`Failed to open library browser:\n${error.message}`);
            }
        }

        function toggleShowOnlyNew() {
            showOnlyNewExercises = document.getElementById('show-new-toggle').checked;
            selectedExercisesForImport.clear();
            document.getElementById('bulk-import-btn').style.display = 'none';
            renderLibraryExercises();
        }

        function toggleExerciseSelection(exerciseId, event) {
            event.stopPropagation();
            if (selectedExercisesForImport.has(exerciseId)) {
                selectedExercisesForImport.delete(exerciseId);
            } else {
                selectedExercisesForImport.add(exerciseId);
            }

            // Show/hide import button based on selection
            const importBtn = document.getElementById('bulk-import-btn');
            importBtn.style.display = selectedExercisesForImport.size > 0 ? 'block' : 'none';

            // Update checkbox state
            const checkbox = document.getElementById(`ex-check-${exerciseId}`);
            if (checkbox) checkbox.checked = selectedExercisesForImport.has(exerciseId);
        }

        function renderLibraryExercises() {
            console.log('Rendering library exercises...');
            const container = document.getElementById('library-exercises-list');
            const searchTerm = document.getElementById('library-search').value.toLowerCase();

            // Check if still loading
            if (isLoadingLibraryExercises) {
                container.innerHTML = '<div class="history-item">Loading exercise library‚Ä¶</div>';
                return;
            }

            console.log(`Total library exercises: ${libraryExercises.length}`);
            console.log(`Exercise library size: ${exerciseLibrary.length}`);

            // Filter exercises based on search and "show only new" toggle
            let filtered = libraryExercises.filter(ex => {
                try {
                    const matchesSearch =
                        ex.canonical_name.toLowerCase().includes(searchTerm) ||
                        ex.description.toLowerCase().includes(searchTerm) ||
                        (ex.primary_muscles && ex.primary_muscles.some(m => m.toLowerCase().includes(searchTerm))) ||
                        (ex.equipment && ex.equipment.required && ex.equipment.required.some(e => e.toLowerCase().includes(searchTerm)));
                    return matchesSearch;
                } catch (error) {
                    console.error('Error filtering exercise:', ex.id, error);
                    return false;
                }
            });

            // Apply "show only new" filter
            if (showOnlyNewExercises) {
                filtered = filtered.filter(ex => !exerciseLibrary.find(e => e.id === ex.id));
            }

            console.log(`Filtered exercises: ${filtered.length}`);

            if (filtered.length === 0) {
                const message = showOnlyNewExercises
                    ? 'No new exercises found. Uncheck "Show only new" to see all.'
                    : 'No exercises found in library';
                container.innerHTML = `<div class="history-item">${message}</div>`;
                console.log('No exercises to display');
                return;
            }

            try {
                container.innerHTML = filtered.map((ex, idx) => {
                    try {
                        const patternLabel = getPatternBadge(ex.pattern) + ' ' + getPatternLabel(ex.pattern);
                        const patternColor = getPatternColor(ex.pattern);
                        const equipmentRequired = ex.equipment && ex.equipment.required ? ex.equipment.required : [];
                        const equipmentLabel = equipmentRequired.length > 0
                            ? equipmentRequired.join(', ')
                            : 'No equipment';

                        const alreadyImported = exerciseLibrary.find(e => e.id === ex.id);
                        const isChecked = selectedExercisesForImport.has(ex.id);
                        const checkboxDisabled = alreadyImported && !showOnlyNewExercises;
                        const primaryMuscles = ex.primary_muscles || [];

                        return `
                            <div class="history-item" style="display: flex; gap: 12px; align-items: start; ${alreadyImported && !showOnlyNewExercises ? 'opacity: 0.5;' : ''}">
                                <input type="checkbox"
                                       id="ex-check-${ex.id}"
                                       ${isChecked ? 'checked' : ''}
                                       ${checkboxDisabled ? 'disabled' : ''}
                                       data-action="toggleExerciseSelection"
                                       data-action-arg="${ex.id}"
                                       data-action-pass-event="true"
                                       style="width: 20px; height: 20px; margin-top: 2px; cursor: ${checkboxDisabled ? 'not-allowed' : 'pointer'};">
                                <div style="flex: 1; cursor: pointer;" data-action="showExerciseDetail" data-action-arg="${ex.id}" role="button" tabindex="0">
                                    <div style="font-weight: 600; margin-bottom: 4px;">
                                        ${ex.canonical_name}
                                        ${alreadyImported && !showOnlyNewExercises ? '<span style="font-size: 11px; color: var(--ios-green); margin-left: 6px;">‚úì Imported</span>' : ''}
                                    </div>
                                    <div style="font-size: 12px; color: var(--ios-gray); margin-bottom: 4px;">${(ex.description || '').substring(0, 100)}${(ex.description || '').length > 100 ? '...' : ''}</div>
                                    <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;">
                                        <span class="pill" style="background: ${patternColor}; color: white; font-size: 11px; padding: 4px 8px;">${patternLabel}</span>
                                        <span class="pill" style="background: rgba(0,122,255,0.1); color: var(--ios-blue); font-size: 11px; padding: 4px 8px;">üì¶ ${equipmentLabel}</span>
                                        <span class="pill" style="background: rgba(0,122,255,0.1); color: var(--ios-blue); font-size: 11px; padding: 4px 8px;">üí™ ${primaryMuscles.length} muscles</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    } catch (error) {
                        console.error(`Error rendering exercise ${ex.id}:`, error);
                        return `<div class="history-item" style="color: var(--ios-red);">Error rendering ${ex.id}</div>`;
                    }
                }).join('');
                console.log('Library exercises rendered successfully');
                bindPointerHandlers(container);
            } catch (error) {
                console.error('Error rendering library list:', error);
                container.innerHTML = `<div class="history-item" style="color: var(--ios-red);">Error loading exercises. Check console for details.</div>`;
            }
        }

        function filterLibraryExercises() {
            renderLibraryExercises();
        }

        function showExerciseDetail(exerciseId) {
            selectedLibraryExercise = libraryExercises.find(ex => ex.id === exerciseId);
            if (!selectedLibraryExercise) return;

            const ex = selectedLibraryExercise;
            document.getElementById('exercise-detail-title').textContent = ex.canonical_name;

            const detailContent = `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Description</div>
                    <div style="font-size: 14px; color: var(--ios-gray);">${ex.description}</div>
                </div>

                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Pattern</div>
                    <div style="font-size: 14px;">
                        <span class="pill" style="background: ${getPatternColor(ex.pattern)}; color: white;">
                            ${getPatternBadge(ex.pattern)} ${isSidedPattern(ex.pattern) ? 'Sided Exercise (work left and right separately)' : 'Bilateral Exercise (both sides together)'}
                        </span>
                        ${(ex.pattern_modifiers || []).includes('alternating') && isSidedPattern(ex.pattern) ? `
                        <span class="pill" style="background: var(--ios-orange); color: white; margin-left: 6px;">
                            ‚ö° ALTERNATING (switch sides each rep within set)
                        </span>
                        ` : ''}
                    </div>
                </div>

                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Primary Muscles</div>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        ${ex.primary_muscles.map(m => `<span class="pill" style="background: rgba(0,122,255,0.1); color: var(--ios-blue); font-size: 13px;">${m}</span>`).join('')}
                    </div>
                </div>

                ${ex.secondary_muscles.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Secondary Muscles</div>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        ${ex.secondary_muscles.map(m => `<span class="pill" style="background: rgba(0,122,255,0.05); color: var(--ios-gray); font-size: 12px;">${m}</span>`).join('')}
                    </div>
                </div>
                ` : ''}

                ${ex.equipment.required.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Equipment Required</div>
                    <div style="font-size: 14px; color: var(--ios-gray);">${ex.equipment.required.join(', ')}</div>
                </div>
                ` : ''}

                ${ex.equipment.optional.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">Optional Equipment</div>
                    <div style="font-size: 14px; color: var(--ios-gray);">${ex.equipment.optional.join(', ')}</div>
                </div>
                ` : ''}

                ${ex.guidance.external_cues.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">üëÄ External Cues</div>
                    <ul style="font-size: 13px; color: var(--ios-gray); margin: 0; padding-left: 20px;">
                        ${ex.guidance.external_cues.map(cue => `<li style="margin-bottom: 6px;">${cue}</li>`).join('')}
                    </ul>
                </div>
                ` : ''}

                ${ex.guidance.motor_cues.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px;">üí™ Motor Cues</div>
                    <ul style="font-size: 13px; color: var(--ios-gray); margin: 0; padding-left: 20px;">
                        ${ex.guidance.motor_cues.map(cue => `<li style="margin-bottom: 6px;">${cue}</li>`).join('')}
                    </ul>
                </div>
                ` : ''}

                ${ex.guidance.compensation_warnings.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px; color: var(--ios-orange);">‚ö†Ô∏è Compensation Warnings</div>
                    <ul style="font-size: 13px; color: var(--ios-gray); margin: 0; padding-left: 20px;">
                        ${ex.guidance.compensation_warnings.map(warning => `<li style="margin-bottom: 6px;">${warning}</li>`).join('')}
                    </ul>
                </div>
                ` : ''}

                ${ex.guidance.safety_flags.length > 0 ? `
                <div style="margin-bottom: 16px;">
                    <div style="font-weight: 600; margin-bottom: 8px; color: var(--ios-red);">üõë Safety Flags</div>
                    <ul style="font-size: 13px; color: var(--ios-red); margin: 0; padding-left: 20px;">
                        ${ex.guidance.safety_flags.map(flag => `<li style="margin-bottom: 6px;">${flag}</li>`).join('')}
                    </ul>
                </div>
                ` : ''}
            `;

            document.getElementById('exercise-detail-content').innerHTML = detailContent;
            document.getElementById('library-browser-modal').classList.remove('active');
            document.getElementById('exercise-detail-modal').classList.add('active');
            haptic('medium');
        }

        function closeExerciseDetail() {
            document.getElementById('exercise-detail-modal').classList.remove('active');
            document.getElementById('library-browser-modal').classList.add('active');
            haptic('medium');
        }

        function importLibraryExercise() {
            if (!selectedLibraryExercise) return;

            const ex = selectedLibraryExercise;

            // Check if already imported
            if (exerciseLibrary.find(e => e.id === ex.id)) {
                alert('This exercise is already in your library!');
                return;
            }

            // If PT has assigned dosage, use it directly
            if (ex.current && ex.current.sets) {
                importExerciseWithDosage(ex, ex.current, 'PT-assigned dosage');
                closeExerciseDetail();
                closeLibraryBrowser();

                const isBilateral = isBilateralPattern(ex.pattern);
                const hasAlternating = (ex.pattern_modifiers || []).includes('alternating');
                let patternMsg = isSidedPattern(ex.pattern)
                    ? 'üîÑ Side tracking enabled: Will log left and right separately'
                    : '‚úì Bilateral exercise: Both sides work together';
                if (hasAlternating && isSidedPattern(ex.pattern)) {
                    patternMsg += '\n‚ö° ALTERNATING: Switch sides on each rep within the set';
                }

                const dosageSummary = buildDosageSummary(ex.current, ex.pattern_modifiers || []);
                alert(`"${ex.canonical_name}" added to your program!\n\n${dosageSummary}\n(Using PT-assigned dosage)\n\n${patternMsg}`);
            } else {
                // No PT dosage - show prompt
                showDosagePrompt(ex);
            }
        }

        // Helper to build dosage summary string
        function buildDosageSummary(dosageSpec, modifiers) {
            const replacesReps = modifiers.includes('duration_seconds') || modifiers.includes('distance_feet');
            let summary = `${dosageSpec.sets} sets`;
            if (!replacesReps && dosageSpec.repsPerSet) {
                summary += ` √ó ${dosageSpec.repsPerSet} reps`;
            }
            if (dosageSpec.secondsPerRep && dosageSpec.secondsPerRep > 0) {
                summary += ` √ó ${dosageSpec.secondsPerRep}s`;
            }
            if (dosageSpec.distanceFeet && dosageSpec.distanceFeet > 0) {
                summary += ` √ó ${dosageSpec.distanceFeet}ft`;
            }
            return summary;
        }

        // Helper to import exercise with a given dosage spec
        function importExerciseWithDosage(ex, dosageSpec, source) {
            const isBilateral = isBilateralPattern(ex.pattern);
            const sideOptions = getSideOptionsForPattern(ex.pattern);
            const simpleTags = ex.tags.functional || [];
            const equipmentList = ex.equipment.required || [];

            const dosageSummary = buildDosageSummary(dosageSpec, ex.pattern_modifiers || []);

            const newExercise = {
                id: ex.id,
                name: ex.canonical_name,
                description: ex.description,
                pt_category: ex.pt_category,
                primary_muscles: ex.primary_muscles,
                secondary_muscles: ex.secondary_muscles,
                pattern: ex.pattern,
                pattern_modifiers: ex.pattern_modifiers,
                form_parameters_required: ex.form_parameters_required || [],
                equipment: equipmentList,
                equipmentOptional: ex.equipment.optional || [],
                guidance: ex.guidance,
                tags: simpleTags,
                sideOptions: sideOptions,
                primaryMuscles: ex.primary_muscles.join(', '),
                anatomicRegions: ex.tags.heatmap ? ex.tags.heatmap.join(', ') : '',
                difficulty: '',
                supersedes: [],
                current: dosageSpec,
                history: [
                    {
                        timestamp: new Date().toISOString(),
                        summary: `${source} (${dosageSummary})`,
                        previous: {},
                        next: dosageSpec,
                        supersedes: []
                    }
                ],
                favorite: false,
                archived: false
            };

            exerciseLibrary.push(newExercise);
            persistExerciseLibrary();
        }

        // Queue for bulk import - process one at a time with dosage prompts
        let bulkImportQueue = [];

        function bulkImportExercises() {
            if (selectedExercisesForImport.size === 0) {
                alert('No exercises selected');
                return;
            }

            // Convert selected IDs to array and filter out already-imported
            bulkImportQueue = Array.from(selectedExercisesForImport).filter(exerciseId => {
                const ex = libraryExercises.find(e => e.id === exerciseId);
                if (!ex) return false;
                // Skip if already imported
                if (exerciseLibrary.find(e => e.id === ex.id)) return false;
                return true;
            });

            if (bulkImportQueue.length === 0) {
                alert('All selected exercises are already in your program');
                selectedExercisesForImport.clear();
                return;
            }

            // Clear selection and close library browser
            selectedExercisesForImport.clear();
            closeLibraryBrowser();

            // Start importing first exercise
            processNextBulkImport();
        }

        function processNextBulkImport() {
            if (bulkImportQueue.length === 0) {
                // All done!
                alert('All exercises imported successfully!');
                haptic('success');
                return;
            }

            // Get next exercise ID and show dosage prompt
            const exerciseId = bulkImportQueue.shift();
            const ex = libraryExercises.find(e => e.id === exerciseId);
            if (ex) {
                showDosagePrompt(ex);
            } else {
                // Skip if not found, continue to next
                processNextBulkImport();
            }
        }

        function closeLibraryBrowser() {
            document.getElementById('library-browser-modal').classList.remove('active');
            haptic('medium');
        }

        Object.assign(window, {
            showQuickSwitcher,
            showWeeklyStats,
            showExerciseDetailsModal,
            showLibraryDiagnostics,
            // Expose for inline "Close" button in the library diagnostics modal.
            closeLibraryDiagnostics,
            toggleHamburgerMenu,
            showSettings,
            exportForPT,
            importPTModifications,
            endSessionEarly,
            incrementCounter,
            startTimer,
            stopTimer,
            resetTimer,
            logPartialTimerRep,
            previousSet,
            showLogSetModal,
            // Problem: Next Set actions were not reachable from data-action bindings; Fix: expose Next Set handlers on window.
            showNextSetModal,
            completeSet,
            showExerciseList,
            showHistory,
            togglePocketMode,
            closeExerciseModal,
            closeExerciseList,
            saveExercise,
            showPlanSessionModal,
            showLibraryBrowser,
            showArchivedExercises,
            showDataBackup,
            closeFormParamsModal,
            skipFormParams,
            saveFormParams,
            closeSessionNotesModal,
            skipFormParams,
            saveFormParams,
            confirmSkipNotes,
            saveSessionWithNotes,
            closeLogSetModal,
            saveLoggedSet,
            // Problem: Next Set modal buttons were not wired to window; Fix: expose modal handlers on window.
            closeNextSetModal,
            editNextSet,
            confirmNextSet,
            closeExerciseDetailsModal,
            saveExerciseDetails,
            skipRest,
            closeRestTimer,
            closeQuickSwitcher,
            exportWeeklySummary,
            reloadApp,
            addSetToEditSession,
            updateEditSessionSet,
            deleteSession,
            closeEditSession,
            saveEditedSession,
            closeHistoryModal,
            closeAllSessions,
            closeWeeklyStats,
            showAllSessions,
            closeAllSessions,
            closeWeeklyStats,
            showAllSessions,
            closeExerciseProgress,
            closeLibraryBrowser,
            bulkImportExercises,
            closeExerciseDetail,
            importLibraryExercise,
            exportAllData,
            exportExerciseLibrary,
            exportExerciseHistory,
            closeDataBackup,
            closeSettings,
            closeDosagePrompt,
            confirmDosage,
            closeEditDosage,
            saveEditedDosage,
            closePlanSessionModal,
            startPlannedSession,
            hideActionSheet,
            confirmActionSheet,
            closeExportPTModal,
            copyPtPayloadOnly,
            sendToPT,
            closeImportPTModal,
            processPastedImport,
            handlePocketTap,
            selectCurrentSide,
            selectLogSetSide,
            quickStartExercise,
            toggleExerciseInPlan,
            switchToPlannedExercise,
            showExerciseProgress,
            editSession,
            deleteEditSessionSet,
            selectExerciseFromList,
            toggleFilterTag,
            unarchiveExercise,
            permanentlyDeleteExercise,
            toggleFavorite,
            showEditDosageModal,
            archiveExercise,
            quickSwitchTo,
            toggleExerciseSelection,
            toggleShowOnlyNew,
            showExerciseDetail,
            showNotesModal,
            closeNotesModal,
            sendNote,
            archiveNote,
            undoSendNote
        });

        // iOS Safari/PWA does not reliably support onclick; unified pointer-based event handling enforced for iOS and desktop.
        // Problem: inline onclick can miss taps on iOS. Fix: bind pointerup/keydown handlers once on load.
        bindPointerHandlers();
        bindExerciseSearchEvents();

        function bindAuthModalEvents() {
            const guardButton = document.getElementById('auth-guard-signin-btn');
            const modal = document.getElementById('auth-modal');
            const closeButton = document.getElementById('auth-modal-close');
            const cancelButton = document.getElementById('auth-cancel-btn');
            const signInButton = document.getElementById('auth-signin-btn');
            const resetButton = document.getElementById('auth-reset-btn');

            if (guardButton) {
                guardButton.addEventListener('pointerup', showAuthModal);
                guardButton.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter' || event.key === ' ') {
                        event.preventDefault();
                        showAuthModal();
                    }
                });
            }

            if (signInButton) {
                signInButton.addEventListener('pointerup', handleSignIn);
            }

            if (resetButton) {
                resetButton.addEventListener('pointerup', handlePasswordReset);
            }

            if (closeButton) {
                closeButton.addEventListener('pointerup', hideAuthModal);
            }

            if (cancelButton) {
                cancelButton.addEventListener('pointerup', hideAuthModal);
            }

            if (modal) {
                modal.addEventListener('pointerup', (event) => {
                    if (event.target === modal) {
                        hideAuthModal();
                    }
                });
            }

            document.addEventListener('keydown', (event) => {
                if (authModalActive && event.key === 'Escape') {
                    event.preventDefault();
                    hideAuthModal();
                }
            });
        }

        bindAuthModalEvents();

        const menuSignInButton = document.getElementById('menu-signin-btn');
        const menuSignOutButton = document.getElementById('menu-signout-btn');
        if (menuSignInButton) {
            menuSignInButton.addEventListener('pointerup', handleMenuSignIn);
        }
        if (menuSignOutButton) {
            menuSignOutButton.addEventListener('pointerup', handleMenuSignOut);
        }

        // Initialize
        loadPreferences(); // Load user preferences
        document.getElementById('header-version').textContent = APP_VERSION; // Show version in header
        updateDisplay();
        updateStreakDisplay();
        // updateQuickStartShortcuts(); // REMOVED: Quick Start section removed
        setTimeout(checkSessionRecovery, 500); // Check for recovery after UI loads
        void reconcileSharedExerciseLibrary();
        // iOS Safari/PWA does not reliably support onclick; unified pointer-based event handling enforced for iOS and desktop.
        // Problem: onclick can miss "Next Set" taps on iOS. Fix: ensure pointerup binding stays in place.
        bindTouchActivation('next-set-btn', showNextSetModal);
        // Mark app boot complete to suppress the load-failed overlay.
        window.appBooted = true;
        const loadWarning = document.getElementById('app-load-warning');
        if (loadWarning) loadWarning.style.display = 'none';

        // Register Service Worker for offline support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw-pt.js')
                    .then(registration => {
                        console.log('PT Tracker SW registered:', registration.scope);
                    })
                    .catch(error => {
                        console.log('PT Tracker SW registration failed:', error);
                    });
            });
        }
    </script>
</body>
</html>
