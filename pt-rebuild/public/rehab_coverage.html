<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rehab Coverage Analysis</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" type="image/svg+xml" href="/icons/icon.svg">
    <link rel="apple-touch-icon" href="/icons/icon.svg">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="PT Tracker">
    <link rel="stylesheet" href="/css/main.css">
    <style>
        :root {
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f8f9fa;
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --border-color: #e0e0e0;
            --accent-color: #007AFF;
            --accent-hover: #0056b3;
            --success-color: #34C759;
            --success-bg: #d4edda;
            --warning-color: #FF9500;
            --warning-bg: #fff3cd;
            --danger-color: #FF3B30;
            --danger-bg: #f8d7da;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.08);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.1);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-primary: #0f1115;
                --bg-secondary: #1c1f26;
                --bg-tertiary: #2a2f3a;
                --text-primary: #f5f5f5;
                --text-secondary: #a0a0a0;
                --border-color: #3a3f4b;
                --accent-color: #4c8dff;
                --accent-hover: #3d7de6;
                --success-color: #34C759;
                --success-bg: rgba(52, 199, 89, 0.15);
                --warning-color: #FF9500;
                --warning-bg: rgba(255, 149, 0, 0.15);
                --danger-color: #FF3B30;
                --danger-bg: rgba(255, 59, 48, 0.15);
                --shadow-sm: 0 1px 3px rgba(0,0,0,0.3);
                --shadow-md: 0 4px 12px rgba(0,0,0,0.4);
            }
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: var(--bg-primary);
            color: var(--text-primary);
            -webkit-font-smoothing: antialiased;
            touch-action: manipulation; /* Prevent iOS double-tap zoom */
            -webkit-user-select: none;
            user-select: none;
        }

        .hidden {
            display: none !important;
        }

        /* Auth Modal */
        .auth-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .auth-modal.hidden {
            display: none;
        }

        .auth-content {
            background: var(--bg-secondary);
            padding: 2rem;
            border-radius: var(--radius-lg);
            max-width: 400px;
            width: 90%;
            box-shadow: var(--shadow-md);
        }

        .auth-content h2 {
            margin: 0 0 1.5rem 0;
            color: var(--text-primary);
        }

        .auth-form input {
            width: 100%;
            padding: 0.875rem;
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            font-size: 16px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .auth-form button {
            width: 100%;
            padding: 0.875rem;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: var(--radius-sm);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .auth-form button:active {
            background: var(--accent-hover);
        }

        .auth-error {
            color: var(--danger-color);
            margin-top: 1rem;
            font-size: 14px;
        }

        /* Header */
        .header {
            background: var(--bg-secondary);
            padding: 1rem 1.25rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            margin: 0;
            font-size: 1.35rem;
            font-weight: 700;
            color: var(--accent-color);
        }

        .header-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        /* Hamburger Menu */
        .hamburger-btn {
            background: transparent;
            border: none;
            font-size: 22px;
            cursor: pointer;
            padding: 8px;
            touch-action: manipulation;
        }

        .hamburger-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9998;
        }

        .hamburger-overlay.active {
            display: block;
        }

        .hamburger-menu {
            display: none;
            position: fixed;
            top: 0;
            right: 0;
            width: 280px;
            height: 100%;
            background: var(--bg-secondary);
            z-index: 9999;
            box-shadow: -2px 0 8px rgba(0, 0, 0, 0.2);
            overflow-y: auto;
        }

        .hamburger-menu.active {
            display: block;
        }

        .hamburger-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .hamburger-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .hamburger-close {
            background: transparent;
            border: none;
            color: var(--accent-color);
            font-size: 14px;
            cursor: pointer;
            padding: 8px;
        }

        .hamburger-user-info {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
            color: var(--text-secondary);
        }

        .hamburger-user-info strong {
            display: block;
            color: var(--text-primary);
            font-size: 14px;
            margin-bottom: 4px;
        }

        .hamburger-item {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            color: var(--text-primary);
            text-decoration: none;
            touch-action: manipulation;
        }

        .hamburger-item:active {
            background: var(--bg-tertiary);
        }

        .hamburger-icon {
            font-size: 20px;
            width: 24px;
            text-align: center;
        }

        .btn {
            padding: 0.625rem 1rem;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn:active {
            opacity: 0.85;
            transform: scale(0.98);
        }

        /* Region Accordion */
        .coverage-section {
            padding: 1rem;
        }

        .region-group {
            background: var(--bg-secondary);
            margin-bottom: 1rem;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            overflow: hidden;
        }

        .region-header {
            padding: 1rem 1.25rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .region-header:active {
            background: var(--bg-tertiary);
        }

        .region-title {
            font-weight: 700;
            font-size: 1.05rem;
            text-transform: capitalize;
        }

        .region-bar-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex: 1;
            margin-left: 1rem;
        }

        .coverage-bar {
            flex: 1;
            height: 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            overflow: hidden;
            min-width: 60px;
            max-width: 200px;
            border: 1px solid var(--border-color);
        }

        .coverage-bar-fill {
            height: 100%;
            border-radius: 5px;
            transition: width 0.3s ease, background 0.3s ease, opacity 0.3s ease;
        }

        .region-stats {
            font-size: 0.8rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .expand-icon {
            transition: transform 0.2s ease;
            font-size: 0.85rem;
            margin-left: 0.5rem;
        }

        .expand-icon.collapsed {
            transform: rotate(-90deg);
        }

        .region-content {
            padding: 1rem;
        }

        .region-content.collapsed {
            display: none;
        }

        /* Capacity Rows */
        .capacity-group {
            margin-bottom: 1rem;
            padding: 0.875rem;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            border-left: 4px solid var(--accent-color);
        }

        .capacity-group:last-child {
            margin-bottom: 0;
        }

        .capacity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .capacity-header:active {
            opacity: 0.8;
        }

        .capacity-title {
            font-weight: 600;
            font-size: 0.95rem;
            text-transform: capitalize;
            color: var(--accent-color);
        }

        .capacity-bar-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            margin-left: 0.75rem;
        }

        .capacity-stats {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .capacity-chevron {
            font-size: 0.8rem;
            color: var(--text-secondary);
            transition: transform 0.2s;
            margin-left: 0.5rem;
        }

        .capacity-group.expanded .capacity-chevron {
            transform: rotate(90deg);
        }

        /* Focus Rows */
        .focus-list {
            display: none;
            margin-top: 0.75rem;
            padding-left: 0.75rem;
            border-left: 2px solid var(--border-color);
        }

        .capacity-group.expanded .focus-list {
            display: block;
        }

        .focus-item {
            padding: 0.625rem;
            margin-bottom: 0.5rem;
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            border-left: 3px solid var(--success-color);
        }

        .focus-item:last-child {
            margin-bottom: 0;
        }

        .focus-item.needs-attention {
            border-left-color: var(--warning-color);
        }

        .focus-item.not-covered {
            border-left-color: var(--danger-color);
        }

        .focus-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .focus-name {
            font-weight: 500;
            font-size: 0.9rem;
            text-transform: capitalize;
        }

        .focus-stats {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Exercise List - Card Format (matching pt/rehab_coverage.html) */
        .exercise-list {
            margin-top: 0.5rem;
            padding: 4px 0;
        }

        .exercise-card {
            display: flex;
            align-items: flex-start;
            gap: 6px;
            padding: 6px 8px;
            margin: 3px 0;
            background: var(--bg-tertiary);
            border-radius: 4px;
            border-left: 3px solid;
        }

        .exercise-card-icon {
            min-width: 16px;
            margin-top: 2px;
            font-size: 14px;
        }

        .exercise-card-content {
            flex: 1;
            min-width: 0;
        }

        .exercise-card-title {
            font-size: 13px;
            font-weight: 500;
            word-wrap: break-word;
            line-height: 1.3;
        }

        .exercise-card-meta {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        /* Contribution colors */
        .contrib-high { border-left-color: var(--danger-color); }
        .contrib-medium { border-left-color: var(--warning-color); }
        .contrib-low { border-left-color: var(--accent-color); }

        .loading {
            text-align: center;
            padding: 3rem;
            color: var(--text-secondary);
        }

        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--text-secondary);
        }

        /* Legend Card */
        .legend-card {
            background: var(--bg-secondary);
            margin: 1rem;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            overflow: hidden;
        }

        .legend-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            cursor: pointer;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .legend-header:active {
            background: var(--border-color);
        }

        .legend-header h4 {
            margin: 0;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .legend-toggle {
            font-size: 1rem;
            color: var(--text-secondary);
            transition: transform 0.2s;
        }

        .legend-card.expanded .legend-toggle {
            transform: rotate(90deg);
        }

        .legend-content {
            display: none;
            padding: 1rem;
        }

        .legend-card.expanded .legend-content {
            display: block;
        }

        .legend-section {
            margin-bottom: 1rem;
        }

        .legend-section:last-child {
            margin-bottom: 0;
        }

        .legend-section-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--accent-color);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.35rem 0;
            font-size: 0.85rem;
        }

        .legend-sample {
            width: 40px;
            height: 12px;
            border-radius: 3px;
            border: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .legend-opacity-samples {
            display: flex;
            gap: 4px;
        }

        .legend-opacity-sample {
            width: 18px;
            height: 12px;
            border-radius: 3px;
            border: 1px solid var(--border-color);
        }

        .legend-description {
            color: var(--text-secondary);
            font-size: 0.8rem;
            line-height: 1.4;
            margin-top: 0.25rem;
        }

        /* Summary Card */
        .summary-card {
            background: var(--bg-secondary);
            padding: 1.25rem;
            margin: 1rem;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
        }

        .summary-card h3 {
            margin: 0 0 1rem 0;
            font-size: 1.1rem;
            font-weight: 700;
        }

        .summary-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
        }

        .summary-row:last-child {
            border-bottom: none;
        }

        .summary-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .summary-value {
            font-weight: 600;
            font-size: 1rem;
        }

        @media (prefers-color-scheme: dark) {
            .hamburger-menu,
            .header {
                background: var(--bg-secondary);
            }

            .hamburger-header,
            .hamburger-item {
                border-color: var(--border-color);
            }

            .hamburger-item:active {
                background: var(--bg-tertiary);
            }
        }
    </style>
</head>
<body>
    <!-- Auth Modal -->
    <div id="authModal" class="auth-modal">
        <div class="auth-content">
            <h2>Coverage Analysis Sign In</h2>
            <form id="authForm" class="auth-form">
                <input
                    type="email"
                    id="emailInput"
                    placeholder="Email"
                    required
                    autocomplete="email"
                >
                <input
                    type="password"
                    id="passwordInput"
                    placeholder="Password"
                    required
                    autocomplete="current-password"
                >
                <button type="submit">Sign In</button>
                <div id="authError" class="auth-error"></div>
            </form>
        </div>
    </div>

    <!-- Header -->
    <div class="header">
        <h1>Rehab Coverage</h1>
        <div class="header-actions">
            <button class="btn btn-secondary" data-action="refresh-data">‚Üª</button>
            <button class="hamburger-btn" data-action="toggle-hamburger">‚ò∞</button>
        </div>
    </div>

    <!-- Hamburger Menu -->
    <div class="hamburger-overlay" id="hamburgerOverlay" data-action="toggle-hamburger"></div>
    <div class="hamburger-menu" id="hamburgerMenu">
        <div class="hamburger-header">
            <h3>Menu</h3>
            <button class="hamburger-close" data-action="toggle-hamburger">Close</button>
        </div>
        <div class="hamburger-user-info" id="userInfo">
            <strong>Signed in as</strong>
            <span id="userEmail">Loading...</span>
        </div>
        <div>
            <a href="index.html" class="hamburger-item" id="ptTrackerLink">
                <span class="hamburger-icon">üè†</span>
                <span>PT Tracker</span>
            </a>
            <a href="pt_view.html" class="hamburger-item">
                <span class="hamburger-icon">üìä</span>
                <span>View History</span>
            </a>
            <a href="pt_editor.html" class="hamburger-item">
                <span class="hamburger-icon">‚úèÔ∏è</span>
                <span>Exercise Editor</span>
            </a>
            <div class="hamburger-item" data-action="refresh-data">
                <span class="hamburger-icon">üîÑ</span>
                <span>Refresh Data</span>
            </div>
            <div class="hamburger-item" data-action="sign-out">
                <span class="hamburger-icon">üö™</span>
                <span>Sign Out</span>
            </div>
        </div>
    </div>

    <!-- Summary Card -->
    <div class="summary-card">
        <h3>Coverage Overview</h3>
        <div class="summary-row">
            <span class="summary-label">Last Activity:</span>
            <span class="summary-value" id="lastActivity">‚Äî</span>
        </div>
        <div class="summary-row">
            <span class="summary-label">7-Day Coverage:</span>
            <span class="summary-value" id="weekCoverage">‚Äî</span>
        </div>
        <div class="summary-row">
            <span class="summary-label">21-Day Trend:</span>
            <span class="summary-value" id="trendStatus">‚Äî</span>
        </div>
    </div>

    <!-- Legend -->
    <div class="legend-card" id="legendCard">
        <div class="legend-header" data-action="toggle-legend">
            <h4>üìä How to Read Coverage Bars</h4>
            <span class="legend-toggle">‚Ä∫</span>
        </div>
        <div class="legend-content">
            <div class="legend-section">
                <div class="legend-section-title">Bar Width = 7-Day Density</div>
                <p class="legend-description">How consistently exercises are being done in the past week.</p>
                <div class="legend-row">
                    <div class="legend-sample" style="width: 40px; background: #888;"></div>
                    <span>100% = All exercises done daily</span>
                </div>
                <div class="legend-row">
                    <div class="legend-sample" style="width: 20px; background: #888;"></div>
                    <span>50% = About half the expected volume</span>
                </div>
                <div class="legend-row">
                    <div class="legend-sample" style="width: 4px; background: #888;"></div>
                    <span>0% = No exercises done this week</span>
                </div>
            </div>

            <div class="legend-section">
                <div class="legend-section-title">Bar Color = Recency</div>
                <p class="legend-description">How recently the most neglected exercise was done.</p>
                <div class="legend-row">
                    <div class="legend-sample" style="background: rgb(52, 199, 89);"></div>
                    <span>Green = Done within 3 days</span>
                </div>
                <div class="legend-row">
                    <div class="legend-sample" style="background: rgb(255, 204, 0);"></div>
                    <span>Yellow = 4-6 days ago</span>
                </div>
                <div class="legend-row">
                    <div class="legend-sample" style="background: rgb(255, 149, 0);"></div>
                    <span>Orange = 7-10 days ago</span>
                </div>
                <div class="legend-row">
                    <div class="legend-sample" style="background: rgb(255, 59, 48);"></div>
                    <span>Red = 11+ days or never done</span>
                </div>
            </div>

            <div class="legend-section">
                <div class="legend-section-title">Bar Opacity = 3-Week Momentum</div>
                <p class="legend-description">Shows if you're keeping up over time. <strong>Solid = exercising regularly.</strong> <strong>Faded = falling behind.</strong> Bars fade slowly when you skip sessions, but brighten quickly when you get back on track.</p>
                <div class="legend-row">
                    <div class="legend-opacity-samples">
                        <div class="legend-opacity-sample" style="background: #007AFF; opacity: 1;"></div>
                        <div class="legend-opacity-sample" style="background: #007AFF; opacity: 0.7;"></div>
                        <div class="legend-opacity-sample" style="background: #007AFF; opacity: 0.4;"></div>
                        <div class="legend-opacity-sample" style="background: #007AFF; opacity: 0.15;"></div>
                    </div>
                    <span>Solid ‚Üí Faded</span>
                </div>
                <div class="legend-row" style="margin-top: 4px;">
                    <span style="font-size: 12px;">‚Üë steady = doing great &nbsp;|&nbsp; ‚Üí ok = on track &nbsp;|&nbsp; ‚Üì slipping = do more</span>
                </div>
            </div>

            <div class="legend-section">
                <div class="legend-section-title">Exercise Borders</div>
                <div class="legend-row">
                    <div class="legend-sample" style="border-left: 3px solid var(--danger-color); background: var(--bg-tertiary);"></div>
                    <span>Red = HIGH contribution (priority)</span>
                </div>
                <div class="legend-row">
                    <div class="legend-sample" style="border-left: 3px solid var(--warning-color); background: var(--bg-tertiary);"></div>
                    <span>Orange = MEDIUM contribution</span>
                </div>
                <div class="legend-row">
                    <div class="legend-sample" style="border-left: 3px solid var(--accent-color); background: var(--bg-tertiary);"></div>
                    <span>Blue = LOW contribution</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Coverage Matrix -->
    <div class="coverage-section">
        <div id="coverageMatrix">
            <div class="loading">Loading coverage data...</div>
        </div>
    </div>

    <!-- Supabase Client -->
    <script src="/js/vendor/supabase.min.js"></script>

    <script>
        /**
         * ============================================================================
         * COVERAGE CALCULATION FORMULAS
         * ============================================================================
         *
         * These formulas implement THREE INDEPENDENT SIGNALS for exercise coverage:
         *   1. PERCENT (7-day density) - How consistently are exercises being done?
         *   2. COLOR (recency) - How recently was the most neglected exercise done?
         *   3. OPACITY (21-day trend) - What's the long-term engagement pattern?
         *
         * SPECIFICATION SOURCE: rehab_coverage formulas.md (LOCKED)
         *
         * To adjust thresholds or weights, edit the CONSTANTS object below.
         * ============================================================================
         */

        // ============================================================================
        // CONSTANTS - Edit these to adjust formula behavior
        // ============================================================================
        const COVERAGE_CONSTANTS = {
            // Contribution weights
            HIGH_WEIGHT: 1.0,
            MEDIUM_WEIGHT: 0.4,
            MEDIUM_BONUS_CAP: 15,        // Max percentage bonus from MEDIUM exercises

            // Opacity (21-day trend) settings
            OPACITY_WINDOW_DAYS: 21,
            OPACITY_OPTIMAL_DAYS: 15,    // Days of activity for 100% opacity

            // Decay thresholds (days since last activity)
            DECAY_NONE_MAX: 6,           // No decay if <= 6 days
            DECAY_SLIGHT_MAX: 9,         // Slight decay (0.8x) if 7-9 days
            DECAY_MODERATE_MAX: 13,      // Moderate decay (0.5x) if 10-13 days
            // Heavy decay (0.3x) if >= 14 days

            // Recovery thresholds (7-day activity count)
            RECOVERY_STRONG_MIN: 5,      // 90% floor
            RECOVERY_GOOD_MIN: 4,        // 70% floor
            RECOVERY_NOTICEABLE_MIN: 3,  // 50% floor

            // Focus aggregation weights
            FOCUS_WORST_WEIGHT: 0.6,
            FOCUS_OTHERS_WEIGHT: 0.4,

            // Region bar weight exponent
            REGION_WEIGHT_EXPONENT: 1.3,

            // Color score (recency) - days since last done -> score
            // Higher score = greener (more recent)
            COLOR_SCORE_DAY_0: 100,      // Done today
            COLOR_SCORE_DAY_1: 85,       // Done yesterday
            COLOR_SCORE_DAY_2: 60,       // 2 days ago
            COLOR_SCORE_DAY_3: 35,       // 3 days ago
            COLOR_SCORE_DAY_4: 15,       // 4 days ago
            COLOR_SCORE_DECAY: 2,        // Points lost per day after day 4

            // Recency text thresholds (based on color score)
            RECENCY_RECENT_MIN: 80,      // "‚úì done recently"
            RECENCY_FEW_DAYS_MIN: 60,    // "~ a few days ago"
            RECENCY_STALE_MIN: 40,       // "‚ö† getting stale"
            RECENCY_OVERDUE_MIN: 20,     // "! overdue"
            // Below 20 = "!! very overdue"

            // Trend text thresholds (based on opacity %)
            TREND_STEADY_MIN: 70,        // "‚Üë steady"
            TREND_OK_MIN: 50,            // "‚Üí ok"
            TREND_SLIPPING_MIN: 30,      // "‚Üì slipping"
            // Below 30 = "‚Üì‚Üì low"
        };

        // ============================================================================
        // FORMULA 1: PERCENT (7-Day Density)
        // ============================================================================
        /**
         * Calculate the 7-day density percentage for a capacity bar.
         *
         * @param {Object} capacityBarData - Contains:
         *   - high_exercises: Array of HIGH contribution exercises
         *   - medium_exercises: Array of MEDIUM contribution exercises
         *   - history_7_days: Map<exerciseId, daysActive> - days active in last 7
         *   - focuses: Array of focus names (if focus-aware calculation needed)
         * @returns {number} 0-100 percentage
         */
        function calculatePercent(capacityBarData) {
            const { high_exercises, medium_exercises, history_7_days, focuses } = capacityBarData;

            // If no HIGH exercises, treat MEDIUM as HIGH (capped at 50%)
            if (high_exercises.length === 0) {
                return calculatePercentForMediumAsHigh(medium_exercises, history_7_days);
            }

            // If focuses exist, calculate per-focus then aggregate
            if (focuses && focuses.length > 1) {
                return calculatePercentWithFocuses(high_exercises, medium_exercises, history_7_days, focuses);
            }

            // Standard calculation: sum HIGH contributions
            let highContribution = 0;
            for (const ex of high_exercises) {
                const days = history_7_days.get(ex.id) || 0;
                highContribution += (days / 7.0);
            }

            // Add MEDIUM bonus (capped)
            let mediumContribution = 0;
            for (const ex of medium_exercises) {
                const days = history_7_days.get(ex.id) || 0;
                mediumContribution += (days / 7.0) * COVERAGE_CONSTANTS.MEDIUM_WEIGHT;
            }

            const coverage = highContribution / high_exercises.length;
            const mediumBonus = Math.min(
                (mediumContribution / high_exercises.length) * 100,
                COVERAGE_CONSTANTS.MEDIUM_BONUS_CAP
            );

            return Math.min(coverage * 100 + mediumBonus, 100);
        }

        function calculatePercentForMediumAsHigh(medium_exercises, history_7_days) {
            if (medium_exercises.length === 0) return 0;

            let contribution = 0;
            for (const ex of medium_exercises) {
                const days = history_7_days.get(ex.id) || 0;
                contribution += (days / 7.0);
            }

            const coverage = contribution / medium_exercises.length;
            return Math.min(coverage * 100, 50); // Cap at 50% for MEDIUM-only
        }

        function calculatePercentWithFocuses(high_exercises, medium_exercises, history_7_days, focuses) {
            const focusGroups = groupExercisesByFocus(high_exercises);
            const focusPercents = [];

            for (const [focus, exercises] of focusGroups) {
                let contribution = 0;
                for (const ex of exercises) {
                    const days = history_7_days.get(ex.id) || 0;
                    contribution += (days / 7.0);
                }
                focusPercents.push((contribution / exercises.length) * 100);
            }

            // Aggregate: 60% worst + 40% avg(others)
            const worst = Math.min(...focusPercents);
            const others = focusPercents.filter(p => p !== worst);
            const avgOthers = others.length > 0 ? average(others) : worst;
            const base = COVERAGE_CONSTANTS.FOCUS_WORST_WEIGHT * worst +
                        COVERAGE_CONSTANTS.FOCUS_OTHERS_WEIGHT * avgOthers;

            // Add MEDIUM bonus
            let mediumContribution = 0;
            for (const ex of medium_exercises) {
                const days = history_7_days.get(ex.id) || 0;
                mediumContribution += (days / 7.0) * COVERAGE_CONSTANTS.MEDIUM_WEIGHT;
            }
            const mediumBonus = Math.min(
                (mediumContribution / high_exercises.length) * 100,
                COVERAGE_CONSTANTS.MEDIUM_BONUS_CAP
            );

            return Math.min(base + mediumBonus, 100);
        }

        // ============================================================================
        // FORMULA 2: COLOR SCORE (Recency)
        // ============================================================================
        /**
         * Calculate the color score (0-100) based on recency of most neglected exercise.
         *
         * @param {Object} capacityBarData - Contains:
         *   - high_exercises: Array of HIGH contribution exercises
         *   - medium_exercises: Array of MEDIUM contribution exercises
         *   - last_done_dates: Map<exerciseId, Date> - last done date per exercise
         *   - current_date: Date - today's date
         *   - focuses: Array of focus names (optional)
         * @returns {number} 0-100 color score
         */
        function calculateColorScore(capacityBarData) {
            const { high_exercises, medium_exercises, low_exercises, last_done_dates, current_date, focuses } = capacityBarData;

            // Determine which exercises to use based on highest available contribution
            let targetExercises;
            if (high_exercises.length > 0) {
                targetExercises = high_exercises;
            } else if (medium_exercises.length > 0) {
                targetExercises = medium_exercises;
            } else if (low_exercises && low_exercises.length > 0) {
                targetExercises = low_exercises;
            } else {
                return 0; // No exercises
            }

            // If focuses exist and using HIGH, calculate per-focus then aggregate
            if (targetExercises === high_exercises && focuses && focuses.length > 1) {
                return calculateColorWithFocuses(high_exercises, last_done_dates, current_date, focuses);
            }

            // Find oldest exercise (most neglected) among target exercises
            let maxDaysSince = 0;

            for (const ex of targetExercises) {
                const lastDone = last_done_dates.get(ex.id);
                if (!lastDone) return 0; // Never done = deep red

                const daysSince = daysBetween(lastDone, current_date);
                maxDaysSince = Math.max(maxDaysSince, daysSince);
            }

            return daysToColorScore(maxDaysSince);
        }

        /**
         * Convert days-since-last to a 0-100 color score.
         * Higher score = greener, lower score = redder.
         * Thresholds defined in COVERAGE_CONSTANTS.
         */
        function daysToColorScore(days) {
            const C = COVERAGE_CONSTANTS;
            if (days === 0) return C.COLOR_SCORE_DAY_0;
            if (days === 1) return C.COLOR_SCORE_DAY_1;
            if (days === 2) return C.COLOR_SCORE_DAY_2;
            if (days === 3) return C.COLOR_SCORE_DAY_3;
            if (days === 4) return C.COLOR_SCORE_DAY_4;
            return Math.max(0, C.COLOR_SCORE_DAY_4 - (days - 4) * C.COLOR_SCORE_DECAY);
        }

        function calculateColorForMedium(medium_exercises, last_done_dates, current_date) {
            if (medium_exercises.length === 0) return 0;

            let maxDaysSince = 0;
            for (const ex of medium_exercises) {
                const lastDone = last_done_dates.get(ex.id);
                if (!lastDone) return 0;

                const daysSince = daysBetween(lastDone, current_date);
                maxDaysSince = Math.max(maxDaysSince, daysSince);
            }

            return daysToColorScore(maxDaysSince);
        }

        function calculateColorWithFocuses(high_exercises, last_done_dates, current_date, focuses) {
            const focusGroups = groupExercisesByFocus(high_exercises);
            const focusScores = [];

            for (const [focus, exercises] of focusGroups) {
                let maxDays = 0;
                let hasNeverDone = false;

                for (const ex of exercises) {
                    const lastDone = last_done_dates.get(ex.id);
                    if (!lastDone) {
                        hasNeverDone = true;
                        break;
                    }
                    const daysSince = daysBetween(lastDone, current_date);
                    maxDays = Math.max(maxDays, daysSince);
                }

                if (hasNeverDone) {
                    focusScores.push(0);
                } else {
                    focusScores.push(daysToColorScore(maxDays));
                }
            }

            // Aggregate: 60% worst + 40% avg(others)
            const worst = Math.min(...focusScores);
            const others = focusScores.filter(s => s !== worst);
            const avgOthers = others.length > 0 ? average(others) : worst;

            return COVERAGE_CONSTANTS.FOCUS_WORST_WEIGHT * worst +
                   COVERAGE_CONSTANTS.FOCUS_OTHERS_WEIGHT * avgOthers;
        }

        // ============================================================================
        // FORMULA 3: OPACITY (21-Day Trend with Slow Decay, Fast Recovery)
        // ============================================================================
        /**
         * Calculate the opacity (0-100) based on 21-day trend.
         *
         * @param {Object} capacityBarData - Contains:
         *   - high_exercises: Array of HIGH contribution exercises
         *   - medium_exercises: Array of MEDIUM contribution exercises
         *   - history_21_days: Map<exerciseId, daysActive> - days active in last 21
         *   - history_7_days: Map<exerciseId, daysActive> - days active in last 7
         *   - last_done_dates: Map<exerciseId, Date> - last done date per exercise
         *   - current_date: Date - today's date
         *   - focuses: Array of focus names (optional)
         * @returns {number} 0-100 opacity percentage
         */
        function calculateOpacity(capacityBarData) {
            const {
                high_exercises, medium_exercises,
                history_21_days, history_7_days,
                last_done_dates, current_date, focuses
            } = capacityBarData;

            // If no HIGH exercises, use MEDIUM
            if (high_exercises.length === 0) {
                return calculateOpacityForMedium(
                    medium_exercises, history_21_days, history_7_days,
                    last_done_dates, current_date
                );
            }

            // If focuses exist, calculate per-focus then aggregate
            if (focuses && focuses.length > 1) {
                return calculateOpacityWithFocuses(
                    high_exercises, history_21_days, history_7_days,
                    last_done_dates, current_date, focuses
                );
            }

            // Calculate 21-day volume
            let total21day = 0;
            for (const ex of high_exercises) {
                total21day += history_21_days.get(ex.id) || 0;
            }
            const avg21day = total21day / high_exercises.length;

            // Calculate recent 7-day volume
            let totalRecent = 0;
            for (const ex of high_exercises) {
                totalRecent += history_7_days.get(ex.id) || 0;
            }
            const avgRecent = totalRecent / high_exercises.length;

            // Find most recent work
            let minDaysSince = Infinity;
            for (const ex of high_exercises) {
                const lastDone = last_done_dates.get(ex.id);
                if (lastDone) {
                    const daysSince = daysBetween(lastDone, current_date);
                    minDaysSince = Math.min(minDaysSince, daysSince);
                }
            }

            // Base opacity from 21-day volume (15 days = 100%)
            let base = Math.min(avg21day / COVERAGE_CONSTANTS.OPACITY_OPTIMAL_DAYS, 1.0) * 100;

            // SLOW DECAY (based on days-since-last)
            if (minDaysSince >= 14) {
                base *= 0.3;      // Heavy decay
            } else if (minDaysSince >= 10) {
                base *= 0.5;      // Moderate decay
            } else if (minDaysSince >= 7) {
                base *= 0.8;      // Slight decay
            }
            // else: <7 days, no decay

            // FAST RECOVERY (based on recent 7-day work)
            if (avgRecent >= COVERAGE_CONSTANTS.RECOVERY_STRONG_MIN) {
                return Math.max(base, 90);      // Solid week ‚Üí 90% floor
            } else if (avgRecent >= COVERAGE_CONSTANTS.RECOVERY_GOOD_MIN) {
                return Math.max(base, 70);      // Good week ‚Üí 70% floor
            } else if (avgRecent >= COVERAGE_CONSTANTS.RECOVERY_NOTICEABLE_MIN) {
                return Math.max(base, 50);      // Noticeable ‚Üí 50% floor
            }

            return Math.round(base);
        }

        function calculateOpacityForMedium(medium_exercises, history_21_days, history_7_days, last_done_dates, current_date) {
            if (medium_exercises.length === 0) return 20; // Minimum visibility

            let total21 = 0;
            let totalRecent = 0;
            let minDaysSince = Infinity;

            for (const ex of medium_exercises) {
                total21 += history_21_days.get(ex.id) || 0;
                totalRecent += history_7_days.get(ex.id) || 0;

                const lastDone = last_done_dates.get(ex.id);
                if (lastDone) {
                    const daysSince = daysBetween(lastDone, current_date);
                    minDaysSince = Math.min(minDaysSince, daysSince);
                }
            }

            const avg21 = total21 / medium_exercises.length;
            const avgRecent = totalRecent / medium_exercises.length;

            let base = Math.min(avg21 / COVERAGE_CONSTANTS.OPACITY_OPTIMAL_DAYS, 1.0) * 100;

            // Apply slow decay
            if (minDaysSince >= 14) base *= 0.3;
            else if (minDaysSince >= 10) base *= 0.5;
            else if (minDaysSince >= 7) base *= 0.8;

            // Apply fast recovery floors (reduced for MEDIUM)
            if (avgRecent >= 5) base = Math.max(base, 70);
            else if (avgRecent >= 4) base = Math.max(base, 50);
            else if (avgRecent >= 3) base = Math.max(base, 35);

            return Math.round(base);
        }

        function calculateOpacityWithFocuses(high_exercises, history_21_days, history_7_days, last_done_dates, current_date, focuses) {
            const focusGroups = groupExercisesByFocus(high_exercises);
            const focusOpacities = [];

            for (const [focus, exercises] of focusGroups) {
                let total21 = 0;
                let totalRecent = 0;
                let minDaysSince = Infinity;

                for (const ex of exercises) {
                    total21 += history_21_days.get(ex.id) || 0;
                    totalRecent += history_7_days.get(ex.id) || 0;

                    const lastDone = last_done_dates.get(ex.id);
                    if (lastDone) {
                        const daysSince = daysBetween(lastDone, current_date);
                        minDaysSince = Math.min(minDaysSince, daysSince);
                    }
                }

                const avg21 = total21 / exercises.length;
                const avgRecent = totalRecent / exercises.length;

                let base = Math.min(avg21 / COVERAGE_CONSTANTS.OPACITY_OPTIMAL_DAYS, 1.0) * 100;

                // Apply slow decay
                if (minDaysSince >= 14) base *= 0.3;
                else if (minDaysSince >= 10) base *= 0.5;
                else if (minDaysSince >= 7) base *= 0.8;

                // Apply fast recovery floors
                if (avgRecent >= 5) base = Math.max(base, 90);
                else if (avgRecent >= 4) base = Math.max(base, 70);
                else if (avgRecent >= 3) base = Math.max(base, 50);

                focusOpacities.push(base);
            }

            // Aggregate: 60% worst + 40% avg(others)
            const worst = Math.min(...focusOpacities);
            const others = focusOpacities.filter(o => o !== worst);
            const avgOthers = others.length > 0 ? average(others) : worst;

            return Math.round(
                COVERAGE_CONSTANTS.FOCUS_WORST_WEIGHT * worst +
                COVERAGE_CONSTANTS.FOCUS_OTHERS_WEIGHT * avgOthers
            );
        }

        // ============================================================================
        // COLOR SCORE TO RGB
        // ============================================================================
        /**
         * Convert a 0-100 color score to an RGB color string.
         * 100 = bright green, 50 = yellow, 0 = deep red
         */
        function colorScoreToRGB(score) {
            if (score >= 85) {
                // Green range (85-100)
                const t = (score - 85) / 15;
                return `rgb(${Math.round(132 - t * 116)}, ${Math.round(204 + t * 41)}, 129)`;
            } else if (score >= 60) {
                // Yellow-green range (60-85)
                const t = (score - 60) / 25;
                return `rgb(${Math.round(250 - t * 118)}, 204, ${Math.round(21 + t * 108)})`;
            } else if (score >= 35) {
                // Orange range (35-60)
                const t = (score - 35) / 25;
                return `rgb(249, ${Math.round(115 + t * 89)}, 22)`;
            } else if (score >= 15) {
                // Red-orange range (15-35)
                const t = (score - 15) / 20;
                return `rgb(${Math.round(239 + t * 10)}, ${Math.round(68 + t * 47)}, 22)`;
            } else {
                // Deep red range (0-15)
                const t = score / 15;
                return `rgb(${Math.round(185 + t * 54)}, ${Math.round(28 + t * 40)}, ${Math.round(28 - t * 6)})`;
            }
        }

        // ============================================================================
        // REGION BAR AGGREGATION
        // ============================================================================
        /**
         * Aggregate capacity bars into a region bar using weighted average.
         * Weight = (count of HIGH exercises) ^ 1.3
         */
        function calculateRegionBar(capacityBars) {
            const weights = capacityBars.map(cap => {
                const highCount = cap.exercises.filter(e => e.contribution === 'high').length;
                return Math.pow(highCount, COVERAGE_CONSTANTS.REGION_WEIGHT_EXPONENT);
            });
            const totalWeight = weights.reduce((a, b) => a + b, 0);

            if (totalWeight === 0) {
                return { percent: 0, color_score: 0, opacity: 20 };
            }

            const percent = Math.round(weightedAverage(capacityBars.map(c => c.percent), weights));
            const colorScore = Math.round(weightedAverage(capacityBars.map(c => c.color_score), weights));
            const opacity = Math.round(weightedAverage(capacityBars.map(c => c.opacity), weights));

            return { percent, color_score: colorScore, opacity };
        }

        // ============================================================================
        // HELPER FUNCTIONS
        // ============================================================================
        function daysBetween(date1, date2) {
            const d1 = new Date(date1);
            const d2 = new Date(date2);
            d1.setHours(0, 0, 0, 0);
            d2.setHours(0, 0, 0, 0);
            return Math.floor((d2 - d1) / (1000 * 60 * 60 * 24));
        }

        function average(arr) {
            if (arr.length === 0) return 0;
            return arr.reduce((a, b) => a + b, 0) / arr.length;
        }

        function weightedAverage(values, weights) {
            const totalWeight = weights.reduce((a, b) => a + b, 0);
            if (totalWeight === 0) return 0;

            let sum = 0;
            for (let i = 0; i < values.length; i++) {
                sum += values[i] * weights[i];
            }
            return sum / totalWeight;
        }

        function groupExercisesByFocus(exercises) {
            const groups = new Map();
            for (const ex of exercises) {
                const focus = ex.focus || 'general';
                if (!groups.has(focus)) {
                    groups.set(focus, []);
                }
                groups.get(focus).push(ex);
            }
            return groups;
        }

        // ============================================================================
        // END COVERAGE FORMULAS
        // ============================================================================


        // ============================================================================
        // APPLICATION STATE & INITIALIZATION
        // ============================================================================
        const SUPABASE_URL = 'https://zvgoaxdpkgfxklotqwpz.supabase.co';
        const SUPABASE_ANON_KEY = 'sb_publishable_pdyqh56HqQQ6OfHl3GG11A_W6IxqqWp';
        const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        let currentUser = null;
        let authToken = null;
        let userRole = null;
        let allLogs = [];
        let allRoles = [];
        let coverageData = {};
        let collapsedRegions = new Set();

        /**
         * Initialize the application
         */
        async function init() {
            // Check auth state
            const { data: { session } } = await supabaseClient.auth.getSession();

            if (session) {
                currentUser = session.user;
                authToken = session.access_token;
                hideAuthModal();
                await loadUserRole();
                await loadData();
            } else {
                showAuthModal();
            }

            // Auth state listener
            supabaseClient.auth.onAuthStateChange((event, session) => {
                if (event === 'SIGNED_IN') {
                    currentUser = session.user;
                    authToken = session.access_token;
                    hideAuthModal();
                    loadUserRole().then(() => loadData());
                } else if (event === 'SIGNED_OUT') {
                    currentUser = null;
                    authToken = null;
                    userRole = null;
                    showAuthModal();
                }
            });

            // Bind event handlers
            bindEventHandlers();
        }

        /**
         * Load user role to determine menu visibility.
         * Role is now loaded from /api/roles response in loadData().
         * This function just ensures menu visibility is updated.
         */
        async function loadUserRole() {
            // Role will be set by loadData() from /api/roles response
            // Default to patient if not yet loaded
            if (!userRole) {
                userRole = 'patient';
            }
            updateMenuVisibility();
        }

        /**
         * Update menu items based on user role
         */
        function updateMenuVisibility() {
            // Update user email display
            const userEmailEl = document.getElementById('userEmail');
            if (userEmailEl && currentUser) {
                userEmailEl.textContent = currentUser.email || 'Unknown';
            }

            const ptTrackerLink = document.getElementById('ptTrackerLink');
            if (ptTrackerLink) {
                // Only show PT Tracker link for patients
                if (userRole !== 'patient') {
                    ptTrackerLink.classList.add('hidden');
                } else {
                    ptTrackerLink.classList.remove('hidden');
                }
            }
        }

        // Auth functions
        function showAuthModal() {
            document.getElementById('authModal').classList.remove('hidden');
        }

        function hideAuthModal() {
            document.getElementById('authModal').classList.add('hidden');
        }

        async function signIn(email, password) {
            const { data, error } = await supabaseClient.auth.signInWithPassword({
                email,
                password
            });

            if (error) {
                throw error;
            }

            return data;
        }

        async function signOut() {
            await supabaseClient.auth.signOut();
        }

        /**
         * Load coverage data from API
         */
        async function loadData() {
            try {
                document.getElementById('coverageMatrix').innerHTML = '<div class="loading">Loading coverage data...</div>';

                // Load logs and roles in parallel
                const [logsResult, rolesResult] = await Promise.all([
                    fetchWithAuth('/api/logs?limit=1000'),
                    fetchWithAuth('/api/roles')
                ]);

                allLogs = logsResult.logs || [];
                allRoles = rolesResult.roles || [];

                // Extract user role from roles response and update menu
                if (rolesResult.user_role) {
                    userRole = rolesResult.user_role;
                    updateMenuVisibility();
                }

                // Calculate and render coverage
                calculateAndRenderCoverage();

            } catch (error) {
                console.error('Failed to load data:', error);
                document.getElementById('coverageMatrix').innerHTML =
                    '<div class="empty-state">Failed to load coverage data. Please try refreshing.</div>';
            }
        }

        async function fetchWithAuth(url, options = {}) {
            const headers = {
                'Content-Type': 'application/json',
                ...options.headers
            };

            if (authToken) {
                headers['Authorization'] = `Bearer ${authToken}`;
            }

            const response = await fetch(url, {
                ...options,
                headers
            });

            if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
            }

            return response.json();
        }

        /**
         * Calculate coverage using the THREE SIGNALS formulas and render
         */
        function calculateAndRenderCoverage() {
            const currentDate = new Date();
            const sevenDaysAgo = new Date(currentDate);
            sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
            const twentyOneDaysAgo = new Date(currentDate);
            twentyOneDaysAgo.setDate(twentyOneDaysAgo.getDate() - 21);

            // Build exercise history maps
            const history7Days = new Map();  // exerciseId -> days active in last 7
            const history21Days = new Map(); // exerciseId -> days active in last 21
            const lastDoneDates = new Map(); // exerciseId -> most recent date

            // Process logs to build history
            for (const log of allLogs) {
                const logDate = new Date(log.performed_at);
                const exerciseId = log.exercise_id;

                if (!exerciseId) continue;

                // Track last done date
                const existingDate = lastDoneDates.get(exerciseId);
                if (!existingDate || logDate > existingDate) {
                    lastDoneDates.set(exerciseId, logDate);
                }

                // Count unique days in 7-day window
                if (logDate >= sevenDaysAgo) {
                    const dateKey = logDate.toISOString().split('T')[0];
                    const key7 = `${exerciseId}_7_${dateKey}`;
                    if (!history7Days.has(key7)) {
                        history7Days.set(exerciseId, (history7Days.get(exerciseId) || 0) + 1);
                        history7Days.set(key7, true); // Mark this day as counted
                    }
                }

                // Count unique days in 21-day window
                if (logDate >= twentyOneDaysAgo) {
                    const dateKey = logDate.toISOString().split('T')[0];
                    const key21 = `${exerciseId}_21_${dateKey}`;
                    if (!history21Days.has(key21)) {
                        history21Days.set(exerciseId, (history21Days.get(exerciseId) || 0) + 1);
                        history21Days.set(key21, true);
                    }
                }
            }

            // Build coverage matrix: region ‚Üí capacity ‚Üí data
            coverageData = {};

            // Group roles by region ‚Üí capacity
            for (const role of allRoles) {
                const region = role.region || 'uncategorized';
                const capacity = role.capacity || 'general';
                const focus = role.focus || null;
                const contribution = role.contribution || 'low';
                const exerciseId = role.exercise_id;
                const exerciseName = role.exercises?.canonical_name || exerciseId;

                if (!coverageData[region]) {
                    coverageData[region] = {};
                }
                if (!coverageData[region][capacity]) {
                    coverageData[region][capacity] = {
                        exercises: [],
                        focuses: new Set()
                    };
                }

                const lastDoneDate = lastDoneDates.get(exerciseId) || null;
                coverageData[region][capacity].exercises.push({
                    id: exerciseId,
                    name: exerciseName,
                    contribution,
                    focus,
                    lastDone: lastDoneDate,
                    daysSince: lastDoneDate ? daysBetween(lastDoneDate, currentDate) : null,
                    days7: history7Days.get(exerciseId) || 0,
                    days21: history21Days.get(exerciseId) || 0
                });

                if (focus) {
                    coverageData[region][capacity].focuses.add(focus);
                }
            }

            // Calculate signals for each capacity bar
            for (const region of Object.keys(coverageData)) {
                for (const capacity of Object.keys(coverageData[region])) {
                    const capData = coverageData[region][capacity];
                    const exercises = capData.exercises;

                    const highExercises = exercises.filter(e => e.contribution === 'high');
                    const mediumExercises = exercises.filter(e => e.contribution === 'medium');
                    const lowExercises = exercises.filter(e => e.contribution === 'low');
                    const focuses = Array.from(capData.focuses);

                    // Build history maps for this capacity
                    const capHistory7 = new Map();
                    const capHistory21 = new Map();
                    const capLastDone = new Map();

                    for (const ex of exercises) {
                        capHistory7.set(ex.id, ex.days7);
                        capHistory21.set(ex.id, ex.days21);
                        if (ex.lastDone) {
                            capLastDone.set(ex.id, ex.lastDone);
                        }
                    }

                    const barData = {
                        high_exercises: highExercises,
                        medium_exercises: mediumExercises,
                        low_exercises: lowExercises,
                        history_7_days: capHistory7,
                        history_21_days: capHistory21,
                        last_done_dates: capLastDone,
                        current_date: currentDate,
                        focuses: focuses.length > 1 ? focuses : null
                    };

                    // Calculate THREE SIGNALS
                    capData.percent = calculatePercent(barData);
                    capData.color_score = calculateColorScore(barData);
                    capData.opacity = calculateOpacity(barData);
                    capData.color = colorScoreToRGB(capData.color_score);
                }
            }

            // Calculate region-level aggregates
            for (const region of Object.keys(coverageData)) {
                const capacityBars = Object.values(coverageData[region]);
                const regionBar = calculateRegionBar(capacityBars);
                coverageData[region]._regionBar = regionBar;
            }

            // Update summary
            updateSummary(lastDoneDates, history7Days, history21Days, currentDate);

            // Render
            renderCoverageMatrix();
        }

        /**
         * Update summary card
         */
        function updateSummary(lastDoneDates, history7Days, history21Days, currentDate) {
            // Last activity
            let mostRecentDate = null;
            for (const [, date] of lastDoneDates) {
                if (!mostRecentDate || date > mostRecentDate) {
                    mostRecentDate = date;
                }
            }

            const lastActivityEl = document.getElementById('lastActivity');
            if (mostRecentDate) {
                const daysAgo = daysBetween(mostRecentDate, currentDate);
                lastActivityEl.textContent = daysAgo === 0 ? 'Today' : `${daysAgo} days ago`;
                lastActivityEl.style.color = daysAgo <= 1 ? 'var(--success-color)' :
                                             daysAgo <= 3 ? 'var(--warning-color)' : 'var(--danger-color)';
            } else {
                lastActivityEl.textContent = 'No activity';
                lastActivityEl.style.color = 'var(--danger-color)';
            }

            // 7-day coverage (count of unique exercises done)
            const exercisesDone7Days = new Set();
            for (const [key] of history7Days) {
                if (!key.includes('_7_')) {
                    exercisesDone7Days.add(key);
                }
            }
            const totalExercises = new Set(allRoles.map(r => r.exercise_id)).size;
            const coverage7 = totalExercises > 0 ? Math.round((exercisesDone7Days.size / totalExercises) * 100) : 0;

            const weekCoverageEl = document.getElementById('weekCoverage');
            weekCoverageEl.textContent = `${coverage7}% (${exercisesDone7Days.size}/${totalExercises})`;
            weekCoverageEl.style.color = coverage7 >= 70 ? 'var(--success-color)' :
                                         coverage7 >= 40 ? 'var(--warning-color)' : 'var(--danger-color)';

            // 21-day trend - use average opacity from all region bars
            // This reflects actual engagement, not just binary "done once"
            let totalOpacity = 0;
            let regionCount = 0;
            for (const region of Object.keys(coverageData)) {
                const regionBar = coverageData[region]._regionBar;
                if (regionBar && typeof regionBar.opacity === 'number') {
                    totalOpacity += regionBar.opacity;
                    regionCount++;
                }
            }
            const avgOpacity = regionCount > 0 ? Math.round(totalOpacity / regionCount) : 0;

            const trendEl = document.getElementById('trendStatus');
            // Make trend understandable: higher % = more consistent over 3 weeks
            // Add arrows and plain language
            if (avgOpacity >= 70) {
                trendEl.textContent = `üìà Strong (${avgOpacity}%) - exercising consistently`;
                trendEl.style.color = 'var(--success-color)';
            } else if (avgOpacity >= 50) {
                trendEl.textContent = `‚ÜóÔ∏è Building (${avgOpacity}%) - good momentum`;
                trendEl.style.color = 'var(--success-color)';
            } else if (avgOpacity >= 30) {
                trendEl.textContent = `‚ÜòÔ∏è Fading (${avgOpacity}%) - activity dropping`;
                trendEl.style.color = 'var(--warning-color)';
            } else {
                trendEl.textContent = `üìâ Low (${avgOpacity}%) - needs more sessions`;
                trendEl.style.color = 'var(--danger-color)';
            }
        }

        /**
         * Render the coverage matrix
         */
        function renderCoverageMatrix() {
            const matrixEl = document.getElementById('coverageMatrix');

            if (Object.keys(coverageData).length === 0) {
                matrixEl.innerHTML = '<div class="empty-state">No coverage data available.</div>';
                return;
            }

            // Sort regions by color score (worst first)
            const regions = Object.keys(coverageData).sort((a, b) => {
                const aBar = coverageData[a]._regionBar || { color_score: 0 };
                const bBar = coverageData[b]._regionBar || { color_score: 0 };
                return aBar.color_score - bBar.color_score;
            });

            const html = regions.map(region => {
                const regionBar = coverageData[region]._regionBar || { percent: 0, color_score: 50, opacity: 50 };
                const capacities = Object.keys(coverageData[region]).filter(k => k !== '_regionBar');
                const isCollapsed = collapsedRegions.has(region);

                const capacitiesHtml = capacities.map(capacity => {
                    const capData = coverageData[region][capacity];
                    const exercises = capData.exercises || [];
                    const percent = Math.round(capData.percent || 0);
                    const colorScore = capData.color_score || 0;
                    const opacity = Math.max(20, capData.opacity || 20);
                    const color = capData.color || colorScoreToRGB(colorScore);

                    // Group exercises by focus
                    const focusGroups = new Map();
                    focusGroups.set('general', []);

                    for (const ex of exercises) {
                        const focus = ex.focus || 'general';
                        if (!focusGroups.has(focus)) {
                            focusGroups.set(focus, []);
                        }
                        focusGroups.get(focus).push(ex);
                    }

                    const hasFocuses = focusGroups.size > 1 || (focusGroups.size === 1 && !focusGroups.has('general'));

                    const focusesHtml = Array.from(focusGroups.entries()).map(([focus, focusExercises]) => {
                        if (focusExercises.length === 0) return '';

                        const doneCount = focusExercises.filter(e => e.lastDone).length;
                        const totalCount = focusExercises.length;

                        let statusClass = '';
                        if (doneCount === 0) statusClass = 'not-covered';
                        else if (doneCount < totalCount) statusClass = 'needs-attention';

                        // Render exercises as cards (matching pt/rehab_coverage.html format)
                        const exercisesHtml = focusExercises.map(ex => {
                            const isDone = !!ex.lastDone;
                            const daysSince = ex.daysSince || 0;
                            // Show warning if never done OR done more than 7 days ago
                            const isOverdue = !isDone || daysSince >= 7;
                            const statusIcon = isOverdue ? '‚ö†' : '‚úì';
                            const statusColor = isOverdue ? 'var(--warning-color)' : 'var(--success-color)';
                            const statusText = isDone ? `${daysSince}d ago` : 'never';

                            // Contribution level determines left border color
                            const contribution = ex.contribution || 'low';
                            const contribClass = `contrib-${contribution}`;

                            // Build metrics string: 7d sessions, 21d sessions
                            const sessions7 = ex.days7 || 0;
                            const sessions21 = ex.days21 || 0;
                            const metricsText = `7d: ${sessions7} ¬∑ 21d: ${sessions21}`;

                            return `
                                <div class="exercise-card ${contribClass}">
                                    <span class="exercise-card-icon" style="color: ${statusColor};">${statusIcon}</span>
                                    <div class="exercise-card-content">
                                        <div class="exercise-card-title">${escapeHtml(ex.name)}</div>
                                        <div class="exercise-card-meta">
                                            <span style="color: ${contribution === 'high' ? 'var(--danger-color)' : contribution === 'medium' ? 'var(--warning-color)' : 'var(--accent-color)'}; font-weight: 600; text-transform: uppercase; letter-spacing: 0.3px;">${contribution}</span>
                                            <span style="margin: 0 6px; opacity: 0.5;">‚Ä¢</span>
                                            <span style="color: ${statusColor};">${statusText}</span>
                                            <span style="margin: 0 6px; opacity: 0.5;">‚Ä¢</span>
                                            <span style="opacity: 0.7;">${metricsText}</span>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('');

                        return `
                            <div class="focus-item ${statusClass}">
                                <div class="focus-header">
                                    <span class="focus-name">${focus === 'general' ? 'General' : escapeHtml(focus.replace(/_/g, ' '))}</span>
                                    <span class="focus-stats">${doneCount}/${totalCount}</span>
                                </div>
                                <div class="exercise-list">${exercisesHtml}</div>
                            </div>
                        `;
                    }).join('');

                    // Build descriptive subtitle for the bar
                    // Color score: 100=green, 0=red. Map to recency.
                    const C = COVERAGE_CONSTANTS;
                    let recencyText = '';
                    if (colorScore >= C.RECENCY_RECENT_MIN) recencyText = '‚úì done recently';
                    else if (colorScore >= C.RECENCY_FEW_DAYS_MIN) recencyText = '~ a few days ago';
                    else if (colorScore >= C.RECENCY_STALE_MIN) recencyText = '‚ö† getting stale';
                    else if (colorScore >= C.RECENCY_OVERDUE_MIN) recencyText = '! overdue';
                    else recencyText = '!! very overdue';

                    // Make trend clearer with arrow
                    let trendText = '';
                    if (opacity >= C.TREND_STEADY_MIN) trendText = `‚Üë steady (${opacity}%)`;
                    else if (opacity >= C.TREND_OK_MIN) trendText = `‚Üí ok (${opacity}%)`;
                    else if (opacity >= C.TREND_SLIPPING_MIN) trendText = `‚Üì slipping (${opacity}%)`;
                    else trendText = `‚Üì‚Üì low (${opacity}%)`;

                    const barExplanation = `This week: ${percent}% ‚Ä¢ Last done: ${recencyText} ‚Ä¢ 3-week: ${trendText}`;

                    return `
                        <div class="capacity-group" id="cap-${escapeHtml(region)}-${escapeHtml(capacity)}">
                            <div class="capacity-header" data-action="toggle-capacity" data-region="${escapeHtml(region)}" data-capacity="${escapeHtml(capacity)}">
                                <span class="capacity-title">${escapeHtml(capacity)}</span>
                                <div class="capacity-bar-container">
                                    <div class="coverage-bar">
                                        <div class="coverage-bar-fill" style="width: ${percent}%; background: ${color}; opacity: ${opacity / 100};"></div>
                                    </div>
                                    <span class="capacity-stats">${percent}%</span>
                                </div>
                                <span class="capacity-chevron">‚Ä∫</span>
                            </div>
                            <div class="capacity-subtitle" style="font-size: 11px; color: var(--text-secondary); padding: 2px 0 4px 0; margin-left: 2px;">${barExplanation}</div>
                            <div class="focus-list">
                                ${focusesHtml}
                            </div>
                        </div>
                    `;
                }).join('');

                const regionColor = colorScoreToRGB(regionBar.color_score);
                const regionOpacity = Math.max(20, regionBar.opacity);

                return `
                    <div class="region-group">
                        <div class="region-header" data-action="toggle-region" data-region="${escapeHtml(region)}">
                            <span class="region-title">${escapeHtml(region)}</span>
                            <div class="region-bar-container">
                                <div class="coverage-bar">
                                    <div class="coverage-bar-fill" style="width: ${regionBar.percent}%; background: ${regionColor}; opacity: ${regionOpacity / 100};"></div>
                                </div>
                                <span class="region-stats">${regionBar.percent}%</span>
                            </div>
                            <span class="expand-icon ${isCollapsed ? 'collapsed' : ''}">‚ñº</span>
                        </div>
                        <div class="region-content ${isCollapsed ? 'collapsed' : ''}">
                            ${capacitiesHtml}
                        </div>
                    </div>
                `;
            }).join('');

            matrixEl.innerHTML = html;
        }

        /**
         * Toggle region collapse
         */
        function toggleRegion(region) {
            if (collapsedRegions.has(region)) {
                collapsedRegions.delete(region);
            } else {
                collapsedRegions.add(region);
            }
            renderCoverageMatrix();
        }

        /**
         * Toggle capacity expand
         */
        function toggleCapacity(region, capacity) {
            const el = document.getElementById(`cap-${region}-${capacity}`);
            if (el) {
                el.classList.toggle('expanded');
            }
        }

        /**
         * Toggle hamburger menu
         */
        function toggleHamburger() {
            const overlay = document.getElementById('hamburgerOverlay');
            const menu = document.getElementById('hamburgerMenu');
            overlay.classList.toggle('active');
            menu.classList.toggle('active');
        }

        /**
         * Toggle legend card expansion
         */
        function toggleLegend() {
            const legendCard = document.getElementById('legendCard');
            if (legendCard) {
                legendCard.classList.toggle('expanded');
            }
        }

        /**
         * Bind event handlers
         */
        function bindEventHandlers() {
            // Auth form
            document.getElementById('authForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                const email = document.getElementById('emailInput').value;
                const password = document.getElementById('passwordInput').value;
                const errorEl = document.getElementById('authError');

                try {
                    await signIn(email, password);
                    errorEl.textContent = '';
                } catch (error) {
                    errorEl.textContent = error.message;
                }
            });

            // Pointer events (iOS-safe)
            document.body.addEventListener('pointerup', async (e) => {
                const target = e.target.closest('[data-action]');
                if (!target) return;

                const action = target.dataset.action;

                switch (action) {
                    case 'toggle-hamburger':
                        toggleHamburger();
                        break;
                    case 'toggle-legend':
                        toggleLegend();
                        break;
                    case 'refresh-data':
                        toggleHamburger();
                        await loadData();
                        break;
                    case 'toggle-region':
                        toggleRegion(target.dataset.region);
                        break;
                    case 'toggle-capacity':
                        toggleCapacity(target.dataset.region, target.dataset.capacity);
                        break;
                    case 'sign-out':
                        toggleHamburger();
                        await signOut();
                        break;
                }
            });

            // Keyboard accessibility
            document.body.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    const target = e.target.closest('[data-action]');
                    if (target) {
                        e.preventDefault();
                        target.dispatchEvent(new PointerEvent('pointerup', { bubbles: true }));
                    }
                }
            });
        }

        /**
         * Escape HTML to prevent XSS
         */
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Start the app
        init();
    </script>
</body>
</html>
